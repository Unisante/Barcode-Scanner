(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define([], factory);
  else if (typeof exports === 'object')
    exports["Quagga"] = factory();
  else
    root["Quagga"] = factory();
})(window, function () {
  return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
        /******/
      }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
        /******/
      };
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
      /******/
    }
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
        /******/
      }
      /******/
    };
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
      }
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
      /******/
    };
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
      /******/
    };
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 105);
    /******/
  })
/************************************************************************/
/******/([
/* 0 */
/***/ (function (module, exports) {

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      module.exports = _defineProperty;

      /***/
    }),
/* 1 */
/***/ (function (module, exports) {

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      module.exports = _assertThisInitialized;

      /***/
    }),
/* 2 */
/***/ (function (module, exports) {

      function _getPrototypeOf(o) {
        module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      module.exports = _getPrototypeOf;

      /***/
    }),
/* 3 */
/***/ (function (module, exports) {

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      module.exports = _classCallCheck;

      /***/
    }),
/* 4 */
/***/ (function (module, exports) {

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      module.exports = _createClass;

      /***/
    }),
/* 5 */
/***/ (function (module, exports, __webpack_require__) {

      var _typeof = __webpack_require__(23);

      var assertThisInitialized = __webpack_require__(1);

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return assertThisInitialized(self);
      }

      module.exports = _possibleConstructorReturn;

      /***/
    }),
/* 6 */
/***/ (function (module, exports, __webpack_require__) {

      var setPrototypeOf = __webpack_require__(178);

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) setPrototypeOf(subClass, superClass);
      }

      module.exports = _inherits;

      /***/
    }),
/* 7 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = {
        EPSILON: __webpack_require__(58),
        create: __webpack_require__(59),
        clone: __webpack_require__(110),
        fromValues: __webpack_require__(111),
        copy: __webpack_require__(112),
        set: __webpack_require__(113),
        equals: __webpack_require__(114),
        exactEquals: __webpack_require__(115),
        add: __webpack_require__(116),
        subtract: __webpack_require__(60),
        sub: __webpack_require__(117),
        multiply: __webpack_require__(61),
        mul: __webpack_require__(118),
        divide: __webpack_require__(62),
        div: __webpack_require__(119),
        inverse: __webpack_require__(120),
        min: __webpack_require__(121),
        max: __webpack_require__(122),
        rotate: __webpack_require__(123),
        floor: __webpack_require__(124),
        ceil: __webpack_require__(125),
        round: __webpack_require__(126),
        scale: __webpack_require__(127),
        scaleAndAdd: __webpack_require__(128),
        distance: __webpack_require__(63),
        dist: __webpack_require__(129),
        squaredDistance: __webpack_require__(64),
        sqrDist: __webpack_require__(130),
        length: __webpack_require__(65),
        len: __webpack_require__(131),
        squaredLength: __webpack_require__(66),
        sqrLen: __webpack_require__(132),
        negate: __webpack_require__(133),
        normalize: __webpack_require__(134),
        dot: __webpack_require__(135),
        cross: __webpack_require__(136),
        lerp: __webpack_require__(137),
        random: __webpack_require__(138),
        transformMat2: __webpack_require__(139),
        transformMat2d: __webpack_require__(140),
        transformMat3: __webpack_require__(141),
        transformMat4: __webpack_require__(142),
        forEach: __webpack_require__(143),
        limit: __webpack_require__(144)
      };

      /***/
    }),
/* 8 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
      // ESM COMPAT FLAG
      __webpack_require__.r(__webpack_exports__);

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, "imageRef", function () { return /* binding */ imageRef; });
      __webpack_require__.d(__webpack_exports__, "computeIntegralImage2", function () { return /* binding */ computeIntegralImage2; });
      __webpack_require__.d(__webpack_exports__, "computeIntegralImage", function () { return /* binding */ computeIntegralImage; });
      __webpack_require__.d(__webpack_exports__, "thresholdImage", function () { return /* binding */ thresholdImage; });
      __webpack_require__.d(__webpack_exports__, "computeHistogram", function () { return /* binding */ computeHistogram; });
      __webpack_require__.d(__webpack_exports__, "sharpenLine", function () { return /* binding */ sharpenLine; });
      __webpack_require__.d(__webpack_exports__, "determineOtsuThreshold", function () { return /* binding */ determineOtsuThreshold; });
      __webpack_require__.d(__webpack_exports__, "otsuThreshold", function () { return /* binding */ otsuThreshold; });
      __webpack_require__.d(__webpack_exports__, "computeBinaryImage", function () { return /* binding */ computeBinaryImage; });
      __webpack_require__.d(__webpack_exports__, "cluster", function () { return /* binding */ cv_utils_cluster; });
      __webpack_require__.d(__webpack_exports__, "Tracer", function () { return /* binding */ Tracer; });
      __webpack_require__.d(__webpack_exports__, "DILATE", function () { return /* binding */ DILATE; });
      __webpack_require__.d(__webpack_exports__, "ERODE", function () { return /* binding */ ERODE; });
      __webpack_require__.d(__webpack_exports__, "dilate", function () { return /* binding */ dilate; });
      __webpack_require__.d(__webpack_exports__, "erode", function () { return /* binding */ erode; });
      __webpack_require__.d(__webpack_exports__, "subtract", function () { return /* binding */ subtract; });
      __webpack_require__.d(__webpack_exports__, "bitwiseOr", function () { return /* binding */ bitwiseOr; });
      __webpack_require__.d(__webpack_exports__, "countNonZero", function () { return /* binding */ countNonZero; });
      __webpack_require__.d(__webpack_exports__, "topGeneric", function () { return /* binding */ topGeneric; });
      __webpack_require__.d(__webpack_exports__, "grayArrayFromImage", function () { return /* binding */ grayArrayFromImage; });
      __webpack_require__.d(__webpack_exports__, "grayArrayFromContext", function () { return /* binding */ grayArrayFromContext; });
      __webpack_require__.d(__webpack_exports__, "grayAndHalfSampleFromCanvasData", function () { return /* binding */ grayAndHalfSampleFromCanvasData; });
      __webpack_require__.d(__webpack_exports__, "computeGray", function () { return /* binding */ computeGray; });
      __webpack_require__.d(__webpack_exports__, "loadImageArray", function () { return /* binding */ loadImageArray; });
      __webpack_require__.d(__webpack_exports__, "halfSample", function () { return /* binding */ halfSample; });
      __webpack_require__.d(__webpack_exports__, "hsv2rgb", function () { return /* binding */ hsv2rgb; });
      __webpack_require__.d(__webpack_exports__, "_computeDivisors", function () { return /* binding */ _computeDivisors; });
      __webpack_require__.d(__webpack_exports__, "calculatePatchSize", function () { return /* binding */ calculatePatchSize; });
      __webpack_require__.d(__webpack_exports__, "_parseCSSDimensionValues", function () { return /* binding */ _parseCSSDimensionValues; });
      __webpack_require__.d(__webpack_exports__, "_dimensionsConverters", function () { return /* binding */ _dimensionsConverters; });
      __webpack_require__.d(__webpack_exports__, "computeImageArea", function () { return /* binding */ computeImageArea; });

      // EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
      var gl_vec2 = __webpack_require__(7);

      // EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
      var gl_vec3 = __webpack_require__(100);

      // CONCATENATED MODULE: ./src/common/cluster.js
      // TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
      // into typescript. be warned. :-)

      var vec2 = {
        clone: gl_vec2["clone"],
        dot: gl_vec2["dot"]
      };
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
        create: function create(point, threshold) {
          var points = [];
          var center = {
            rad: 0,
            vec: vec2.clone([0, 0])
          };
          var pointMap = {};

          function _add(pointToAdd) {
            pointMap[pointToAdd.id] = pointToAdd;
            points.push(pointToAdd);
          }

          function updateCenter() {
            var i;
            var sum = 0;

            for (i = 0; i < points.length; i++) {
              sum += points[i].rad;
            }

            center.rad = sum / points.length;
            center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
          }

          function init() {
            _add(point);

            updateCenter();
          }

          init();
          return {
            add: function add(pointToAdd) {
              if (!pointMap[pointToAdd.id]) {
                _add(pointToAdd);

                updateCenter();
              }
            },
            fits: function fits(otherPoint) {
              // check cosine similarity to center-angle
              var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

              if (similarity > threshold) {
                return true;
              }

              return false;
            },
            getPoints: function getPoints() {
              return points;
            },
            getCenter: function getCenter() {
              return center;
            }
          };
        },
        createPoint: function createPoint(newPoint, id, property) {
          return {
            rad: newPoint[property],
            point: newPoint,
            id: id
          };
        }
      });
      // EXTERNAL MODULE: ./src/common/array_helper.ts
      var array_helper = __webpack_require__(10);

      // CONCATENATED MODULE: ./src/common/cv_utils.js
      /* eslint-disable no-mixed-operators */

      /* eslint-disable no-bitwise */




      var cv_utils_vec2 = {
        clone: gl_vec2["clone"]
      };
      var vec3 = {
        clone: gl_vec3["clone"]
      };
      /**
       * @param x x-coordinate
       * @param y y-coordinate
       * @return ImageReference {x,y} Coordinate
       */

      function imageRef(x, y) {
        var that = {
          x: x,
          y: y,
          toVec2: function toVec2() {
            return cv_utils_vec2.clone([this.x, this.y]);
          },
          toVec3: function toVec3() {
            return vec3.clone([this.x, this.y, 1]);
          },
          round: function round() {
            this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
            this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
            return this;
          }
        };
        return that;
      }
      /**
       * Computes an integral image of a given grayscale image.
       * @param imageDataContainer {ImageDataContainer} the image to be integrated
       */

      function computeIntegralImage2(imageWrapper, integralWrapper) {
        var imageData = imageWrapper.data;
        var width = imageWrapper.size.x;
        var height = imageWrapper.size.y;
        var integralImageData = integralWrapper.data;
        var sum = 0;
        var posA = 0;
        var posB = 0;
        var posC = 0;
        var posD = 0;
        var x;
        var y; // sum up first column

        posB = width;
        sum = 0;

        for (y = 1; y < height; y++) {
          sum += imageData[posA];
          integralImageData[posB] += sum;
          posA += width;
          posB += width;
        }

        posA = 0;
        posB = 1;
        sum = 0;

        for (x = 1; x < width; x++) {
          sum += imageData[posA];
          integralImageData[posB] += sum;
          posA++;
          posB++;
        }

        for (y = 1; y < height; y++) {
          posA = y * width + 1;
          posB = (y - 1) * width + 1;
          posC = y * width;
          posD = (y - 1) * width;

          for (x = 1; x < width; x++) {
            integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
            posA++;
            posB++;
            posC++;
            posD++;
          }
        }
      }
      function computeIntegralImage(imageWrapper, integralWrapper) {
        var imageData = imageWrapper.data;
        var width = imageWrapper.size.x;
        var height = imageWrapper.size.y;
        var integralImageData = integralWrapper.data;
        var sum = 0; // sum up first row

        for (var i = 0; i < width; i++) {
          sum += imageData[i];
          integralImageData[i] = sum;
        }

        for (var v = 1; v < height; v++) {
          sum = 0;

          for (var u = 0; u < width; u++) {
            sum += imageData[v * width + u];
            integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
          }
        }
      }
      function thresholdImage(imageWrapper, threshold, targetWrapper) {
        if (!targetWrapper) {
          // eslint-disable-next-line no-param-reassign
          targetWrapper = imageWrapper;
        }

        var imageData = imageWrapper.data;
        var length = imageData.length;
        var targetData = targetWrapper.data;

        while (length--) {
          targetData[length] = imageData[length] < threshold ? 1 : 0;
        }
      }
      function computeHistogram(imageWrapper, bitsPerPixel) {
        if (!bitsPerPixel) {
          // eslint-disable-next-line no-param-reassign
          bitsPerPixel = 8;
        }

        var imageData = imageWrapper.data;
        var length = imageData.length;
        var bitShift = 8 - bitsPerPixel;
        var bucketCnt = 1 << bitsPerPixel;
        var hist = new Int32Array(bucketCnt);

        while (length--) {
          hist[imageData[length] >> bitShift]++;
        }

        return hist;
      }
      function sharpenLine(line) {
        var i;
        var length = line.length;
        var left = line[0];
        var center = line[1];
        var right;

        for (i = 1; i < length - 1; i++) {
          right = line[i + 1]; //  -1 4 -1 kernel
          // eslint-disable-next-line no-param-reassign

          line[i - 1] = center * 2 - left - right & 255;
          left = center;
          center = right;
        }

        return line;
      }
      function determineOtsuThreshold(imageWrapper) {
        var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
        var hist;
        var bitShift = 8 - bitsPerPixel;

        function px(init, end) {
          var sum = 0;

          for (var i = init; i <= end; i++) {
            sum += hist[i];
          }

          return sum;
        }

        function mx(init, end) {
          var sum = 0;

          for (var i = init; i <= end; i++) {
            sum += i * hist[i];
          }

          return sum;
        }

        function determineThreshold() {
          var vet = [0];
          var p1;
          var p2;
          var p12;
          var m1;
          var m2;
          var m12;
          var max = (1 << bitsPerPixel) - 1;
          hist = computeHistogram(imageWrapper, bitsPerPixel);

          for (var k = 1; k < max; k++) {
            p1 = px(0, k);
            p2 = px(k + 1, max);
            p12 = p1 * p2;

            if (p12 === 0) {
              p12 = 1;
            }

            m1 = mx(0, k) * p2;
            m2 = mx(k + 1, max) * p1;
            m12 = m1 - m2;
            vet[k] = m12 * m12 / p12;
          }

          return array_helper["a" /* default */].maxIndex(vet);
        }

        var threshold = determineThreshold();
        return threshold << bitShift;
      }
      function otsuThreshold(imageWrapper, targetWrapper) {
        var threshold = determineOtsuThreshold(imageWrapper);
        thresholdImage(imageWrapper, threshold, targetWrapper);
        return threshold;
      } // local thresholding

      function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
        computeIntegralImage(imageWrapper, integralWrapper);

        if (!targetWrapper) {
          // eslint-disable-next-line no-param-reassign
          targetWrapper = imageWrapper;
        }

        var imageData = imageWrapper.data;
        var targetData = targetWrapper.data;
        var width = imageWrapper.size.x;
        var height = imageWrapper.size.y;
        var integralImageData = integralWrapper.data;
        var sum = 0;
        var v;
        var u;
        var kernel = 3;
        var A;
        var B;
        var C;
        var D;
        var avg;
        var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

        for (v = 0; v <= kernel; v++) {
          for (u = 0; u < width; u++) {
            targetData[v * width + u] = 0;
            targetData[(height - 1 - v) * width + u] = 0;
          }
        } // clear out left & right border


        for (v = kernel; v < height - kernel; v++) {
          for (u = 0; u <= kernel; u++) {
            targetData[v * width + u] = 0;
            targetData[v * width + (width - 1 - u)] = 0;
          }
        }

        for (v = kernel + 1; v < height - kernel - 1; v++) {
          for (u = kernel + 1; u < width - kernel; u++) {
            A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
            B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
            C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
            D = integralImageData[(v + kernel) * width + (u + kernel)];
            sum = D - C - B + A;
            avg = sum / size;
            targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
          }
        }
      }
      function cv_utils_cluster(points, threshold, property) {
        var i;
        var k;
        var thisCluster;
        var point;
        var clusters = [];

        if (!property) {
          // eslint-disable-next-line no-param-reassign
          property = 'rad';
        }

        function addToCluster(newPoint) {
          var found = false;

          for (k = 0; k < clusters.length; k++) {
            thisCluster = clusters[k];

            if (thisCluster.fits(newPoint)) {
              thisCluster.add(newPoint);
              found = true;
            }
          }

          return found;
        } // iterate over each cloud


        for (i = 0; i < points.length; i++) {
          point = cluster.createPoint(points[i], i, property);

          if (!addToCluster(point)) {
            clusters.push(cluster.create(point, threshold));
          }
        }

        return clusters;
      }
      var Tracer = {
        trace: function trace(points, vec) {
          var iteration;
          var maxIterations = 10;
          var top = [];
          var result = [];
          var centerPos = 0;
          var currentPos = 0;

          function trace(idx, forward) {
            var to;
            var toIdx;
            var predictedPos;
            var thresholdX = 1;
            var thresholdY = Math.abs(vec[1] / 10);
            var found = false;

            function match(pos, predicted) {
              if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
                return true;
              }

              return false;
            } // check if the next index is within the vec specifications
            // if not, check as long as the threshold is met


            var from = points[idx];

            if (forward) {
              predictedPos = {
                x: from.x + vec[0],
                y: from.y + vec[1]
              };
            } else {
              predictedPos = {
                x: from.x - vec[0],
                y: from.y - vec[1]
              };
            }

            toIdx = forward ? idx + 1 : idx - 1;
            to = points[toIdx]; // eslint-disable-next-line no-cond-assign

            while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
              toIdx = forward ? toIdx + 1 : toIdx - 1;
              to = points[toIdx];
            }

            return found ? toIdx : null;
          }

          for (iteration = 0; iteration < maxIterations; iteration++) {
            // randomly select point to start with
            centerPos = Math.floor(Math.random() * points.length); // trace forward

            top = [];
            currentPos = centerPos;
            top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

            while ((currentPos = trace(currentPos, true)) !== null) {
              top.push(points[currentPos]);
            }

            if (centerPos > 0) {
              currentPos = centerPos; // eslint-disable-next-line no-cond-assign

              while ((currentPos = trace(currentPos, false)) !== null) {
                top.push(points[currentPos]);
              }
            }

            if (top.length > result.length) {
              result = top;
            }
          }

          return result;
        }
      };
      var DILATE = 1;
      var ERODE = 2;
      function dilate(inImageWrapper, outImageWrapper) {
        var v;
        var u;
        var inImageData = inImageWrapper.data;
        var outImageData = outImageWrapper.data;
        var height = inImageWrapper.size.y;
        var width = inImageWrapper.size.x;
        var sum;
        var yStart1;
        var yStart2;
        var xStart1;
        var xStart2;

        for (v = 1; v < height - 1; v++) {
          for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum > 0 ? 1 : 0;
          }
        }
      }
      function erode(inImageWrapper, outImageWrapper) {
        var v;
        var u;
        var inImageData = inImageWrapper.data;
        var outImageData = outImageWrapper.data;
        var height = inImageWrapper.size.y;
        var width = inImageWrapper.size.x;
        var sum;
        var yStart1;
        var yStart2;
        var xStart1;
        var xStart2;

        for (v = 1; v < height - 1; v++) {
          for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum === 5 ? 1 : 0;
          }
        }
      }
      function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
        if (!resultImageWrapper) {
          // eslint-disable-next-line no-param-reassign
          resultImageWrapper = aImageWrapper;
        }

        var length = aImageWrapper.data.length;
        var aImageData = aImageWrapper.data;
        var bImageData = bImageWrapper.data;
        var cImageData = resultImageWrapper.data;

        while (length--) {
          cImageData[length] = aImageData[length] - bImageData[length];
        }
      }
      function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
        if (!resultImageWrapper) {
          // eslint-disable-next-line no-param-reassign
          resultImageWrapper = aImageWrapper;
        }

        var length = aImageWrapper.data.length;
        var aImageData = aImageWrapper.data;
        var bImageData = bImageWrapper.data;
        var cImageData = resultImageWrapper.data;

        while (length--) {
          cImageData[length] = aImageData[length] || bImageData[length];
        }
      }
      function countNonZero(imageWrapper) {
        var length = imageWrapper.data.length;
        var data = imageWrapper.data;
        var sum = 0;

        while (length--) {
          sum += data[length];
        }

        return sum;
      }
      function topGeneric(list, top, scoreFunc) {
        var i;
        var minIdx = 0;
        var min = 0;
        var queue = [];
        var score;
        var hit;
        var pos;

        for (i = 0; i < top; i++) {
          queue[i] = {
            score: 0,
            item: null
          };
        }

        for (i = 0; i < list.length; i++) {
          score = scoreFunc.apply(this, [list[i]]);

          if (score > min) {
            hit = queue[minIdx];
            hit.score = score;
            hit.item = list[i];
            min = Number.MAX_VALUE;

            for (pos = 0; pos < top; pos++) {
              if (queue[pos].score < min) {
                min = queue[pos].score;
                minIdx = pos;
              }
            }
          }
        }

        return queue;
      }
      function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
        ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
        var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
        computeGray(ctxData, array);
      }
      function grayArrayFromContext(ctx, size, offset, array) {
        var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
        computeGray(ctxData, array);
      }
      function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
        var topRowIdx = 0;
        var bottomRowIdx = size.x;
        var endIdx = Math.floor(canvasData.length / 4);
        var outWidth = size.x / 2;
        var outImgIdx = 0;
        var inWidth = size.x;
        var i;

        while (bottomRowIdx < endIdx) {
          for (i = 0; i < outWidth; i++) {
            // eslint-disable-next-line no-param-reassign
            outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
            outImgIdx++;
            topRowIdx += 2;
            bottomRowIdx += 2;
          }

          topRowIdx += inWidth;
          bottomRowIdx += inWidth;
        }
      }
      function computeGray(imageData, outArray, config) {
        var l = imageData.length / 4 | 0;
        var singleChannel = config && config.singleChannel === true;

        if (singleChannel) {
          for (var i = 0; i < l; i++) {
            // eslint-disable-next-line no-param-reassign
            outArray[i] = imageData[i * 4 + 0];
          }
        } else {
          for (var _i = 0; _i < l; _i++) {
            // eslint-disable-next-line no-param-reassign
            outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
          }
        }
      }
      function loadImageArray(src, callback) {
        var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
        var img = new Image();
        img.callback = callback;

        img.onload = function () {
          // eslint-disable-next-line no-param-reassign
          canvas.width = this.width; // eslint-disable-next-line no-param-reassign

          canvas.height = this.height;
          var ctx = canvas.getContext('2d');
          ctx.drawImage(this, 0, 0);
          var array = new Uint8Array(this.width * this.height);
          ctx.drawImage(this, 0, 0);

          var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
            data = _ctx$getImageData.data;

          computeGray(data, array);
          this.callback(array, {
            x: this.width,
            y: this.height
          }, this);
        };

        img.src = src;
      }
      /**
       * @param inImg {ImageWrapper} input image to be sampled
       * @param outImg {ImageWrapper} to be stored in
       */

      function halfSample(inImgWrapper, outImgWrapper) {
        var inImg = inImgWrapper.data;
        var inWidth = inImgWrapper.size.x;
        var outImg = outImgWrapper.data;
        var topRowIdx = 0;
        var bottomRowIdx = inWidth;
        var endIdx = inImg.length;
        var outWidth = inWidth / 2;
        var outImgIdx = 0;

        while (bottomRowIdx < endIdx) {
          for (var i = 0; i < outWidth; i++) {
            outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
            outImgIdx++;
            topRowIdx += 2;
            bottomRowIdx += 2;
          }

          topRowIdx += inWidth;
          bottomRowIdx += inWidth;
        }
      }
      function hsv2rgb(hsv) {
        var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
        var h = hsv[0];
        var s = hsv[1];
        var v = hsv[2];
        var c = v * s;
        var x = c * (1 - Math.abs(h / 60 % 2 - 1));
        var m = v - c;
        var r = 0;
        var g = 0;
        var b = 0;

        if (h < 60) {
          r = c;
          g = x;
        } else if (h < 120) {
          r = x;
          g = c;
        } else if (h < 180) {
          g = c;
          b = x;
        } else if (h < 240) {
          g = x;
          b = c;
        } else if (h < 300) {
          r = x;
          b = c;
        } else if (h < 360) {
          r = c;
          b = x;
        } // eslint-disable-next-line no-param-reassign


        rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

        rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

        rgb[2] = (b + m) * 255 | 0;
        return rgb;
      }
      function _computeDivisors(n) {
        var largeDivisors = [];
        var divisors = [];

        for (var i = 1; i < Math.sqrt(n) + 1; i++) {
          if (n % i === 0) {
            divisors.push(i);

            if (i !== n / i) {
              largeDivisors.unshift(Math.floor(n / i));
            }
          }
        }

        return divisors.concat(largeDivisors);
      }

      function _computeIntersection(arr1, arr2) {
        var i = 0;
        var j = 0;
        var result = [];

        while (i < arr1.length && j < arr2.length) {
          if (arr1[i] === arr2[j]) {
            result.push(arr1[i]);
            i++;
            j++;
          } else if (arr1[i] > arr2[j]) {
            j++;
          } else {
            i++;
          }
        }

        return result;
      }

      function calculatePatchSize(patchSize, imgSize) {
        var divisorsX = _computeDivisors(imgSize.x);

        var divisorsY = _computeDivisors(imgSize.y);

        var wideSide = Math.max(imgSize.x, imgSize.y);

        var common = _computeIntersection(divisorsX, divisorsY);

        var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
        var nrOfPatchesMap = {
          'x-small': 5,
          small: 4,
          medium: 3,
          large: 2,
          'x-large': 1
        };
        var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
        var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
        var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
        var optimalPatchSize;

        function findPatchSizeForDivisors(divisors) {
          var i = 0;
          var found = divisors[Math.floor(divisors.length / 2)];

          while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
            i++;
          }

          if (i > 0) {
            if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
              found = divisors[i - 1];
            } else {
              found = divisors[i];
            }
          }

          if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
            return {
              x: found,
              y: found
            };
          }

          return null;
        }

        optimalPatchSize = findPatchSizeForDivisors(common);

        if (!optimalPatchSize) {
          optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

          if (!optimalPatchSize) {
            optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
          }
        }

        return optimalPatchSize;
      }
      function _parseCSSDimensionValues(value) {
        var dimension = {
          value: parseFloat(value),
          unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
        };
        return dimension;
      }
      var _dimensionsConverters = {
        top: function top(dimension, context) {
          return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
        },
        right: function right(dimension, context) {
          return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
        },
        bottom: function bottom(dimension, context) {
          return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
        },
        left: function left(dimension, context) {
          return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
        }
      };
      function computeImageArea(inputWidth, inputHeight, area) {
        var context = {
          width: inputWidth,
          height: inputHeight
        };
        var parsedArea = Object.keys(area).reduce(function (result, key) {
          var value = area[key];

          var parsed = _parseCSSDimensionValues(value);

          var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


          result[key] = calculated;
          return result;
        }, {});
        return {
          sx: parsedArea.left,
          sy: parsedArea.top,
          sw: parsedArea.right - parsedArea.left,
          sh: parsedArea.bottom - parsedArea.top
        };
      }

      /***/
    }),
/* 9 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
        drawRect: function drawRect(pos, size, ctx, style) {
          ctx.strokeStyle = style.color;
          ctx.fillStyle = style.color;
          ctx.lineWidth = style.lineWidth || 1;
          ctx.beginPath();
          ctx.strokeRect(pos.x, pos.y, size.x, size.y);
        },
        drawPath: function drawPath(path, def, ctx, style) {
          ctx.strokeStyle = style.color;
          ctx.fillStyle = style.color;
          ctx.lineWidth = style.lineWidth;
          ctx.beginPath();
          ctx.moveTo(path[0][def.x], path[0][def.y]);

          for (var j = 1; j < path.length; j++) {
            ctx.lineTo(path[j][def.x], path[j][def.y]);
          }

          ctx.closePath();
          ctx.stroke();
        },
        drawImage: function drawImage(imageData, size, ctx) {
          var canvasData = ctx.getImageData(0, 0, size.x, size.y);
          var data = canvasData.data;
          var canvasDataPos = data.length;
          var imageDataPos = imageData.length;

          if (canvasDataPos / imageDataPos !== 4) {
            return false;
          }

          while (imageDataPos--) {
            var value = imageData[imageDataPos];
            data[--canvasDataPos] = 255;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
          }

          ctx.putImageData(canvasData, 0, 0);
          return true;
        }
      });

      /***/
    }),
/* 10 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
        init: function init(arr, val) {
          // arr.fill(val);
          var l = arr.length;

          while (l--) {
            arr[l] = val;
          }
        },

        /**
         * Shuffles the content of an array
         */
        shuffle: function shuffle(arr) {
          var i = arr.length - 1;

          for (i; i >= 0; i--) {
            var j = Math.floor(Math.random() * i);
            var x = arr[i];
            arr[i] = arr[j];
            arr[j] = x;
          }

          return arr;
        },
        toPointList: function toPointList(arr) {
          var rows = arr.reduce(function (p, n) {
            var row = "[".concat(n.join(','), "]");
            p.push(row);
            return p;
          }, []);
          return "[".concat(rows.join(',\r\n'), "]");
        },

        /**
         * returns the elements which's score is bigger than the threshold
         */
        threshold: function threshold(arr, _threshold, scoreFunc) {
          var queue = arr.reduce(function (prev, next) {
            if (scoreFunc.apply(arr, [next]) >= _threshold) {
              prev.push(next);
            }

            return prev;
          }, []);
          return queue;
        },
        maxIndex: function maxIndex(arr) {
          var max = 0;

          for (var i = 0; i < arr.length; i++) {
            if (arr[i] > arr[max]) {
              max = i;
            }
          }

          return max;
        },
        max: function max(arr) {
          var max = 0;

          for (var i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
              max = arr[i];
            }
          }

          return max;
        },
        sum: function sum(arr) {
          var length = arr.length;
          var sum = 0;

          while (length--) {
            sum += arr[length];
          }

          return sum;
        }
      });

      /***/
    }),
/* 11 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);







      var vec2 = {
        clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
      };

      function assertNumberPositive(val) {
        if (val < 0) {
          throw new Error("expected positive number, received ".concat(val));
        }
      }

      var ImageWrapper = /*#__PURE__*/function () {
        // Represents a basic image combining the data and size. In addition, some methods for
        // manipulation are contained within.
        function ImageWrapper(size, data) {
          var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
          var initialize = arguments.length > 3 ? arguments[3] : undefined;

          _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

          _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

          _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

          _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

          if (!data) {
            this.data = new ArrayType(size.x * size.y);

            if (initialize) {
              _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
            }
          } else {
            this.data = data;
          }

          this.size = size;
        } // tests if a position is within the image, extended out by a border on each side


        _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
          key: "inImageWithBorder",
          value: function inImageWithBorder(imgRef) {
            var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
            // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
            // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
            // assertNumberPositive(imgRef.x);
            // assertNumberPositive(imgRef.y);

            return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
          } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
          // end of new imageWrapper size.

        }, {
          key: "subImageAsCopy",
          value: function subImageAsCopy(imageWrapper, from) {
            assertNumberPositive(from.x);
            assertNumberPositive(from.y);
            var _imageWrapper$size = imageWrapper.size,
              sizeX = _imageWrapper$size.x,
              sizeY = _imageWrapper$size.y;

            for (var x = 0; x < sizeX; x++) {
              for (var y = 0; y < sizeY; y++) {
                // eslint-disable-next-line no-param-reassign
                imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
              }
            }

            return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
            // sure that all of it's parameters are set properly, something like
            // ImageWrapper.UpdateFrom()
            // that might take a provided data and size, and make sure there's no invalid indexMapping
            // hanging around, and such.
          } // Retrieve a grayscale value at the given pixel position of the image

        }, {
          key: "get",
          value: function get(x, y) {
            return this.data[y * this.size.x + x];
          } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
          // means)

        }, {
          key: "getSafe",
          value: function getSafe(x, y) {
            // cache indexMapping because if we're using it once, we'll probably need it a bunch more
            // too
            if (!this.indexMapping) {
              this.indexMapping = {
                x: [],
                y: []
              };

              for (var i = 0; i < this.size.x; i++) {
                this.indexMapping.x[i] = i;
                this.indexMapping.x[i + this.size.x] = i;
              }

              for (var _i = 0; _i < this.size.y; _i++) {
                this.indexMapping.y[_i] = _i;
                this.indexMapping.y[_i + this.size.y] = _i;
              }
            }

            return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
          } // Sets a given pixel position in the image to the given grayscale value

        }, {
          key: "set",
          value: function set(x, y, value) {
            this.data[y * this.size.x + x] = value;
            delete this.indexMapping;
            return this;
          } // Sets the border of the image (1 pixel) to zero

        }, {
          key: "zeroBorder",
          value: function zeroBorder() {
            var _this$size = this.size,
              width = _this$size.x,
              height = _this$size.y;

            for (var i = 0; i < width; i++) {
              // eslint-disable-next-line no-multi-assign
              this.data[i] = this.data[(height - 1) * width + i] = 0;
            }

            for (var _i2 = 1; _i2 < height - 1; _i2++) {
              // eslint-disable-next-line no-multi-assign
              this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
            }

            delete this.indexMapping;
            return this;
          } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
          // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
          // necessary to get it to run, no thought put into it yet.

        }, {
          key: "moments",
          value: function moments(labelCount) {
            var data = this.data;
            var x;
            var y;
            var height = this.size.y;
            var width = this.size.x;
            var val;
            var ysq;
            var labelSum = [];
            var i;
            var label;
            var mu11;
            var mu02;
            var mu20;
            var x_;
            var y_;
            var tmp;
            var result = [];
            var PI = Math.PI;
            var PI_4 = PI / 4;

            if (labelCount <= 0) {
              return result;
            }

            for (i = 0; i < labelCount; i++) {
              labelSum[i] = {
                m00: 0,
                m01: 0,
                m10: 0,
                m11: 0,
                m02: 0,
                m20: 0,
                theta: 0,
                rad: 0
              };
            }

            for (y = 0; y < height; y++) {
              ysq = y * y;

              for (x = 0; x < width; x++) {
                val = data[y * width + x];

                if (val > 0) {
                  label = labelSum[val - 1];
                  label.m00 += 1;
                  label.m01 += y;
                  label.m10 += x;
                  label.m11 += x * y;
                  label.m02 += ysq;
                  label.m20 += x * x;
                }
              }
            }

            for (i = 0; i < labelCount; i++) {
              label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

              if (!isNaN(label.m00) && label.m00 !== 0) {
                x_ = label.m10 / label.m00;
                y_ = label.m01 / label.m00;
                mu11 = label.m11 / label.m00 - x_ * y_;
                mu02 = label.m02 / label.m00 - y_ * y_;
                mu20 = label.m20 / label.m00 - x_ * x_;
                tmp = (mu02 - mu20) / (2 * mu11);
                tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

                label.theta = (tmp * 180 / PI + 90) % 180 - 90;

                if (label.theta < 0) {
                  label.theta += 180;
                }

                label.rad = tmp > PI ? tmp - PI : tmp;
                label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
                result.push(label);
              }
            }

            return result;
          } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

        }, {
          key: "getAsRGBA",
          value: function getAsRGBA() {
            var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
            var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

            for (var y = 0; y < this.size.y; y++) {
              for (var x = 0; x < this.size.x; x++) {
                var pixel = y * this.size.x + x;
                var current = this.get(x, y) * scale;
                ret[pixel * 4 + 0] = current;
                ret[pixel * 4 + 1] = current;
                ret[pixel * 4 + 2] = current;
                ret[pixel * 4 + 3] = 255;
              }
            }

            return ret;
          } // Display this ImageWrapper in a given Canvas element at the specified scale

        }, {
          key: "show",
          value: function show(canvas) {
            var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
            var ctx = canvas.getContext('2d');

            if (!ctx) {
              throw new Error('Unable to get canvas context');
            }

            var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

            canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

            canvas.height = this.size.y;
            var newFrame = new ImageData(data, frame.width, frame.height);
            ctx.putImageData(newFrame, 0, 0);
          } // Displays a specified SubImage area in a given canvas. This differs drastically from
          // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
          // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
          // but until I can visualize these functions side by side, I'm just going to copy the existing
          // implementation.

        }, {
          key: "overlay",
          value: function overlay(canvas, inScale, from) {
            var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
            var hsv = [0, 1, 1];
            var rgb = [0, 0, 0];
            var whiteRgb = [255, 255, 255];
            var blackRgb = [0, 0, 0];
            var result = [];
            var ctx = canvas.getContext('2d');

            if (!ctx) {
              throw new Error('Unable to get canvas context');
            }

            var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
            var data = frame.data;
            var length = this.data.length;

            while (length--) {
              hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

              result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__["hsv2rgb"])(hsv, rgb);
              var pos = length * 4;
              var _result = result;

              var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

              data[pos] = _result2[0];
              data[pos + 1] = _result2[1];
              data[pos + 2] = _result2[2];
              data[pos + 3] = 255;
            }

            ctx.putImageData(frame, from.x, from.y);
          }
        }]);

        return ImageWrapper;
      }();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

      /***/
    }),
/* 12 */
/***/ (function (module, exports) {

      var g; // This works in non-strict mode

      g = function () {
        return this;
      }();

      try {
        // This works if eval is allowed (see CSP)
        g = g || new Function("return this")();
      } catch (e) {
        // This works if the window reference is available
        if (typeof window === "object") g = window;
      } // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}


      module.exports = g;

      /***/
    }),
/* 13 */
/***/ (function (module, exports) {

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
      }

      module.exports = isObject;

      /***/
    }),
/* 14 */
/***/ (function (module, exports) {

      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */
      var isArray = Array.isArray;
      module.exports = isArray;

      /***/
    }),
/* 15 */
/***/ (function (module, exports) {

      // shim for using process in browser
      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }

      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }

      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }

        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();

      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        } // if setTimeout wasn't available but was latter defined


        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }

      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        } // if clearTimeout wasn't available but was latter defined


        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }

      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }

        draining = false;

        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }

        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }

        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;

        while (len) {
          currentQueue = queue;
          queue = [];

          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }

          queueIndex = -1;
          len = queue.length;
        }

        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);

        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }

        queue.push(new Item(fun, args));

        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }; // v8 likes predictible objects


      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }

      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };

      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues

      process.versions = {};

      function noop() { }

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };

      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };

      process.umask = function () {
        return 0;
      };

      /***/
    }),
/* 16 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      // a duplex stream is just a stream that is both readable and writable.
      // Since JS doesn't have multiple prototypal inheritance, this class
      // prototypally inherits from Readable, and then parasitically from
      // Writable.

      /*<replacement>*/

      var pna = __webpack_require__(38);
      /*</replacement>*/

      /*<replacement>*/


      var objectKeys = Object.keys || function (obj) {
        var keys = [];

        for (var key in obj) {
          keys.push(key);
        }

        return keys;
      };
      /*</replacement>*/


      module.exports = Duplex;
      /*<replacement>*/

      var util = Object.create(__webpack_require__(27));
      util.inherits = __webpack_require__(22);
      /*</replacement>*/

      var Readable = __webpack_require__(94);

      var Writable = __webpack_require__(55);

      util.inherits(Duplex, Readable);
      {
        // avoid scope creep, the keys array can then be collected
        var keys = objectKeys(Writable.prototype);

        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
      }

      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false) this.readable = false;
        if (options && options.writable === false) this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
        this.once('end', onend);
      }

      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function () {
          return this._writableState.highWaterMark;
        }
      }); // the no-half-open enforcer

      function onend() {
        // if we allow half-open state, or if the writable side ended,
        // then we're ok.
        if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
        // But allow more writes to happen in this tick.

        pna.nextTick(onEndNT, this);
      }

      function onEndNT(self) {
        self.end();
      }

      Object.defineProperty(Duplex.prototype, 'destroyed', {
        get: function () {
          if (this._readableState === undefined || this._writableState === undefined) {
            return false;
          }

          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function (value) {
          // we ignore the value if the stream
          // has not been initialized yet
          if (this._readableState === undefined || this._writableState === undefined) {
            return;
          } // backward compatibility, the user is explicitly
          // managing destroyed


          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });

      Duplex.prototype._destroy = function (err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
      };

      /***/
    }),
/* 17 */
/***/ (function (module, exports, __webpack_require__) {

      var baseMerge = __webpack_require__(179),
        createAssigner = __webpack_require__(234);
      /**
       * This method is like `_.assign` except that it recursively merges own and
       * inherited enumerable string keyed properties of source objects into the
       * destination object. Source properties that resolve to `undefined` are
       * skipped if a destination value exists. Array and plain object properties
       * are merged recursively. Other objects and value types are overridden by
       * assignment. Source objects are applied from left to right. Subsequent
       * sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {
       *   'a': [{ 'b': 2 }, { 'd': 4 }]
       * };
       *
       * var other = {
       *   'a': [{ 'c': 3 }, { 'e': 5 }]
       * };
       *
       * _.merge(object, other);
       * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
       */


      var merge = createAssigner(function (object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      module.exports = merge;

      /***/
    }),
/* 18 */
/***/ (function (module, exports, __webpack_require__) {

      var superPropBase = __webpack_require__(244);

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          module.exports = _get = Reflect.get;
        } else {
          module.exports = _get = function _get(target, property, receiver) {
            var base = superPropBase(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      module.exports = _get;

      /***/
    }),
/* 19 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(245);

      /***/
    }),
/* 20 */
/***/ (function (module, exports, __webpack_require__) {

      var freeGlobal = __webpack_require__(80);
      /** Detect free variable `self`. */


      var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
      /** Used as a reference to the global object. */

      var root = freeGlobal || freeSelf || Function('return this')();
      module.exports = root;

      /***/
    }),
/* 21 */
/***/ (function (module, exports) {

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return value != null && typeof value == 'object';
      }

      module.exports = isObjectLike;

      /***/
    }),
/* 22 */
/***/ (function (module, exports) {

      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;

            var TempCtor = function () { };

            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }

      /***/
    }),
/* 23 */
/***/ (function (module, exports) {

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          module.exports = _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          module.exports = _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      module.exports = _typeof;

      /***/
    }),
/* 24 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
      /**
       * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
       */
      var Tracer = {
        searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
        create: function create(imageWrapper, labelWrapper) {
          var imageData = imageWrapper.data;
          var labelData = labelWrapper.data;
          var searchDirections = this.searchDirections;
          var width = imageWrapper.size.x;
          var pos;

          function _trace(current, color, label, edgelabel) {
            var i;
            var y;
            var x;

            for (i = 0; i < 7; i++) {
              y = current.cy + searchDirections[current.dir][0];
              x = current.cx + searchDirections[current.dir][1];
              pos = y * width + x;

              if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
                labelData[pos] = label;
                current.cy = y;
                current.cx = x;
                return true;
              }

              if (labelData[pos] === 0) {
                labelData[pos] = edgelabel;
              }

              current.dir = (current.dir + 1) % 8;
            }

            return false;
          }

          function vertex2D(x, y, dir) {
            return {
              dir: dir,
              x: x,
              y: y,
              next: null,
              prev: null
            };
          }

          function _contourTracing(sy, sx, label, color, edgelabel) {
            var Fv = null;
            var Cv;
            var P;
            var ldir;
            var current = {
              cx: sx,
              cy: sy,
              dir: 0
            };

            if (_trace(current, color, label, edgelabel)) {
              Fv = vertex2D(sx, sy, current.dir);
              Cv = Fv;
              ldir = current.dir;
              P = vertex2D(current.cx, current.cy, 0);
              P.prev = Cv;
              Cv.next = P;
              P.next = null;
              Cv = P;

              do {
                current.dir = (current.dir + 6) % 8;

                _trace(current, color, label, edgelabel);

                if (ldir !== current.dir) {
                  Cv.dir = current.dir;
                  P = vertex2D(current.cx, current.cy, 0);
                  P.prev = Cv;
                  Cv.next = P;
                  P.next = null;
                  Cv = P;
                } else {
                  Cv.dir = ldir;
                  Cv.x = current.cx;
                  Cv.y = current.cy;
                }

                ldir = current.dir;
              } while (current.cx !== sx || current.cy !== sy);

              Fv.prev = Cv.prev;
              Cv.prev.next = Fv;
            }

            return Fv;
          }

          return {
            trace: function trace(current, color, label, edgelabel) {
              return _trace(current, color, label, edgelabel);
            },
            contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
              return _contourTracing(sy, sx, label, color, edgelabel);
            }
          };
        }
      };
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

      /***/
    }),
/* 25 */
/***/ (function (module, exports, __webpack_require__) {

      var Symbol = __webpack_require__(32),
        getRawTag = __webpack_require__(192),
        objectToString = __webpack_require__(193);
      /** `Object#toString` result references. */


      var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
      /** Built-in value references. */

      var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */

      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }

        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }

      module.exports = baseGetTag;

      /***/
    }),
/* 26 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
/* WEBPACK VAR INJECTION */(function (global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

        /* eslint-disable no-proto */


        var base64 = __webpack_require__(277);

        var ieee754 = __webpack_require__(278);

        var isArray = __webpack_require__(279);

        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Due to various browser bugs, sometimes the Object implementation will be used even
         * when the browser supports typed arrays.
         *
         * Note:
         *
         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *     incorrect length in some situations.
        
         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
         * get the Object implementation, which is slower but behaves correctly.
         */

        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
        /*
         * Export kMaxLength after typed array support is determined.
         */

        exports.kMaxLength = kMaxLength();

        function typedArraySupport() {
          try {
            var arr = new Uint8Array(1);
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function () {
                return 42;
              }
            };
            return arr.foo() === 42 && // typed array instances can be augmented
              typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
              arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
          } catch (e) {
            return false;
          }
        }

        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
        }

        function createBuffer(that, length) {
          if (kMaxLength() < length) {
            throw new RangeError('Invalid typed array length');
          }

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = new Uint8Array(length);
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            if (that === null) {
              that = new Buffer(length);
            }

            that.length = length;
          }

          return that;
        }
        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */


        function Buffer(arg, encodingOrOffset, length) {
          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
            return new Buffer(arg, encodingOrOffset, length);
          } // Common case.


          if (typeof arg === 'number') {
            if (typeof encodingOrOffset === 'string') {
              throw new Error('If encoding is specified then the first argument must be a string');
            }

            return allocUnsafe(this, arg);
          }

          return from(this, arg, encodingOrOffset, length);
        }

        Buffer.poolSize = 8192; // not used by this implementation
        // TODO: Legacy, not needed anymore. Remove in next major version.

        Buffer._augment = function (arr) {
          arr.__proto__ = Buffer.prototype;
          return arr;
        };

        function from(that, value, encodingOrOffset, length) {
          if (typeof value === 'number') {
            throw new TypeError('"value" argument must not be a number');
          }

          if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
            return fromArrayBuffer(that, value, encodingOrOffset, length);
          }

          if (typeof value === 'string') {
            return fromString(that, value, encodingOrOffset);
          }

          return fromObject(that, value);
        }
        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/


        Buffer.from = function (value, encodingOrOffset, length) {
          return from(null, value, encodingOrOffset, length);
        };

        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;

          if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true
            });
          }
        }

        function assertSize(size) {
          if (typeof size !== 'number') {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }

        function alloc(that, size, fill, encoding) {
          assertSize(size);

          if (size <= 0) {
            return createBuffer(that, size);
          }

          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
          }

          return createBuffer(that, size);
        }
        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/


        Buffer.alloc = function (size, fill, encoding) {
          return alloc(null, size, fill, encoding);
        };

        function allocUnsafe(that, size) {
          assertSize(size);
          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }

          return that;
        }
        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */


        Buffer.allocUnsafe = function (size) {
          return allocUnsafe(null, size);
        };
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */


        Buffer.allocUnsafeSlow = function (size) {
          return allocUnsafe(null, size);
        };

        function fromString(that, string, encoding) {
          if (typeof encoding !== 'string' || encoding === '') {
            encoding = 'utf8';
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }

          var length = byteLength(string, encoding) | 0;
          that = createBuffer(that, length);
          var actual = that.write(string, encoding);

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            that = that.slice(0, actual);
          }

          return that;
        }

        function fromArrayLike(that, array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          that = createBuffer(that, length);

          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255;
          }

          return that;
        }

        function fromArrayBuffer(that, array, byteOffset, length) {
          array.byteLength; // this throws if `array` is not a valid ArrayBuffer

          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('\'offset\' is out of bounds');
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('\'length\' is out of bounds');
          }

          if (byteOffset === undefined && length === undefined) {
            array = new Uint8Array(array);
          } else if (length === undefined) {
            array = new Uint8Array(array, byteOffset);
          } else {
            array = new Uint8Array(array, byteOffset, length);
          }

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = array;
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            that = fromArrayLike(that, array);
          }

          return that;
        }

        function fromObject(that, obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0;
            that = createBuffer(that, len);

            if (that.length === 0) {
              return that;
            }

            obj.copy(that, 0, 0, len);
            return that;
          }

          if (obj) {
            if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
              if (typeof obj.length !== 'number' || isnan(obj.length)) {
                return createBuffer(that, 0);
              }

              return fromArrayLike(that, obj);
            }

            if (obj.type === 'Buffer' && isArray(obj.data)) {
              return fromArrayLike(that, obj.data);
            }
          }

          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
        }

        function checked(length) {
          // Note: cannot use `length < kMaxLength()` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= kMaxLength()) {
            throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
          }

          return length | 0;
        }

        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0;
          }

          return Buffer.alloc(+length);
        }

        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer);
        };

        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError('Arguments must be Buffers');
          }

          if (a === b) return 0;
          var x = a.length;
          var y = b.length;

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;

            default:
              return false;
          }
        };

        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }

          if (list.length === 0) {
            return Buffer.alloc(0);
          }

          var i;

          if (length === undefined) {
            length = 0;

            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }

          var buffer = Buffer.allocUnsafe(length);
          var pos = 0;

          for (i = 0; i < list.length; ++i) {
            var buf = list[i];

            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }

            buf.copy(buffer, pos);
            pos += buf.length;
          }

          return buffer;
        };

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length;
          }

          if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
            return string.byteLength;
          }

          if (typeof string !== 'string') {
            string = '' + string;
          }

          var len = string.length;
          if (len === 0) return 0; // Use a for loop to avoid recursion

          var loweredCase = false;

          for (; ;) {
            switch (encoding) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return len;

              case 'utf8':
              case 'utf-8':
              case undefined:
                return utf8ToBytes(string).length;

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2;

              case 'hex':
                return len >>> 1;

              case 'base64':
                return base64ToBytes(string).length;

              default:
                if (loweredCase) return utf8ToBytes(string).length; // assume utf8

                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }

        Buffer.byteLength = byteLength;

        function slowToString(encoding, start, end) {
          var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.
          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

          if (start === undefined || start < 0) {
            start = 0;
          } // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.


          if (start > this.length) {
            return '';
          }

          if (end === undefined || end > this.length) {
            end = this.length;
          }

          if (end <= 0) {
            return '';
          } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


          end >>>= 0;
          start >>>= 0;

          if (end <= start) {
            return '';
          }

          if (!encoding) encoding = 'utf8';

          while (true) {
            switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end);

              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end);

              case 'ascii':
                return asciiSlice(this, start, end);

              case 'latin1':
              case 'binary':
                return latin1Slice(this, start, end);

              case 'base64':
                return base64Slice(this, start, end);

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end);

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
            }
          }
        } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
        // Buffer instances.


        Buffer.prototype._isBuffer = true;

        function swap(b, n, m) {
          var i = b[n];
          b[n] = b[m];
          b[m] = i;
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length;

          if (len % 2 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 16-bits');
          }

          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }

          return this;
        };

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length;

          if (len % 4 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 32-bits');
          }

          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }

          return this;
        };

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length;

          if (len % 8 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 64-bits');
          }

          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }

          return this;
        };

        Buffer.prototype.toString = function toString() {
          var length = this.length | 0;
          if (length === 0) return '';
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
          if (this === b) return true;
          return Buffer.compare(this, b) === 0;
        };

        Buffer.prototype.inspect = function inspect() {
          var str = '';
          var max = exports.INSPECT_MAX_BYTES;

          if (this.length > 0) {
            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
            if (this.length > max) str += ' ... ';
          }

          return '<Buffer ' + str + '>';
        };

        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError('Argument must be a Buffer');
          }

          if (start === undefined) {
            start = 0;
          }

          if (end === undefined) {
            end = target ? target.length : 0;
          }

          if (thisStart === undefined) {
            thisStart = 0;
          }

          if (thisEnd === undefined) {
            thisEnd = this.length;
          }

          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError('out of range index');
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }

          if (thisStart >= thisEnd) {
            return -1;
          }

          if (start >= end) {
            return 1;
          }

          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target) return 0;
          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf


        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1; // Normalize byteOffset

          if (typeof byteOffset === 'string') {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff;
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000;
          }

          byteOffset = +byteOffset; // Coerce to Number.

          if (isNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1;
          } // Normalize byteOffset: negative offsets start from the end of the buffer


          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

          if (byteOffset >= buffer.length) {
            if (dir) return -1; else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0; else return -1;
          } // Normalize val


          if (typeof val === 'string') {
            val = Buffer.from(val, encoding);
          } // Finally, search either indexOf (if dir is true) or lastIndexOf


          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1;
            }

            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === 'number') {
            val = val & 0xFF; // Search for a byte value [0-255]

            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }

            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }

          throw new TypeError('val must be string, number or Buffer');
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase();

            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }

              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i];
            } else {
              return buf.readUInt16BE(i * indexSize);
            }
          }

          var i;

          if (dir) {
            var foundIndex = -1;

            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

            for (i = byteOffset; i >= 0; i--) {
              var found = true;

              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              }

              if (found) return i;
            }
          }

          return -1;
        }

        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };

        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;

          if (!length) {
            length = remaining;
          } else {
            length = Number(length);

            if (length > remaining) {
              length = remaining;
            }
          } // must be an even number of digits


          var strLen = string.length;
          if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

          if (length > strLen / 2) {
            length = strLen / 2;
          }

          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }

          return i;
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }

        Buffer.prototype.write = function write(string, offset, length, encoding) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = 'utf8';
            length = this.length;
            offset = 0; // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === 'string') {
            encoding = offset;
            length = this.length;
            offset = 0; // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset | 0;

            if (isFinite(length)) {
              length = length | 0;
              if (encoding === undefined) encoding = 'utf8';
            } else {
              encoding = length;
              length = undefined;
            } // legacy write(string, encoding, offset, length) - remove in v0.13

          } else {
            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
          }

          var remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;

          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError('Attempt to write outside buffer bounds');
          }

          if (!encoding) encoding = 'utf8';
          var loweredCase = false;

          for (; ;) {
            switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length);

              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length);

              case 'ascii':
                return asciiWrite(this, string, offset, length);

              case 'latin1':
              case 'binary':
                return latin1Write(this, string, offset, length);

              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length);

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;

          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte;
                  }

                  break;

                case 2:
                  secondByte = buf[i + 1];

                  if ((secondByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                    if (tempCodePoint > 0x7F) {
                      codePoint = tempCodePoint;
                    }
                  }

                  break;

                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];

                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                      codePoint = tempCodePoint;
                    }
                  }

                  break;

                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];

                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint;
                    }
                  }

              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xFFFD;
              bytesPerSequence = 1;
            } else if (codePoint > 0xFFFF) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000;
              res.push(codePoint >>> 10 & 0x3FF | 0xD800);
              codePoint = 0xDC00 | codePoint & 0x3FF;
            }

            res.push(codePoint);
            i += bytesPerSequence;
          }

          return decodeCodePointsArray(res);
        } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety


        var MAX_ARGUMENTS_LENGTH = 0x1000;

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;

          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
          } // Decode in chunks to avoid "call stack size exceeded".


          var res = '';
          var i = 0;

          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
          }

          return res;
        }

        function asciiSlice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7F);
          }

          return ret;
        }

        function latin1Slice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }

          return ret;
        }

        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = '';

          for (var i = start; i < end; ++i) {
            out += toHex(buf[i]);
          }

          return out;
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = '';

          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }

          return res;
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;

          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }

          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }

          if (end < start) end = start;
          var newBuf;

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, undefined);

            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }

          return newBuf;
        };
        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */


        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
        }

        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;

          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }

          return val;
        };

        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;

          if (!noAssert) {
            checkOffset(offset, byteLength, this.length);
          }

          var val = this[offset + --byteLength];
          var mul = 1;

          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul;
          }

          return val;
        };

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset];
        };

        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };

        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };

        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
        };

        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };

        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;

          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }

          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };

        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var i = byteLength;
          var mul = 1;
          var val = this[offset + --i];

          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul;
          }

          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 0x80)) return this[offset];
          return (0xff - this[offset] + 1) * -1;
        };

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 0x8000 ? val | 0xFFFF0000 : val;
        };

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 0x8000 ? val | 0xFFFF0000 : val;
        };

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4);
        };

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4);
        };

        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8);
        };

        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8);
        };

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;

          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var mul = 1;
          var i = 0;
          this[offset] = value & 0xFF;

          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = value / mul & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;

          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var i = byteLength - 1;
          var mul = 1;
          this[offset + i] = value & 0xFF;

          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = value / mul & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 0xff;
          return offset + 1;
        };

        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffff + value + 1;

          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
          }
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }

          return offset + 2;
        };

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }

          return offset + 2;
        };

        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffffffff + value + 1;

          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
          }
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }

          return offset + 4;
        };

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }

          return offset + 4;
        };

        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;

          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 0xFF;

          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }

            this[offset + i] = (value / mul >> 0) - sub & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;

          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = byteLength - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 0xFF;

          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }

            this[offset + i] = (value / mul >> 0) - sub & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 0xff + value + 1;
          this[offset] = value & 0xff;
          return offset + 1;
        };

        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }

          return offset + 2;
        };

        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }

          return offset + 2;
        };

        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }

          return offset + 4;
        };

        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (value < 0) value = 0xffffffff + value + 1;

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }

          return offset + 4;
        };

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
          if (offset < 0) throw new RangeError('Index out of range');
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
          }

          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
          }

          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

          if (targetStart < 0) {
            throw new RangeError('targetStart out of bounds');
          }

          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
          if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

          if (end > this.length) end = this.length;

          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }

          var len = end - start;
          var i;

          if (this === target && start < targetStart && targetStart < end) {
            // descending copy from end
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
            // ascending copy from start
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
          }

          return len;
        }; // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])


        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === 'string') {
            if (typeof start === 'string') {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === 'string') {
              encoding = end;
              end = this.length;
            }

            if (val.length === 1) {
              var code = val.charCodeAt(0);

              if (code < 256) {
                val = code;
              }
            }

            if (encoding !== undefined && typeof encoding !== 'string') {
              throw new TypeError('encoding must be a string');
            }

            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }
          } else if (typeof val === 'number') {
            val = val & 255;
          } // Invalid ranges are not set to a default, so can range check early.


          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError('Out of range index');
          }

          if (end <= start) {
            return this;
          }

          start = start >>> 0;
          end = end === undefined ? this.length : end >>> 0;
          if (!val) val = 0;
          var i;

          if (typeof val === 'number') {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
            var len = bytes.length;

            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }

          return this;
        }; // HELPER FUNCTIONS
        // ================


        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

        function base64clean(str) {
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

          if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

          while (str.length % 4 !== 0) {
            str = str + '=';
          }

          return str;
        }

        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, '');
        }

        function toHex(n) {
          if (n < 16) return '0' + n.toString(16);
          return n.toString(16);
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i); // is surrogate component

            if (codePoint > 0xD7FF && codePoint < 0xE000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  continue;
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  continue;
                } // valid lead


                leadSurrogate = codePoint;
                continue;
              } // 2 leads in a row


              if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
              } // valid surrogate pair


              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            }

            leadSurrogate = null; // encode utf8

            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break;
              bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break;
              bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break;
              bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
            } else {
              throw new Error('Invalid code point');
            }
          }

          return bytes;
        }

        function asciiToBytes(str) {
          var byteArray = [];

          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xFF);
          }

          return byteArray;
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];

          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }

          return byteArray;
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }

          return i;
        }

        function isnan(val) {
          return val !== val; // eslint-disable-line no-self-compare
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12)))

      /***/
    }),
/* 27 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (Buffer) {// Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // NOTE: These type checking functions intentionally don't use `instanceof`
        // because it is fragile and can be easily faked with `Object.create()`.
        function isArray(arg) {
          if (Array.isArray) {
            return Array.isArray(arg);
          }

          return objectToString(arg) === '[object Array]';
        }

        exports.isArray = isArray;

        function isBoolean(arg) {
          return typeof arg === 'boolean';
        }

        exports.isBoolean = isBoolean;

        function isNull(arg) {
          return arg === null;
        }

        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
          return arg == null;
        }

        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
          return typeof arg === 'number';
        }

        exports.isNumber = isNumber;

        function isString(arg) {
          return typeof arg === 'string';
        }

        exports.isString = isString;

        function isSymbol(arg) {
          return typeof arg === 'symbol';
        }

        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
          return arg === void 0;
        }

        exports.isUndefined = isUndefined;

        function isRegExp(re) {
          return objectToString(re) === '[object RegExp]';
        }

        exports.isRegExp = isRegExp;

        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }

        exports.isObject = isObject;

        function isDate(d) {
          return objectToString(d) === '[object Date]';
        }

        exports.isDate = isDate;

        function isError(e) {
          return objectToString(e) === '[object Error]' || e instanceof Error;
        }

        exports.isError = isError;

        function isFunction(arg) {
          return typeof arg === 'function';
        }

        exports.isFunction = isFunction;

        function isPrimitive(arg) {
          return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
            typeof arg === 'undefined';
        }

        exports.isPrimitive = isPrimitive;
        exports.isBuffer = Buffer.isBuffer;

        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(26).Buffer))

      /***/
    }),
/* 28 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
/* WEBPACK VAR INJECTION */(function (global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(102);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(103);










        var _config;

        var _currentImageWrapper;

        var _skelImageWrapper;

        var _subImageWrapper;

        var _labelImageWrapper;

        var _patchGrid;

        var _patchLabelGrid;

        var _imageToPatchGrid;

        var _binaryImageWrapper;

        var _patchSize;

        var _canvasContainer = {
          ctx: {
            binary: null
          },
          dom: {
            binary: null
          }
        };
        var _numPatches = {
          x: 0,
          y: 0
        };

        var _inputImageWrapper;

        var _skeletonizer;

        function initBuffers() {
          if (_config.halfSample) {
            _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
              // eslint-disable-next-line no-bitwise
              x: _inputImageWrapper.size.x / 2 | 0,
              // eslint-disable-next-line no-bitwise
              y: _inputImageWrapper.size.y / 2 | 0
            });
          } else {
            _currentImageWrapper = _inputImageWrapper;
          }

          _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

          _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

          _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
          _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
          _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
          var skeletonImageData = new ArrayBuffer(64 * 1024);
          _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
          _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
          _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
            size: _patchSize.x
          }, skeletonImageData);
          _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
            // eslint-disable-next-line no-bitwise
            x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
            // eslint-disable-next-line no-bitwise
            y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
          }, undefined, Array, true);
          _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
          _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
        }

        function initCanvas() {
          if (_config.useWorker || typeof document === 'undefined') {
            return;
          }

          _canvasContainer.dom.binary = document.createElement('canvas');
          _canvasContainer.dom.binary.className = 'binaryBuffer';

          if (true && _config.debug.showCanvas === true) {
            document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
          }

          _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
          _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
          _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
        }
        /**
         * Creates a bounding box which encloses all the given patches
         * @returns {Array} The minimal bounding box
         */


        function boxFromPatches(patches) {
          var overAvg;
          var i;
          var j;
          var patch;
          var transMat;
          var minx = _binaryImageWrapper.size.x;
          var miny = _binaryImageWrapper.size.y;
          var maxx = -_binaryImageWrapper.size.x;
          var maxy = -_binaryImageWrapper.size.y;
          var box;
          var scale; // draw all patches which are to be taken into consideration

          overAvg = 0;

          for (i = 0; i < patches.length; i++) {
            patch = patches[i];
            overAvg += patch.rad;

            if (true && _config.debug.showPatches) {
              _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
                color: 'red'
              });
            }
          }

          overAvg /= patches.length;
          overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

          if (overAvg < 0) {
            overAvg += 180;
          }

          overAvg = (180 - overAvg) * Math.PI / 180;
          transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

          for (i = 0; i < patches.length; i++) {
            patch = patches[i];

            for (j = 0; j < 4; j++) {
              gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
            }

            if (true && _config.debug.boxFromPatches.showTransformed) {
              _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(patch.box, {
                x: 0,
                y: 1
              }, _canvasContainer.ctx.binary, {
                color: '#99ff00',
                lineWidth: 2
              });
            }
          } // find bounding box


          for (i = 0; i < patches.length; i++) {
            patch = patches[i];

            for (j = 0; j < 4; j++) {
              if (patch.box[j][0] < minx) {
                minx = patch.box[j][0];
              }

              if (patch.box[j][0] > maxx) {
                maxx = patch.box[j][0];
              }

              if (patch.box[j][1] < miny) {
                miny = patch.box[j][1];
              }

              if (patch.box[j][1] > maxy) {
                maxy = patch.box[j][1];
              }
            }
          }

          box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

          if (true && _config.debug.boxFromPatches.showTransformedBox) {
            _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
              x: 0,
              y: 1
            }, _canvasContainer.ctx.binary, {
              color: '#ff0000',
              lineWidth: 2
            });
          }

          scale = _config.halfSample ? 2 : 1; // reverse rotation;

          transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

          for (j = 0; j < 4; j++) {
            gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
          }

          if (true && _config.debug.boxFromPatches.showBB) {
            _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
              x: 0,
              y: 1
            }, _canvasContainer.ctx.binary, {
              color: '#ff0000',
              lineWidth: 2
            });
          }

          for (j = 0; j < 4; j++) {
            gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
          }

          return box;
        }
        /**
         * Creates a binary image of the current image
         */


        function binarizeImage() {
          Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["otsuThreshold"])(_currentImageWrapper, _binaryImageWrapper);

          _binaryImageWrapper.zeroBorder();

          if (true && _config.debug.showCanvas) {
            _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
          }
        }
        /**
         * Iterate over the entire image
         * extract patches
         */


        function findPatches() {
          var i;
          var j;
          var x;
          var y;
          var moments;
          var patchesFound = [];
          var rasterizer;
          var rasterResult;
          var patch;

          for (i = 0; i < _numPatches.x; i++) {
            for (j = 0; j < _numPatches.y; j++) {
              x = _subImageWrapper.size.x * i;
              y = _subImageWrapper.size.y * j; // seperate parts

              skeletonize(x, y); // Rasterize, find individual bars

              _skelImageWrapper.zeroBorder();

              _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
              rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
              rasterResult = rasterizer.rasterize(0);

              if (true && _config.debug.showLabels) {
                _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
                  x: x,
                  y: y
                });
              } // calculate moments from the skeletonized patch


              moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

              patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
            }
          }

          if (true && _config.debug.showFoundPatches) {
            for (i = 0; i < patchesFound.length; i++) {
              patch = patchesFound[i];
              _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
                color: '#99ff00',
                lineWidth: 2
              });
            }
          }

          return patchesFound;
        }
        /**
         * Finds those connected areas which contain at least 6 patches
         * and returns them ordered DESC by the number of contained patches
         * @param {Number} maxLabel
         */


        function findBiggestConnectedAreas(maxLabel) {
          var i;
          var sum;
          var labelHist = [];
          var topLabels = [];

          for (i = 0; i < maxLabel; i++) {
            labelHist.push(0);
          }

          sum = _patchLabelGrid.data.length;

          while (sum--) {
            if (_patchLabelGrid.data[sum] > 0) {
              labelHist[_patchLabelGrid.data[sum] - 1]++;
            }
          }

          labelHist = labelHist.map(function (val, idx) {
            return {
              val: val,
              label: idx + 1
            };
          });
          labelHist.sort(function (a, b) {
            return b.val - a.val;
          }); // extract top areas with at least 6 patches present

          topLabels = labelHist.filter(function (el) {
            return el.val >= 5;
          });
          return topLabels;
        }
        /**
         *
         */


        function findBoxes(topLabels, maxLabel) {
          var i;
          var j;
          var sum;
          var patches = [];
          var patch;
          var box;
          var boxes = [];
          var hsv = [0, 1, 1];
          var rgb = [0, 0, 0];

          for (i = 0; i < topLabels.length; i++) {
            sum = _patchLabelGrid.data.length;
            patches.length = 0;

            while (sum--) {
              if (_patchLabelGrid.data[sum] === topLabels[i].label) {
                patch = _imageToPatchGrid.data[sum];
                patches.push(patch);
              }
            }

            box = boxFromPatches(patches);

            if (box) {
              boxes.push(box); // draw patch-labels if requested

              if (true && _config.debug.showRemainingPatchLabels) {
                for (j = 0; j < patches.length; j++) {
                  patch = patches[j];
                  hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
                  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
                  _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
                    color: "rgb(".concat(rgb.join(','), ")"),
                    lineWidth: 2
                  });
                }
              }
            }
          }

          return boxes;
        }
        /**
         * Find similar moments (via cluster)
         * @param {Object} moments
         */


        function similarMoments(moments) {
          var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["cluster"])(moments, 0.90);
          var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["topGeneric"])(clusters, 1, function (e) {
            return e.getPoints().length;
          });
          var points = [];
          var result = [];

          if (topCluster.length === 1) {
            points = topCluster[0].item.getPoints();

            for (var i = 0; i < points.length; i++) {
              result.push(points[i].point);
            }
          }

          return result;
        }

        function skeletonize(x, y) {
          _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));

          _skeletonizer.skeletonize(); // Show skeleton if requested


          if (true && _config.debug.showSkeleton) {
            _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));
          }
        }
        /**
         * Extracts and describes those patches which seem to contain a barcode pattern
         * @param {Array} moments
         * @param {Object} patchPos,
         * @param {Number} x
         * @param {Number} y
         * @returns {Array} list of patches
         */


        function describePatch(moments, patchPos, x, y) {
          var k;
          var avg;
          var eligibleMoments = [];
          var matchingMoments;
          var patch;
          var patchesFound = [];
          var minComponentWeight = Math.ceil(_patchSize.x / 3);

          if (moments.length >= 2) {
            // only collect moments which's area covers at least minComponentWeight pixels.
            for (k = 0; k < moments.length; k++) {
              if (moments[k].m00 > minComponentWeight) {
                eligibleMoments.push(moments[k]);
              }
            } // if at least 2 moments are found which have at least minComponentWeights covered


            if (eligibleMoments.length >= 2) {
              matchingMoments = similarMoments(eligibleMoments);
              avg = 0; // determine the similarity of the moments

              for (k = 0; k < matchingMoments.length; k++) {
                avg += matchingMoments[k].rad;
              } // Only two of the moments are allowed not to fit into the equation
              // add the patch to the set


              if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
                avg /= matchingMoments.length;
                patch = {
                  index: patchPos[1] * _numPatches.x + patchPos[0],
                  pos: {
                    x: x,
                    y: y
                  },
                  box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
                  moments: matchingMoments,
                  rad: avg,
                  vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
                };
                patchesFound.push(patch);
              }
            }
          }

          return patchesFound;
        }
        /**
         * finds patches which are connected and share the same orientation
         * @param {Object} patchesFound
         */


        function rasterizeAngularSimilarity(patchesFound) {
          var label = 0;
          var threshold = 0.95;
          var currIdx = 0;
          var j;
          var patch;
          var hsv = [0, 1, 1];
          var rgb = [0, 0, 0];

          function notYetProcessed() {
            var i;

            for (i = 0; i < _patchLabelGrid.data.length; i++) {
              if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
                return i;
              }
            }

            return _patchLabelGrid.length;
          }

          function trace(currentIdx) {
            var x;
            var y;
            var currentPatch;
            var idx;
            var dir;
            var current = {
              x: currentIdx % _patchLabelGrid.size.x,
              y: currentIdx / _patchLabelGrid.size.x | 0
            };
            var similarity;

            if (currentIdx < _patchLabelGrid.data.length) {
              currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

              _patchLabelGrid.data[currentIdx] = label;

              for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
                y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
                x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
                idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

                if (_patchGrid.data[idx] === 0) {
                  _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

                  continue;
                }

                if (_patchLabelGrid.data[idx] === 0) {
                  similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

                  if (similarity > threshold) {
                    trace(idx);
                  }
                }
              }
            }
          } // prepare for finding the right patches


          _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
          _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
          _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

          for (j = 0; j < patchesFound.length; j++) {
            patch = patchesFound[j];
            _imageToPatchGrid.data[patch.index] = patch;
            _patchGrid.data[patch.index] = 1;
          } // rasterize the patches found to determine area


          _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


          while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
            label++;
            trace(currIdx);
          } // draw patch-labels if requested


          if (true && _config.debug.showPatchLabels) {
            for (j = 0; j < _patchLabelGrid.data.length; j++) {
              if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
                patch = _imageToPatchGrid.data[j];
                hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
                Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
                _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
                  color: "rgb(".concat(rgb.join(','), ")"),
                  lineWidth: 2
                });
              }
            }
          }

          return label;
        }

/* harmony default export */ __webpack_exports__["a"] = ({
          init: function init(inputImageWrapper, config) {
            _config = config;
            _inputImageWrapper = inputImageWrapper;
            initBuffers();
            initCanvas();
          },
          locate: function locate() {
            if (_config.halfSample) {
              Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["halfSample"])(_inputImageWrapper, _currentImageWrapper);
            }

            binarizeImage();
            var patchesFound = findPatches(); // return unless 5% or more patches are found

            if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
              return null;
            } // rasterrize area by comparing angular similarity;


            var maxLabel = rasterizeAngularSimilarity(patchesFound);

            if (maxLabel < 1) {
              return null;
            } // search for area with the most patches (biggest connected area)


            var topLabels = findBiggestConnectedAreas(maxLabel);

            if (topLabels.length === 0) {
              return null;
            }

            var boxes = findBoxes(topLabels, maxLabel);
            return boxes;
          },
          checkImageConstraints: function checkImageConstraints(inputStream, config) {
            var patchSize;
            var width = inputStream.getWidth();
            var height = inputStream.getHeight();
            var thisHalfSample = config.halfSample ? 0.5 : 1;
            var area; // calculate width and height based on area

            if (inputStream.getConfig().area) {
              area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["computeImageArea"])(width, height, inputStream.getConfig().area);
              inputStream.setTopRight({
                x: area.sx,
                y: area.sy
              });
              inputStream.setCanvasSize({
                x: width,
                y: height
              });
              width = area.sw;
              height = area.sh;
            }

            var size = {
              x: Math.floor(width * thisHalfSample),
              y: Math.floor(height * thisHalfSample)
            };
            patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(config.patchSize, size);

            if (true) {
              console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
            }

            inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
            inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

            if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
              return true;
            }

            throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
          }
        });
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12)))

      /***/
    }),
/* 29 */
/***/ (function (module, exports, __webpack_require__) {

      var listCacheClear = __webpack_require__(181),
        listCacheDelete = __webpack_require__(182),
        listCacheGet = __webpack_require__(183),
        listCacheHas = __webpack_require__(184),
        listCacheSet = __webpack_require__(185);
      /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */


      function ListCache(entries) {
        var index = -1,
          length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      } // Add methods to `ListCache`.


      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype['delete'] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;

      /***/
    }),
/* 30 */
/***/ (function (module, exports, __webpack_require__) {

      var eq = __webpack_require__(31);
      /**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */


      function assocIndexOf(array, key) {
        var length = array.length;

        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }

        return -1;
      }

      module.exports = assocIndexOf;

      /***/
    }),
/* 31 */
/***/ (function (module, exports) {

      /**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }

      module.exports = eq;

      /***/
    }),
/* 32 */
/***/ (function (module, exports, __webpack_require__) {

      var root = __webpack_require__(20);
      /** Built-in value references. */


      var Symbol = root.Symbol;
      module.exports = Symbol;

      /***/
    }),
/* 33 */
/***/ (function (module, exports, __webpack_require__) {

      var getNative = __webpack_require__(43);
      /* Built-in method references that are verified to be native. */


      var nativeCreate = getNative(Object, 'create');
      module.exports = nativeCreate;

      /***/
    }),
/* 34 */
/***/ (function (module, exports, __webpack_require__) {

      var isKeyable = __webpack_require__(206);
      /**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */


      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
      }

      module.exports = getMapData;

      /***/
    }),
/* 35 */
/***/ (function (module, exports, __webpack_require__) {

      var baseIsArguments = __webpack_require__(221),
        isObjectLike = __webpack_require__(21);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Built-in value references. */

      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      /**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */

      var isArguments = baseIsArguments(function () {
        return arguments;
      }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
      };
      module.exports = isArguments;

      /***/
    }),
/* 36 */
/***/ (function (module, exports) {

      /** Used as references for various `Number` constants. */
      var MAX_SAFE_INTEGER = 9007199254740991;
      /** Used to detect unsigned integer values. */

      var reIsUint = /^(?:0|[1-9]\d*)$/;
      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */

      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }

      module.exports = isIndex;

      /***/
    }),
/* 37 */
/***/ (function (module, exports, __webpack_require__) {

      var isArray = __webpack_require__(14),
        isKey = __webpack_require__(249),
        stringToPath = __webpack_require__(250),
        toString = __webpack_require__(253);
      /**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */


      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }

        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }

      module.exports = castPath;

      /***/
    }),
/* 38 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
/* WEBPACK VAR INJECTION */(function (process) {

        if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
          module.exports = {
            nextTick: nextTick
          };
        } else {
          module.exports = process;
        }

        function nextTick(fn, arg1, arg2, arg3) {
          if (typeof fn !== 'function') {
            throw new TypeError('"callback" argument must be a function');
          }

          var len = arguments.length;
          var args, i;

          switch (len) {
            case 0:
            case 1:
              return process.nextTick(fn);

            case 2:
              return process.nextTick(function afterTickOne() {
                fn.call(null, arg1);
              });

            case 3:
              return process.nextTick(function afterTickTwo() {
                fn.call(null, arg1, arg2);
              });

            case 4:
              return process.nextTick(function afterTickThree() {
                fn.call(null, arg1, arg2, arg3);
              });

            default:
              args = new Array(len - 1);
              i = 0;

              while (i < args.length) {
                args[i++] = arguments[i];
              }

              return process.nextTick(function afterTick() {
                fn.apply(null, args);
              });
          }
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(15)))

      /***/
    }),
/* 39 */
/***/ (function (module, exports, __webpack_require__) {

      var arrayWithHoles = __webpack_require__(107);

      var iterableToArrayLimit = __webpack_require__(108);

      var unsupportedIterableToArray = __webpack_require__(56);

      var nonIterableRest = __webpack_require__(109);

      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
      }

      module.exports = _slicedToArray;

      /***/
    }),
/* 40 */
/***/ (function (module, exports, __webpack_require__) {

      var arrayWithoutHoles = __webpack_require__(241);

      var iterableToArray = __webpack_require__(242);

      var unsupportedIterableToArray = __webpack_require__(56);

      var nonIterableSpread = __webpack_require__(243);

      function _toConsumableArray(arr) {
        return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
      }

      module.exports = _toConsumableArray;

      /***/
    }),
/* 41 */
/***/ (function (module, exports) {

      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
            args = arguments;
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
          });
        };
      }

      module.exports = _asyncToGenerator;

      /***/
    }),
/* 42 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = {
        determinant: __webpack_require__(265),
        transpose: __webpack_require__(266),
        multiply: __webpack_require__(267),
        identity: __webpack_require__(268),
        adjoint: __webpack_require__(269),
        rotate: __webpack_require__(270),
        invert: __webpack_require__(271),
        create: __webpack_require__(272),
        scale: __webpack_require__(273),
        copy: __webpack_require__(274),
        frob: __webpack_require__(275),
        ldu: __webpack_require__(276)
      };

      /***/
    }),
/* 43 */
/***/ (function (module, exports, __webpack_require__) {

      var baseIsNative = __webpack_require__(191),
        getValue = __webpack_require__(197);
      /**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */


      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
      }

      module.exports = getNative;

      /***/
    }),
/* 44 */
/***/ (function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(25),
        isObject = __webpack_require__(13);
      /** `Object#toString` result references. */


      var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';
      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */

      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        } // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.


        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }

      module.exports = isFunction;

      /***/
    }),
/* 45 */
/***/ (function (module, exports, __webpack_require__) {

      var defineProperty = __webpack_require__(83);
      /**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */


      function baseAssignValue(object, key, value) {
        if (key == '__proto__' && defineProperty) {
          defineProperty(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
          });
        } else {
          object[key] = value;
        }
      }

      module.exports = baseAssignValue;

      /***/
    }),
/* 46 */
/***/ (function (module, exports) {

      module.exports = function (module) {
        if (!module.webpackPolyfill) {
          module.deprecate = function () { };

          module.paths = []; // module.parent = undefined by default

          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
            enumerable: true,
            get: function () {
              return module.l;
            }
          });
          Object.defineProperty(module, "id", {
            enumerable: true,
            get: function () {
              return module.i;
            }
          });
          module.webpackPolyfill = 1;
        }

        return module;
      };

      /***/
    }),
/* 47 */
/***/ (function (module, exports, __webpack_require__) {

      var isFunction = __webpack_require__(44),
        isLength = __webpack_require__(48);
      /**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */


      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }

      module.exports = isArrayLike;

      /***/
    }),
/* 48 */
/***/ (function (module, exports) {

      /** Used as references for various `Number` constants. */
      var MAX_SAFE_INTEGER = 9007199254740991;
      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */

      function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }

      module.exports = isLength;

      /***/
    }),
/* 49 */
/***/ (function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(25),
        isObjectLike = __webpack_require__(21);
      /** `Object#toString` result references. */


      var symbolTag = '[object Symbol]';
      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */

      function isSymbol(value) {
        return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }

      module.exports = isSymbol;

      /***/
    }),
/* 50 */
/***/ (function (module, exports, __webpack_require__) {

      var isSymbol = __webpack_require__(49);
      /** Used as references for various `Number` constants. */


      var INFINITY = 1 / 0;
      /**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */

      function toKey(value) {
        if (typeof value == 'string' || isSymbol(value)) {
          return value;
        }

        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }

      module.exports = toKey;

      /***/
    }),
/* 51 */
/***/ (function (module, exports, __webpack_require__) {

      var iota = __webpack_require__(281);

      var isBuffer = __webpack_require__(282);

      var hasTypedArrays = typeof Float64Array !== "undefined";

      function compare1st(a, b) {
        return a[0] - b[0];
      }

      function order() {
        var stride = this.stride;
        var terms = new Array(stride.length);
        var i;

        for (i = 0; i < terms.length; ++i) {
          terms[i] = [Math.abs(stride[i]), i];
        }

        terms.sort(compare1st);
        var result = new Array(terms.length);

        for (i = 0; i < result.length; ++i) {
          result[i] = terms[i][1];
        }

        return result;
      }

      function compileConstructor(dtype, dimension) {
        var className = ["View", dimension, "d", dtype].join("");

        if (dimension < 0) {
          className = "View_Nil" + dtype;
        }

        var useGetters = dtype === "generic";

        if (dimension === -1) {
          //Special case for trivial arrays
          var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
          var procedure = new Function(code);
          return procedure();
        } else if (dimension === 0) {
          //Special case for 0d arrays
          var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
          var procedure = new Function("TrivialArray", code);
          return procedure(CACHED_CONSTRUCTORS[dtype][0]);
        }

        var code = ["'use strict'"]; //Create constructor for view

        var indices = iota(dimension);
        var args = indices.map(function (i) {
          return "i" + i;
        });
        var index_str = "this.offset+" + indices.map(function (i) {
          return "this.stride[" + i + "]*i" + i;
        }).join("+");
        var shapeArg = indices.map(function (i) {
          return "b" + i;
        }).join(",");
        var strideArg = indices.map(function (i) {
          return "c" + i;
        }).join(",");
        code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension); //view.size:

        code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function (i) {
          return "this.shape[" + i + "]";
        }).join("*"), "}})"); //view.order:

        if (dimension === 1) {
          code.push("proto.order=[0]");
        } else {
          code.push("Object.defineProperty(proto,'order',{get:");

          if (dimension < 4) {
            code.push("function " + className + "_order(){");

            if (dimension === 2) {
              code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
            } else if (dimension === 3) {
              code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
            }
          } else {
            code.push("ORDER})");
          }
        } //view.set(i0, ..., v):


        code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");

        if (useGetters) {
          code.push("return this.data.set(" + index_str + ",v)}");
        } else {
          code.push("return this.data[" + index_str + "]=v}");
        } //view.get(i0, ...):


        code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");

        if (useGetters) {
          code.push("return this.data.get(" + index_str + ")}");
        } else {
          code.push("return this.data[" + index_str + "]}");
        } //view.index:


        code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}"); //view.hi():

        code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function (i) {
          return ["(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0"].join("");
        }).join(",") + "," + indices.map(function (i) {
          return "this.stride[" + i + "]";
        }).join(",") + ",this.offset)}"); //view.lo():

        var a_vars = indices.map(function (i) {
          return "a" + i + "=this.shape[" + i + "]";
        });
        var c_vars = indices.map(function (i) {
          return "c" + i + "=this.stride[" + i + "]";
        });
        code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));

        for (var i = 0; i < dimension; ++i) {
          code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
        }

        code.push("return new " + className + "(this.data," + indices.map(function (i) {
          return "a" + i;
        }).join(",") + "," + indices.map(function (i) {
          return "c" + i;
        }).join(",") + ",b)}"); //view.step():

        code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function (i) {
          return "a" + i + "=this.shape[" + i + "]";
        }).join(",") + "," + indices.map(function (i) {
          return "b" + i + "=this.stride[" + i + "]";
        }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");

        for (var i = 0; i < dimension; ++i) {
          code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
        }

        code.push("return new " + className + "(this.data," + indices.map(function (i) {
          return "a" + i;
        }).join(",") + "," + indices.map(function (i) {
          return "b" + i;
        }).join(",") + ",c)}"); //view.transpose():

        var tShape = new Array(dimension);
        var tStride = new Array(dimension);

        for (var i = 0; i < dimension; ++i) {
          tShape[i] = "a[i" + i + "]";
          tStride[i] = "b[i" + i + "]";
        }

        code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function (n, idx) {
          return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
        }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"); //view.pick():

        code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");

        for (var i = 0; i < dimension; ++i) {
          code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
        }

        code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"); //Add return statement

        code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function (i) {
          return "shape[" + i + "]";
        }).join(",") + "," + indices.map(function (i) {
          return "stride[" + i + "]";
        }).join(",") + ",offset)}"); //Compile procedure

        var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
        return procedure(CACHED_CONSTRUCTORS[dtype], order);
      }

      function arrayDType(data) {
        if (isBuffer(data)) {
          return "buffer";
        }

        if (hasTypedArrays) {
          switch (Object.prototype.toString.call(data)) {
            case "[object Float64Array]":
              return "float64";

            case "[object Float32Array]":
              return "float32";

            case "[object Int8Array]":
              return "int8";

            case "[object Int16Array]":
              return "int16";

            case "[object Int32Array]":
              return "int32";

            case "[object Uint8Array]":
              return "uint8";

            case "[object Uint16Array]":
              return "uint16";

            case "[object Uint32Array]":
              return "uint32";

            case "[object Uint8ClampedArray]":
              return "uint8_clamped";

            case "[object BigInt64Array]":
              return "bigint64";

            case "[object BigUint64Array]":
              return "biguint64";
          }
        }

        if (Array.isArray(data)) {
          return "array";
        }

        return "generic";
      }

      var CACHED_CONSTRUCTORS = {
        "float32": [],
        "float64": [],
        "int8": [],
        "int16": [],
        "int32": [],
        "uint8": [],
        "uint16": [],
        "uint32": [],
        "array": [],
        "uint8_clamped": [],
        "bigint64": [],
        "biguint64": [],
        "buffer": [],
        "generic": []
      };

      (function () {
        for (var id in CACHED_CONSTRUCTORS) {
          CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
        }
      });

      function wrappedNDArrayCtor(data, shape, stride, offset) {
        if (data === undefined) {
          var ctor = CACHED_CONSTRUCTORS.array[0];
          return ctor([]);
        } else if (typeof data === "number") {
          data = [data];
        }

        if (shape === undefined) {
          shape = [data.length];
        }

        var d = shape.length;

        if (stride === undefined) {
          stride = new Array(d);

          for (var i = d - 1, sz = 1; i >= 0; --i) {
            stride[i] = sz;
            sz *= shape[i];
          }
        }

        if (offset === undefined) {
          offset = 0;

          for (var i = 0; i < d; ++i) {
            if (stride[i] < 0) {
              offset -= (shape[i] - 1) * stride[i];
            }
          }
        }

        var dtype = arrayDType(data);
        var ctor_list = CACHED_CONSTRUCTORS[dtype];

        while (ctor_list.length <= d + 1) {
          ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
        }

        var ctor = ctor_list[d + 1];
        return ctor(data, shape, stride, offset);
      }

      module.exports = wrappedNDArrayCtor;

      /***/
    }),
/* 52 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.


      var R = typeof Reflect === 'object' ? Reflect : null;
      var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;

      if (R && typeof R.ownKeys === 'function') {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target);
        };
      }

      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }

      var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
        return value !== value;
      };

      function EventEmitter() {
        EventEmitter.init.call(this);
      }

      module.exports = EventEmitter;
      module.exports.once = once; // Backwards-compat with node 0.10.x

      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = undefined;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
      // added to it. This is a useful default which helps finding memory leaks.

      var defaultMaxListeners = 10;

      function checkListener(listener) {
        if (typeof listener !== 'function') {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }

      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
        enumerable: true,
        get: function () {
          return defaultMaxListeners;
        },
        set: function (arg) {
          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
          }

          defaultMaxListeners = arg;
        }
      });

      EventEmitter.init = function () {
        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        }

        this._maxListeners = this._maxListeners || undefined;
      }; // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.


      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
        }

        this._maxListeners = n;
        return this;
      };

      function _getMaxListeners(that) {
        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }

      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };

      EventEmitter.prototype.emit = function emit(type) {
        var args = [];

        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

        var doError = type === 'error';
        var events = this._events;
        if (events !== undefined) doError = doError && events.error === undefined; else if (!doError) return false; // If there is no 'error' event listener then throw.

        if (doError) {
          var er;
          if (args.length > 0) er = args[0];

          if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
          } // At least give some kind of context to the user


          var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
          err.context = er;
          throw err; // Unhandled 'error' event
        }

        var handler = events[type];
        if (handler === undefined) return false;

        if (typeof handler === 'function') {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);

          for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
        }

        return true;
      };

      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;

        if (events === undefined) {
          events = target._events = Object.create(null);
          target._eventsCount = 0;
        } else {
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object

            events = target._events;
          }

          existing = events[type];
        }

        if (existing === undefined) {
          // Optimize the case of one listener. Don't need the extra array object.
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          } // Check for listener leak


          m = _getMaxListeners(target);

          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true; // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax

            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }

        return target;
      }

      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };

      EventEmitter.prototype.on = EventEmitter.prototype.addListener;

      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0) return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }

      function _onceWrap(target, type, listener) {
        var state = {
          fired: false,
          wrapFn: undefined,
          target: target,
          type: type,
          listener: listener
        };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }

      EventEmitter.prototype.once = function once(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };

      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      }; // Emits a 'removeListener' event if and only if the listener was removed.


      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === undefined) return this;
        list = events[type];
        if (list === undefined) return this;

        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0) this._events = Object.create(null); else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0) return this;
          if (position === 0) list.shift(); else {
            spliceOne(list, position);
          }
          if (list.length === 1) events[type] = list[0];
          if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };

      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === undefined) return this; // not listening for removeListener, no need to emit

        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null); else delete events[type];
          }

          return this;
        } // emit removeListener for all listeners on all events


        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;

          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }

          this.removeAllListeners('removeListener');
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }

        return this;
      };

      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === undefined) return [];
        var evlistener = events[type];
        if (evlistener === undefined) return [];
        if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }

      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };

      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };

      EventEmitter.listenerCount = function (emitter, type) {
        if (typeof emitter.listenerCount === 'function') {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };

      EventEmitter.prototype.listenerCount = listenerCount;

      function listenerCount(type) {
        var events = this._events;

        if (events !== undefined) {
          var evlistener = events[type];

          if (typeof evlistener === 'function') {
            return 1;
          } else if (evlistener !== undefined) {
            return evlistener.length;
          }
        }

        return 0;
      }

      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };

      function arrayClone(arr, n) {
        var copy = new Array(n);

        for (var i = 0; i < n; ++i) copy[i] = arr[i];

        return copy;
      }

      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++) list[index] = list[index + 1];

        list.pop();
      }

      function unwrapListeners(arr) {
        var ret = new Array(arr.length);

        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }

        return ret;
      }

      function once(emitter, name) {
        return new Promise(function (resolve, reject) {
          function eventListener() {
            if (errorListener !== undefined) {
              emitter.removeListener('error', errorListener);
            }

            resolve([].slice.call(arguments));
          }

          ;
          var errorListener; // Adding an error listener is not optional because
          // if an error is thrown on an event emitter we cannot
          // guarantee that the actual event we are waiting will
          // be fired. The result could be a silent way to create
          // memory or file descriptor leaks, which is something
          // we should avoid.

          if (name !== 'error') {
            errorListener = function errorListener(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };

            emitter.once('error', errorListener);
          }

          emitter.once(name, eventListener);
        });
      }

      /***/
    }),
/* 53 */
/***/ (function (module, exports, __webpack_require__) {

      exports = module.exports = __webpack_require__(94);
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = __webpack_require__(55);
      exports.Duplex = __webpack_require__(16);
      exports.Transform = __webpack_require__(98);
      exports.PassThrough = __webpack_require__(300);

      /***/
    }),
/* 54 */
/***/ (function (module, exports, __webpack_require__) {

      /* eslint-disable node/no-deprecated-api */
      var buffer = __webpack_require__(26);

      var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }

      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        // Copy properties from require('buffer')
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }

      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      } // Copy static methods from Buffer


      copyProps(Buffer, SafeBuffer);

      SafeBuffer.from = function (arg, encodingOrOffset, length) {
        if (typeof arg === 'number') {
          throw new TypeError('Argument must not be a number');
        }

        return Buffer(arg, encodingOrOffset, length);
      };

      SafeBuffer.alloc = function (size, fill, encoding) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        var buf = Buffer(size);

        if (fill !== undefined) {
          if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }

        return buf;
      };

      SafeBuffer.allocUnsafe = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        return Buffer(size);
      };

      SafeBuffer.allocUnsafeSlow = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        return buffer.SlowBuffer(size);
      };

      /***/
    }),
/* 55 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
/* WEBPACK VAR INJECTION */(function (process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // A bit simpler than readable streams.
        // Implement an async ._write(chunk, encoding, cb), and it'll handle all
        // the drain event emission and buffering.

        /*<replacement>*/

        var pna = __webpack_require__(38);
        /*</replacement>*/


        module.exports = Writable;
        /* <replacement> */

        function WriteReq(chunk, encoding, cb) {
          this.chunk = chunk;
          this.encoding = encoding;
          this.callback = cb;
          this.next = null;
        } // It seems a linked list but it is not
        // there will be only 2 of these for each stream


        function CorkedRequest(state) {
          var _this = this;

          this.next = null;
          this.entry = null;

          this.finish = function () {
            onCorkedFinish(_this, state);
          };
        }
        /* </replacement> */

        /*<replacement>*/


        var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
        /*</replacement>*/

        /*<replacement>*/

        var Duplex;
        /*</replacement>*/

        Writable.WritableState = WritableState;
        /*<replacement>*/

        var util = Object.create(__webpack_require__(27));
        util.inherits = __webpack_require__(22);
        /*</replacement>*/

        /*<replacement>*/

        var internalUtil = {
          deprecate: __webpack_require__(298)
        };
        /*</replacement>*/

        /*<replacement>*/

        var Stream = __webpack_require__(95);
        /*</replacement>*/

        /*<replacement>*/


        var Buffer = __webpack_require__(54).Buffer;

        var OurUint8Array = global.Uint8Array || function () { };

        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }

        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        /*</replacement>*/


        var destroyImpl = __webpack_require__(96);

        util.inherits(Writable, Stream);

        function nop() { }

        function WritableState(options, stream) {
          Duplex = Duplex || __webpack_require__(16);
          options = options || {}; // Duplex streams are both readable and writable, but share
          // the same options object.
          // However, some cases require setting options to different
          // values for the readable and the writable sides of the duplex stream.
          // These options can be provided separately as readableXXX and writableXXX.

          var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
          // contains buffers or objects.

          this.objectMode = !!options.objectMode;
          if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
          // Note: 0 is a valid value, means that we always return false if
          // the entire buffer is not flushed immediately on write()

          var hwm = options.highWaterMark;
          var writableHwm = options.writableHighWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm; else this.highWaterMark = defaultHwm; // cast to ints.

          this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

          this.finalCalled = false; // drain event flag.

          this.needDrain = false; // at the start of calling end()

          this.ending = false; // when end() has been called, and returned

          this.ended = false; // when 'finish' is emitted

          this.finished = false; // has it been destroyed

          this.destroyed = false; // should we decode strings into buffers before passing to _write?
          // this is here so that some node-core streams can optimize string
          // handling at a lower level.

          var noDecode = options.decodeStrings === false;
          this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
          // encoding is 'binary' so we have to make this configurable.
          // Everything else in the universe uses 'utf8', though.

          this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
          // of how much we're waiting to get pushed to some underlying
          // socket or file.

          this.length = 0; // a flag to see when we're in the middle of a write.

          this.writing = false; // when true all writes will be buffered until .uncork() call

          this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
          // or on a later tick.  We set this to true at first, because any
          // actions that shouldn't happen until "later" should generally also
          // not happen before the first write call.

          this.sync = true; // a flag to know if we're processing previously buffered items, which
          // may call the _write() callback in the same tick, so that we don't
          // end up in an overlapped onwrite situation.

          this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

          this.onwrite = function (er) {
            onwrite(stream, er);
          }; // the callback that the user supplies to write(chunk,encoding,cb)


          this.writecb = null; // the amount that is being written when _write is called.

          this.writelen = 0;
          this.bufferedRequest = null;
          this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
          // this must be 0 before 'finish' can be emitted

          this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
          // This is relevant for synchronous Transform streams

          this.prefinished = false; // True if the error was already emitted and should not be thrown again

          this.errorEmitted = false; // count buffered requests

          this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
          // one allocated and free to use, and we maintain at most two

          this.corkedRequestsFree = new CorkedRequest(this);
        }

        WritableState.prototype.getBuffer = function getBuffer() {
          var current = this.bufferedRequest;
          var out = [];

          while (current) {
            out.push(current);
            current = current.next;
          }

          return out;
        };

        (function () {
          try {
            Object.defineProperty(WritableState.prototype, 'buffer', {
              get: internalUtil.deprecate(function () {
                return this.getBuffer();
              }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
            });
          } catch (_) { }
        })(); // Test _writableState for inheritance to account for Duplex streams,
        // whose prototype chain only points to Readable.


        var realHasInstance;

        if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
          realHasInstance = Function.prototype[Symbol.hasInstance];
          Object.defineProperty(Writable, Symbol.hasInstance, {
            value: function (object) {
              if (realHasInstance.call(this, object)) return true;
              if (this !== Writable) return false;
              return object && object._writableState instanceof WritableState;
            }
          });
        } else {
          realHasInstance = function (object) {
            return object instanceof this;
          };
        }

        function Writable(options) {
          Duplex = Duplex || __webpack_require__(16); // Writable ctor is applied to Duplexes, too.
          // `realHasInstance` is necessary because using plain `instanceof`
          // would return false, as no `_writableState` property is attached.
          // Trying to use the custom `instanceof` for Writable here will also break the
          // Node.js LazyTransform implementation, which has a non-trivial getter for
          // `_writableState` that would lead to infinite recursion.

          if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
            return new Writable(options);
          }

          this._writableState = new WritableState(options, this); // legacy.

          this.writable = true;

          if (options) {
            if (typeof options.write === 'function') this._write = options.write;
            if (typeof options.writev === 'function') this._writev = options.writev;
            if (typeof options.destroy === 'function') this._destroy = options.destroy;
            if (typeof options.final === 'function') this._final = options.final;
          }

          Stream.call(this);
        } // Otherwise people can pipe Writable streams, which is just wrong.


        Writable.prototype.pipe = function () {
          this.emit('error', new Error('Cannot pipe, not readable'));
        };

        function writeAfterEnd(stream, cb) {
          var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

          stream.emit('error', er);
          pna.nextTick(cb, er);
        } // Checks that a user-supplied chunk is valid, especially for the particular
        // mode the stream is in. Currently this means that `null` is never accepted
        // and undefined/non-string values are only allowed in object mode.


        function validChunk(stream, state, chunk, cb) {
          var valid = true;
          var er = false;

          if (chunk === null) {
            er = new TypeError('May not write null values to stream');
          } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
            er = new TypeError('Invalid non-string/buffer chunk');
          }

          if (er) {
            stream.emit('error', er);
            pna.nextTick(cb, er);
            valid = false;
          }

          return valid;
        }

        Writable.prototype.write = function (chunk, encoding, cb) {
          var state = this._writableState;
          var ret = false;

          var isBuf = !state.objectMode && _isUint8Array(chunk);

          if (isBuf && !Buffer.isBuffer(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
          }

          if (typeof encoding === 'function') {
            cb = encoding;
            encoding = null;
          }

          if (isBuf) encoding = 'buffer'; else if (!encoding) encoding = state.defaultEncoding;
          if (typeof cb !== 'function') cb = nop;
          if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
            state.pendingcb++;
            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
          }
          return ret;
        };

        Writable.prototype.cork = function () {
          var state = this._writableState;
          state.corked++;
        };

        Writable.prototype.uncork = function () {
          var state = this._writableState;

          if (state.corked) {
            state.corked--;
            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
          }
        };

        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
          // node::ParseEncoding() requires lower case.
          if (typeof encoding === 'string') encoding = encoding.toLowerCase();
          if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
          this._writableState.defaultEncoding = encoding;
          return this;
        };

        function decodeChunk(state, chunk, encoding) {
          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
            chunk = Buffer.from(chunk, encoding);
          }

          return chunk;
        }

        Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function () {
            return this._writableState.highWaterMark;
          }
        }); // if we're already writing something, then just put this
        // in the queue, and wait our turn.  Otherwise, call _write
        // If we return false, then we need a drain event, so set that flag.

        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
          if (!isBuf) {
            var newChunk = decodeChunk(state, chunk, encoding);

            if (chunk !== newChunk) {
              isBuf = true;
              encoding = 'buffer';
              chunk = newChunk;
            }
          }

          var len = state.objectMode ? 1 : chunk.length;
          state.length += len;
          var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

          if (!ret) state.needDrain = true;

          if (state.writing || state.corked) {
            var last = state.lastBufferedRequest;
            state.lastBufferedRequest = {
              chunk: chunk,
              encoding: encoding,
              isBuf: isBuf,
              callback: cb,
              next: null
            };

            if (last) {
              last.next = state.lastBufferedRequest;
            } else {
              state.bufferedRequest = state.lastBufferedRequest;
            }

            state.bufferedRequestCount += 1;
          } else {
            doWrite(stream, state, false, len, chunk, encoding, cb);
          }

          return ret;
        }

        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
          state.writelen = len;
          state.writecb = cb;
          state.writing = true;
          state.sync = true;
          if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }

        function onwriteError(stream, state, sync, er, cb) {
          --state.pendingcb;

          if (sync) {
            // defer the callback if we are being called synchronously
            // to avoid piling up things on the stack
            pna.nextTick(cb, er); // this can emit finish, and it will always happen
            // after error

            pna.nextTick(finishMaybe, stream, state);
            stream._writableState.errorEmitted = true;
            stream.emit('error', er);
          } else {
            // the caller expect this to happen before if
            // it is async
            cb(er);
            stream._writableState.errorEmitted = true;
            stream.emit('error', er); // this can emit finish, but finish must
            // always follow error

            finishMaybe(stream, state);
          }
        }

        function onwriteStateUpdate(state) {
          state.writing = false;
          state.writecb = null;
          state.length -= state.writelen;
          state.writelen = 0;
        }

        function onwrite(stream, er) {
          var state = stream._writableState;
          var sync = state.sync;
          var cb = state.writecb;
          onwriteStateUpdate(state);
          if (er) onwriteError(stream, state, sync, er, cb); else {
            // Check if we're actually ready to finish, but don't emit yet
            var finished = needFinish(state);

            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
              clearBuffer(stream, state);
            }

            if (sync) {
              /*<replacement>*/
              asyncWrite(afterWrite, stream, state, finished, cb);
              /*</replacement>*/
            } else {
              afterWrite(stream, state, finished, cb);
            }
          }
        }

        function afterWrite(stream, state, finished, cb) {
          if (!finished) onwriteDrain(stream, state);
          state.pendingcb--;
          cb();
          finishMaybe(stream, state);
        } // Must force callback to be called on nextTick, so that we don't
        // emit 'drain' before the write() consumer gets the 'false' return
        // value, and has a chance to attach a 'drain' listener.


        function onwriteDrain(stream, state) {
          if (state.length === 0 && state.needDrain) {
            state.needDrain = false;
            stream.emit('drain');
          }
        } // if there's something in the buffer waiting, then process it


        function clearBuffer(stream, state) {
          state.bufferProcessing = true;
          var entry = state.bufferedRequest;

          if (stream._writev && entry && entry.next) {
            // Fast case, write everything using _writev()
            var l = state.bufferedRequestCount;
            var buffer = new Array(l);
            var holder = state.corkedRequestsFree;
            holder.entry = entry;
            var count = 0;
            var allBuffers = true;

            while (entry) {
              buffer[count] = entry;
              if (!entry.isBuf) allBuffers = false;
              entry = entry.next;
              count += 1;
            }

            buffer.allBuffers = allBuffers;
            doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
            // as the hot path ends with doWrite

            state.pendingcb++;
            state.lastBufferedRequest = null;

            if (holder.next) {
              state.corkedRequestsFree = holder.next;
              holder.next = null;
            } else {
              state.corkedRequestsFree = new CorkedRequest(state);
            }

            state.bufferedRequestCount = 0;
          } else {
            // Slow case, write chunks one-by-one
            while (entry) {
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, false, len, chunk, encoding, cb);
              entry = entry.next;
              state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
              // it means that we need to wait until it does.
              // also, that means that the chunk and cb are currently
              // being processed, so move the buffer counter past them.

              if (state.writing) {
                break;
              }
            }

            if (entry === null) state.lastBufferedRequest = null;
          }

          state.bufferedRequest = entry;
          state.bufferProcessing = false;
        }

        Writable.prototype._write = function (chunk, encoding, cb) {
          cb(new Error('_write() is not implemented'));
        };

        Writable.prototype._writev = null;

        Writable.prototype.end = function (chunk, encoding, cb) {
          var state = this._writableState;

          if (typeof chunk === 'function') {
            cb = chunk;
            chunk = null;
            encoding = null;
          } else if (typeof encoding === 'function') {
            cb = encoding;
            encoding = null;
          }

          if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

          if (state.corked) {
            state.corked = 1;
            this.uncork();
          } // ignore unnecessary end() calls.


          if (!state.ending && !state.finished) endWritable(this, state, cb);
        };

        function needFinish(state) {
          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
        }

        function callFinal(stream, state) {
          stream._final(function (err) {
            state.pendingcb--;

            if (err) {
              stream.emit('error', err);
            }

            state.prefinished = true;
            stream.emit('prefinish');
            finishMaybe(stream, state);
          });
        }

        function prefinish(stream, state) {
          if (!state.prefinished && !state.finalCalled) {
            if (typeof stream._final === 'function') {
              state.pendingcb++;
              state.finalCalled = true;
              pna.nextTick(callFinal, stream, state);
            } else {
              state.prefinished = true;
              stream.emit('prefinish');
            }
          }
        }

        function finishMaybe(stream, state) {
          var need = needFinish(state);

          if (need) {
            prefinish(stream, state);

            if (state.pendingcb === 0) {
              state.finished = true;
              stream.emit('finish');
            }
          }

          return need;
        }

        function endWritable(stream, state, cb) {
          state.ending = true;
          finishMaybe(stream, state);

          if (cb) {
            if (state.finished) pna.nextTick(cb); else stream.once('finish', cb);
          }

          state.ended = true;
          stream.writable = false;
        }

        function onCorkedFinish(corkReq, state, err) {
          var entry = corkReq.entry;
          corkReq.entry = null;

          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }

          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = corkReq;
          } else {
            state.corkedRequestsFree = corkReq;
          }
        }

        Object.defineProperty(Writable.prototype, 'destroyed', {
          get: function () {
            if (this._writableState === undefined) {
              return false;
            }

            return this._writableState.destroyed;
          },
          set: function (value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (!this._writableState) {
              return;
            } // backward compatibility, the user is explicitly
            // managing destroyed


            this._writableState.destroyed = value;
          }
        });
        Writable.prototype.destroy = destroyImpl.destroy;
        Writable.prototype._undestroy = destroyImpl.undestroy;

        Writable.prototype._destroy = function (err, cb) {
          this.end();
          cb(err);
        };
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(15), __webpack_require__(296).setImmediate, __webpack_require__(12)))

      /***/
    }),
/* 56 */
/***/ (function (module, exports, __webpack_require__) {

      var arrayLikeToArray = __webpack_require__(57);

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
      }

      module.exports = _unsupportedIterableToArray;

      /***/
    }),
/* 57 */
/***/ (function (module, exports) {

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      module.exports = _arrayLikeToArray;

      /***/
    }),
/* 58 */
/***/ (function (module, exports) {

      module.exports = 0.000001;

      /***/
    }),
/* 59 */
/***/ (function (module, exports) {

      module.exports = create;
      /**
       * Creates a new, empty vec2
       *
       * @returns {vec2} a new 2D vector
       */

      function create() {
        var out = new Float32Array(2);
        out[0] = 0;
        out[1] = 0;
        return out;
      }

      /***/
    }),
/* 60 */
/***/ (function (module, exports) {

      module.exports = subtract;
      /**
       * Subtracts vector b from vector a
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */

      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        return out;
      }

      /***/
    }),
/* 61 */
/***/ (function (module, exports) {

      module.exports = multiply;
      /**
       * Multiplies two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */

      function multiply(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        return out;
      }

      /***/
    }),
/* 62 */
/***/ (function (module, exports) {

      module.exports = divide;
      /**
       * Divides two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */

      function divide(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        return out;
      }

      /***/
    }),
/* 63 */
/***/ (function (module, exports) {

      module.exports = distance;
      /**
       * Calculates the euclidian distance between two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} distance between a and b
       */

      function distance(a, b) {
        var x = b[0] - a[0],
          y = b[1] - a[1];
        return Math.sqrt(x * x + y * y);
      }

      /***/
    }),
/* 64 */
/***/ (function (module, exports) {

      module.exports = squaredDistance;
      /**
       * Calculates the squared euclidian distance between two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} squared distance between a and b
       */

      function squaredDistance(a, b) {
        var x = b[0] - a[0],
          y = b[1] - a[1];
        return x * x + y * y;
      }

      /***/
    }),
/* 65 */
/***/ (function (module, exports) {

      module.exports = length;
      /**
       * Calculates the length of a vec2
       *
       * @param {vec2} a vector to calculate length of
       * @returns {Number} length of a
       */

      function length(a) {
        var x = a[0],
          y = a[1];
        return Math.sqrt(x * x + y * y);
      }

      /***/
    }),
/* 66 */
/***/ (function (module, exports) {

      module.exports = squaredLength;
      /**
       * Calculates the squared length of a vec2
       *
       * @param {vec2} a vector to calculate squared length of
       * @returns {Number} squared length of a
       */

      function squaredLength(a) {
        var x = a[0],
          y = a[1];
        return x * x + y * y;
      }

      /***/
    }),
/* 67 */
/***/ (function (module, exports) {

      module.exports = 0.000001;

      /***/
    }),
/* 68 */
/***/ (function (module, exports) {

      module.exports = create;
      /**
       * Creates a new, empty vec3
       *
       * @returns {vec3} a new 3D vector
       */

      function create() {
        var out = new Float32Array(3);
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        return out;
      }

      /***/
    }),
/* 69 */
/***/ (function (module, exports) {

      module.exports = fromValues;
      /**
       * Creates a new vec3 initialized with the given values
       *
       * @param {Number} x X component
       * @param {Number} y Y component
       * @param {Number} z Z component
       * @returns {vec3} a new 3D vector
       */

      function fromValues(x, y, z) {
        var out = new Float32Array(3);
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
      }

      /***/
    }),
/* 70 */
/***/ (function (module, exports) {

      module.exports = normalize;
      /**
       * Normalize a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to normalize
       * @returns {vec3} out
       */

      function normalize(out, a) {
        var x = a[0],
          y = a[1],
          z = a[2];
        var len = x * x + y * y + z * z;

        if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
          out[2] = a[2] * len;
        }

        return out;
      }

      /***/
    }),
/* 71 */
/***/ (function (module, exports) {

      module.exports = dot;
      /**
       * Calculates the dot product of two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} dot product of a and b
       */

      function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }

      /***/
    }),
/* 72 */
/***/ (function (module, exports) {

      module.exports = subtract;
      /**
       * Subtracts vector b from vector a
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */

      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        return out;
      }

      /***/
    }),
/* 73 */
/***/ (function (module, exports) {

      module.exports = multiply;
      /**
       * Multiplies two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */

      function multiply(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        out[2] = a[2] * b[2];
        return out;
      }

      /***/
    }),
/* 74 */
/***/ (function (module, exports) {

      module.exports = divide;
      /**
       * Divides two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */

      function divide(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        out[2] = a[2] / b[2];
        return out;
      }

      /***/
    }),
/* 75 */
/***/ (function (module, exports) {

      module.exports = distance;
      /**
       * Calculates the euclidian distance between two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} distance between a and b
       */

      function distance(a, b) {
        var x = b[0] - a[0],
          y = b[1] - a[1],
          z = b[2] - a[2];
        return Math.sqrt(x * x + y * y + z * z);
      }

      /***/
    }),
/* 76 */
/***/ (function (module, exports) {

      module.exports = squaredDistance;
      /**
       * Calculates the squared euclidian distance between two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} squared distance between a and b
       */

      function squaredDistance(a, b) {
        var x = b[0] - a[0],
          y = b[1] - a[1],
          z = b[2] - a[2];
        return x * x + y * y + z * z;
      }

      /***/
    }),
/* 77 */
/***/ (function (module, exports) {

      module.exports = length;
      /**
       * Calculates the length of a vec3
       *
       * @param {vec3} a vector to calculate length of
       * @returns {Number} length of a
       */

      function length(a) {
        var x = a[0],
          y = a[1],
          z = a[2];
        return Math.sqrt(x * x + y * y + z * z);
      }

      /***/
    }),
/* 78 */
/***/ (function (module, exports) {

      module.exports = squaredLength;
      /**
       * Calculates the squared length of a vec3
       *
       * @param {vec3} a vector to calculate squared length of
       * @returns {Number} squared length of a
       */

      function squaredLength(a) {
        var x = a[0],
          y = a[1],
          z = a[2];
        return x * x + y * y + z * z;
      }

      /***/
    }),
/* 79 */
/***/ (function (module, exports, __webpack_require__) {

      var getNative = __webpack_require__(43),
        root = __webpack_require__(20);
      /* Built-in method references that are verified to be native. */


      var Map = getNative(root, 'Map');
      module.exports = Map;

      /***/
    }),
/* 80 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (global) {/** Detect free variable `global` from Node.js. */
        var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
        module.exports = freeGlobal;
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12)))

      /***/
    }),
/* 81 */
/***/ (function (module, exports, __webpack_require__) {

      var mapCacheClear = __webpack_require__(198),
        mapCacheDelete = __webpack_require__(205),
        mapCacheGet = __webpack_require__(207),
        mapCacheHas = __webpack_require__(208),
        mapCacheSet = __webpack_require__(209);
      /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */


      function MapCache(entries) {
        var index = -1,
          length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      } // Add methods to `MapCache`.


      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype['delete'] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;

      /***/
    }),
/* 82 */
/***/ (function (module, exports, __webpack_require__) {

      var baseAssignValue = __webpack_require__(45),
        eq = __webpack_require__(31);
      /**
       * This function is like `assignValue` except that it doesn't assign
       * `undefined` values.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */


      function assignMergeValue(object, key, value) {
        if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }

      module.exports = assignMergeValue;

      /***/
    }),
/* 83 */
/***/ (function (module, exports, __webpack_require__) {

      var getNative = __webpack_require__(43);

      var defineProperty = function () {
        try {
          var func = getNative(Object, 'defineProperty');
          func({}, '', {});
          return func;
        } catch (e) { }
      }();

      module.exports = defineProperty;

      /***/
    }),
/* 84 */
/***/ (function (module, exports, __webpack_require__) {

      var overArg = __webpack_require__(220);
      /** Built-in value references. */


      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module.exports = getPrototype;

      /***/
    }),
/* 85 */
/***/ (function (module, exports) {

      /** Used for built-in method references. */
      var objectProto = Object.prototype;
      /**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */

      function isPrototype(value) {
        var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
        return value === proto;
      }

      module.exports = isPrototype;

      /***/
    }),
/* 86 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (module) {
        var root = __webpack_require__(20),
          stubFalse = __webpack_require__(223);
        /** Detect free variable `exports`. */


        var freeExports = true && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Built-in value references. */

        var Buffer = moduleExports ? root.Buffer : undefined;
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */

        var isBuffer = nativeIsBuffer || stubFalse;
        module.exports = isBuffer;
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(46)(module)))

      /***/
    }),
/* 87 */
/***/ (function (module, exports, __webpack_require__) {

      var baseIsTypedArray = __webpack_require__(225),
        baseUnary = __webpack_require__(226),
        nodeUtil = __webpack_require__(227);
      /* Node.js helper references. */


      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      /**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */

      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;

      /***/
    }),
/* 88 */
/***/ (function (module, exports) {

      /**
       * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function safeGet(object, key) {
        if (key === 'constructor' && typeof object[key] === 'function') {
          return;
        }

        if (key == '__proto__') {
          return;
        }

        return object[key];
      }

      module.exports = safeGet;

      /***/
    }),
/* 89 */
/***/ (function (module, exports, __webpack_require__) {

      var baseAssignValue = __webpack_require__(45),
        eq = __webpack_require__(31);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */

      function assignValue(object, key, value) {
        var objValue = object[key];

        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }

      module.exports = assignValue;

      /***/
    }),
/* 90 */
/***/ (function (module, exports, __webpack_require__) {

      var arrayLikeKeys = __webpack_require__(230),
        baseKeysIn = __webpack_require__(232),
        isArrayLike = __webpack_require__(47);
      /**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */


      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }

      module.exports = keysIn;

      /***/
    }),
/* 91 */
/***/ (function (module, exports) {

      /**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */
      function identity(value) {
        return value;
      }

      module.exports = identity;

      /***/
    }),
/* 92 */
/***/ (function (module, exports, __webpack_require__) {

      var apply = __webpack_require__(236);
      /* Built-in method references for those with the same name as other `lodash` methods. */


      var nativeMax = Math.max;
      /**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */

      function overRest(func, start, transform) {
        start = nativeMax(start === undefined ? func.length - 1 : start, 0);
        return function () {
          var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

          while (++index < length) {
            array[index] = args[start + index];
          }

          index = -1;
          var otherArgs = Array(start + 1);

          while (++index < start) {
            otherArgs[index] = args[index];
          }

          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }

      module.exports = overRest;

      /***/
    }),
/* 93 */
/***/ (function (module, exports, __webpack_require__) {

      var baseSetToString = __webpack_require__(237),
        shortOut = __webpack_require__(239);
      /**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */


      var setToString = shortOut(baseSetToString);
      module.exports = setToString;

      /***/
    }),
/* 94 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
/* WEBPACK VAR INJECTION */(function (global, process) {// Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        /*<replacement>*/

        var pna = __webpack_require__(38);
        /*</replacement>*/


        module.exports = Readable;
        /*<replacement>*/

        var isArray = __webpack_require__(292);
        /*</replacement>*/

        /*<replacement>*/


        var Duplex;
        /*</replacement>*/

        Readable.ReadableState = ReadableState;
        /*<replacement>*/

        var EE = __webpack_require__(52).EventEmitter;

        var EElistenerCount = function (emitter, type) {
          return emitter.listeners(type).length;
        };
        /*</replacement>*/

        /*<replacement>*/


        var Stream = __webpack_require__(95);
        /*</replacement>*/

        /*<replacement>*/


        var Buffer = __webpack_require__(54).Buffer;

        var OurUint8Array = global.Uint8Array || function () { };

        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }

        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        /*</replacement>*/

        /*<replacement>*/


        var util = Object.create(__webpack_require__(27));
        util.inherits = __webpack_require__(22);
        /*</replacement>*/

        /*<replacement>*/

        var debugUtil = __webpack_require__(293);

        var debug = void 0;

        if (debugUtil && debugUtil.debuglog) {
          debug = debugUtil.debuglog('stream');
        } else {
          debug = function () { };
        }
        /*</replacement>*/


        var BufferList = __webpack_require__(294);

        var destroyImpl = __webpack_require__(96);

        var StringDecoder;
        util.inherits(Readable, Stream);
        var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

        function prependListener(emitter, event, fn) {
          // Sadly this is not cacheable as some libraries bundle their own
          // event emitter implementation with them.
          if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
          // userland ones.  NEVER DO THIS. This is here only because this code needs
          // to continue to work with older versions of Node.js that do not include
          // the prependListener() method. The goal is to eventually remove this hack.

          if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [fn, emitter._events[event]];
        }

        function ReadableState(options, stream) {
          Duplex = Duplex || __webpack_require__(16);
          options = options || {}; // Duplex streams are both readable and writable, but share
          // the same options object.
          // However, some cases require setting options to different
          // values for the readable and the writable sides of the duplex stream.
          // These options can be provided separately as readableXXX and writableXXX.

          var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
          // make all the buffer merging and length checks go away

          this.objectMode = !!options.objectMode;
          if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
          // Note: 0 is a valid value, means "don't call _read preemptively ever"

          var hwm = options.highWaterMark;
          var readableHwm = options.readableHighWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm; else this.highWaterMark = defaultHwm; // cast to ints.

          this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
          // linked list can remove elements from the beginning faster than
          // array.shift()

          this.buffer = new BufferList();
          this.length = 0;
          this.pipes = null;
          this.pipesCount = 0;
          this.flowing = null;
          this.ended = false;
          this.endEmitted = false;
          this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
          // immediately, or on a later tick.  We set this to true at first, because
          // any actions that shouldn't happen until "later" should generally also
          // not happen before the first read call.

          this.sync = true; // whenever we return null, then we set a flag to say
          // that we're awaiting a 'readable' event emission.

          this.needReadable = false;
          this.emittedReadable = false;
          this.readableListening = false;
          this.resumeScheduled = false; // has it been destroyed

          this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
          // encoding is 'binary' so we have to make this configurable.
          // Everything else in the universe uses 'utf8', though.

          this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

          this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

          this.readingMore = false;
          this.decoder = null;
          this.encoding = null;

          if (options.encoding) {
            if (!StringDecoder) StringDecoder = __webpack_require__(97).StringDecoder;
            this.decoder = new StringDecoder(options.encoding);
            this.encoding = options.encoding;
          }
        }

        function Readable(options) {
          Duplex = Duplex || __webpack_require__(16);
          if (!(this instanceof Readable)) return new Readable(options);
          this._readableState = new ReadableState(options, this); // legacy

          this.readable = true;

          if (options) {
            if (typeof options.read === 'function') this._read = options.read;
            if (typeof options.destroy === 'function') this._destroy = options.destroy;
          }

          Stream.call(this);
        }

        Object.defineProperty(Readable.prototype, 'destroyed', {
          get: function () {
            if (this._readableState === undefined) {
              return false;
            }

            return this._readableState.destroyed;
          },
          set: function (value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (!this._readableState) {
              return;
            } // backward compatibility, the user is explicitly
            // managing destroyed


            this._readableState.destroyed = value;
          }
        });
        Readable.prototype.destroy = destroyImpl.destroy;
        Readable.prototype._undestroy = destroyImpl.undestroy;

        Readable.prototype._destroy = function (err, cb) {
          this.push(null);
          cb(err);
        }; // Manually shove something into the read() buffer.
        // This returns true if the highWaterMark has not been hit yet,
        // similar to how Writable.write() returns true if you should
        // write() some more.


        Readable.prototype.push = function (chunk, encoding) {
          var state = this._readableState;
          var skipChunkCheck;

          if (!state.objectMode) {
            if (typeof chunk === 'string') {
              encoding = encoding || state.defaultEncoding;

              if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = '';
              }

              skipChunkCheck = true;
            }
          } else {
            skipChunkCheck = true;
          }

          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
        }; // Unshift should *always* be something directly out of read()


        Readable.prototype.unshift = function (chunk) {
          return readableAddChunk(this, chunk, null, true, false);
        };

        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
          var state = stream._readableState;

          if (chunk === null) {
            state.reading = false;
            onEofChunk(stream, state);
          } else {
            var er;
            if (!skipChunkCheck) er = chunkInvalid(state, chunk);

            if (er) {
              stream.emit('error', er);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
              }

              if (addToFront) {
                if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event')); else addChunk(stream, state, chunk, true);
              } else if (state.ended) {
                stream.emit('error', new Error('stream.push() after EOF'));
              } else {
                state.reading = false;

                if (state.decoder && !encoding) {
                  chunk = state.decoder.write(chunk);
                  if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);
                } else {
                  addChunk(stream, state, chunk, false);
                }
              }
            } else if (!addToFront) {
              state.reading = false;
            }
          }

          return needMoreData(state);
        }

        function addChunk(stream, state, chunk, addToFront) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);
            if (state.needReadable) emitReadable(stream);
          }

          maybeReadMore(stream, state);
        }

        function chunkInvalid(state, chunk) {
          var er;

          if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
            er = new TypeError('Invalid non-string/buffer chunk');
          }

          return er;
        } // if it's past the high water mark, we can push in some more.
        // Also, if we have no data yet, we can stand some
        // more bytes.  This is to work around cases where hwm=0,
        // such as the repl.  Also, if the push() triggered a
        // readable event, and the user called read(largeNumber) such that
        // needReadable was set, then we ought to push more, so that another
        // 'readable' event will be triggered.


        function needMoreData(state) {
          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
        }

        Readable.prototype.isPaused = function () {
          return this._readableState.flowing === false;
        }; // backwards compatibility.


        Readable.prototype.setEncoding = function (enc) {
          if (!StringDecoder) StringDecoder = __webpack_require__(97).StringDecoder;
          this._readableState.decoder = new StringDecoder(enc);
          this._readableState.encoding = enc;
          return this;
        }; // Don't raise the hwm > 8MB


        var MAX_HWM = 0x800000;

        function computeNewHighWaterMark(n) {
          if (n >= MAX_HWM) {
            n = MAX_HWM;
          } else {
            // Get the next highest power of 2 to prevent increasing hwm excessively in
            // tiny amounts
            n--;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            n++;
          }

          return n;
        } // This function is designed to be inlinable, so please take care when making
        // changes to the function body.


        function howMuchToRead(n, state) {
          if (n <= 0 || state.length === 0 && state.ended) return 0;
          if (state.objectMode) return 1;

          if (n !== n) {
            // Only flow one buffer at a time
            if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;
          } // If we're asking for more than the current hwm, then raise the hwm.


          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
          if (n <= state.length) return n; // Don't have enough

          if (!state.ended) {
            state.needReadable = true;
            return 0;
          }

          return state.length;
        } // you can override either this method, or the async _read(n) below.


        Readable.prototype.read = function (n) {
          debug('read', n);
          n = parseInt(n, 10);
          var state = this._readableState;
          var nOrig = n;
          if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
          // already have a bunch of data in the buffer, then just trigger
          // the 'readable' event and move on.

          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
            debug('read: emitReadable', state.length, state.ended);
            if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this);
            return null;
          }

          n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

          if (n === 0 && state.ended) {
            if (state.length === 0) endReadable(this);
            return null;
          } // All the actual chunk generation logic needs to be
          // *below* the call to _read.  The reason is that in certain
          // synthetic stream cases, such as passthrough streams, _read
          // may be a completely synchronous operation which may change
          // the state of the read buffer, providing enough data when
          // before there was *not* enough.
          //
          // So, the steps are:
          // 1. Figure out what the state of things will be after we do
          // a read from the buffer.
          //
          // 2. If that resulting state will trigger a _read, then call _read.
          // Note that this may be asynchronous, or synchronous.  Yes, it is
          // deeply ugly to write APIs this way, but that still doesn't mean
          // that the Readable class should behave improperly, as streams are
          // designed to be sync/async agnostic.
          // Take note if the _read call is sync or async (ie, if the read call
          // has returned yet), so that we know whether or not it's safe to emit
          // 'readable' etc.
          //
          // 3. Actually pull the requested chunks out of the buffer and return.
          // if we need a readable event, then we need to do some reading.


          var doRead = state.needReadable;
          debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

          if (state.length === 0 || state.length - n < state.highWaterMark) {
            doRead = true;
            debug('length less than watermark', doRead);
          } // however, if we've ended, then there's no point, and if we're already
          // reading, then it's unnecessary.


          if (state.ended || state.reading) {
            doRead = false;
            debug('reading or ended', doRead);
          } else if (doRead) {
            debug('do read');
            state.reading = true;
            state.sync = true; // if the length is currently zero, then we *need* a readable event.

            if (state.length === 0) state.needReadable = true; // call internal read method

            this._read(state.highWaterMark);

            state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
            // and we need to re-evaluate how much data we can return to the user.

            if (!state.reading) n = howMuchToRead(nOrig, state);
          }

          var ret;
          if (n > 0) ret = fromList(n, state); else ret = null;

          if (ret === null) {
            state.needReadable = true;
            n = 0;
          } else {
            state.length -= n;
          }

          if (state.length === 0) {
            // If we have nothing in the buffer, then we want to know
            // as soon as we *do* get something into the buffer.
            if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

            if (nOrig !== n && state.ended) endReadable(this);
          }

          if (ret !== null) this.emit('data', ret);
          return ret;
        };

        function onEofChunk(stream, state) {
          if (state.ended) return;

          if (state.decoder) {
            var chunk = state.decoder.end();

            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length;
            }
          }

          state.ended = true; // emit 'readable' now to make sure it gets picked up.

          emitReadable(stream);
        } // Don't emit readable right away in sync mode, because this can trigger
        // another read() call => stack overflow.  This way, it might trigger
        // a nextTick recursion warning, but that's not so bad.


        function emitReadable(stream) {
          var state = stream._readableState;
          state.needReadable = false;

          if (!state.emittedReadable) {
            debug('emitReadable', state.flowing);
            state.emittedReadable = true;
            if (state.sync) pna.nextTick(emitReadable_, stream); else emitReadable_(stream);
          }
        }

        function emitReadable_(stream) {
          debug('emit readable');
          stream.emit('readable');
          flow(stream);
        } // at this point, the user has presumably seen the 'readable' event,
        // and called read() to consume some data.  that may have triggered
        // in turn another _read(n) call, in which case reading = true if
        // it's in progress.
        // However, if we're not ended, or reading, and the length < hwm,
        // then go ahead and try to read some more preemptively.


        function maybeReadMore(stream, state) {
          if (!state.readingMore) {
            state.readingMore = true;
            pna.nextTick(maybeReadMore_, stream, state);
          }
        }

        function maybeReadMore_(stream, state) {
          var len = state.length;

          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
            debug('maybeReadMore read 0');
            stream.read(0);
            if (len === state.length) // didn't get any data, stop spinning.
              break; else len = state.length;
          }

          state.readingMore = false;
        } // abstract method.  to be overridden in specific implementation classes.
        // call cb(er, data) where data is <= n in length.
        // for virtual (non-string, non-buffer) streams, "length" is somewhat
        // arbitrary, and perhaps not very meaningful.


        Readable.prototype._read = function (n) {
          this.emit('error', new Error('_read() is not implemented'));
        };

        Readable.prototype.pipe = function (dest, pipeOpts) {
          var src = this;
          var state = this._readableState;

          switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;

            case 1:
              state.pipes = [state.pipes, dest];
              break;

            default:
              state.pipes.push(dest);
              break;
          }

          state.pipesCount += 1;
          debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
          var endFn = doEnd ? onend : unpipe;
          if (state.endEmitted) pna.nextTick(endFn); else src.once('end', endFn);
          dest.on('unpipe', onunpipe);

          function onunpipe(readable, unpipeInfo) {
            debug('onunpipe');

            if (readable === src) {
              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
              }
            }
          }

          function onend() {
            debug('onend');
            dest.end();
          } // when the dest drains, it reduces the awaitDrain counter
          // on the source.  This would be more elegant with a .once()
          // handler in flow(), but adding and removing repeatedly is
          // too slow.


          var ondrain = pipeOnDrain(src);
          dest.on('drain', ondrain);
          var cleanedUp = false;

          function cleanup() {
            debug('cleanup'); // cleanup event handlers once the pipe is broken

            dest.removeListener('close', onclose);
            dest.removeListener('finish', onfinish);
            dest.removeListener('drain', ondrain);
            dest.removeListener('error', onerror);
            dest.removeListener('unpipe', onunpipe);
            src.removeListener('end', onend);
            src.removeListener('end', unpipe);
            src.removeListener('data', ondata);
            cleanedUp = true; // if the reader is waiting for a drain event from this
            // specific writer, then it would cause it to never start
            // flowing again.
            // So, if this is awaiting a drain, then we just call it now.
            // If we don't know, then assume that we are waiting for one.

            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
          } // If the user pushes more data while we're writing to dest then we'll end up
          // in ondata again. However, we only want to increase awaitDrain once because
          // dest will only emit one 'drain' event for the multiple writes.
          // => Introduce a guard on increasing awaitDrain.


          var increasedAwaitDrain = false;
          src.on('data', ondata);

          function ondata(chunk) {
            debug('ondata');
            increasedAwaitDrain = false;
            var ret = dest.write(chunk);

            if (false === ret && !increasedAwaitDrain) {
              // If the user unpiped during `dest.write()`, it is possible
              // to get stuck in a permanently paused state if that write
              // also returned false.
              // => Check whether `dest` is still a piping destination.
              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug('false write response, pause', src._readableState.awaitDrain);
                src._readableState.awaitDrain++;
                increasedAwaitDrain = true;
              }

              src.pause();
            }
          } // if the dest has an error, then stop piping into it.
          // however, don't suppress the throwing behavior for this.


          function onerror(er) {
            debug('onerror', er);
            unpipe();
            dest.removeListener('error', onerror);
            if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
          } // Make sure our error handler is attached before userland ones.


          prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

          function onclose() {
            dest.removeListener('finish', onfinish);
            unpipe();
          }

          dest.once('close', onclose);

          function onfinish() {
            debug('onfinish');
            dest.removeListener('close', onclose);
            unpipe();
          }

          dest.once('finish', onfinish);

          function unpipe() {
            debug('unpipe');
            src.unpipe(dest);
          } // tell the dest that it's being piped to


          dest.emit('pipe', src); // start the flow if it hasn't been started already.

          if (!state.flowing) {
            debug('pipe resume');
            src.resume();
          }

          return dest;
        };

        function pipeOnDrain(src) {
          return function () {
            var state = src._readableState;
            debug('pipeOnDrain', state.awaitDrain);
            if (state.awaitDrain) state.awaitDrain--;

            if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
              state.flowing = true;
              flow(src);
            }
          };
        }

        Readable.prototype.unpipe = function (dest) {
          var state = this._readableState;
          var unpipeInfo = {
            hasUnpiped: false
          }; // if we're not piping anywhere, then do nothing.

          if (state.pipesCount === 0) return this; // just one destination.  most common case.

          if (state.pipesCount === 1) {
            // passed in one, but it's not the right one.
            if (dest && dest !== state.pipes) return this;
            if (!dest) dest = state.pipes; // got a match.

            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            if (dest) dest.emit('unpipe', this, unpipeInfo);
            return this;
          } // slow case. multiple pipe destinations.


          if (!dest) {
            // remove all.
            var dests = state.pipes;
            var len = state.pipesCount;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;

            for (var i = 0; i < len; i++) {
              dests[i].emit('unpipe', this, unpipeInfo);
            }

            return this;
          } // try to find the right one.


          var index = indexOf(state.pipes, dest);
          if (index === -1) return this;
          state.pipes.splice(index, 1);
          state.pipesCount -= 1;
          if (state.pipesCount === 1) state.pipes = state.pipes[0];
          dest.emit('unpipe', this, unpipeInfo);
          return this;
        }; // set up data events if they are asked for
        // Ensure readable listeners eventually get something


        Readable.prototype.on = function (ev, fn) {
          var res = Stream.prototype.on.call(this, ev, fn);

          if (ev === 'data') {
            // Start flowing on next tick if stream isn't explicitly paused
            if (this._readableState.flowing !== false) this.resume();
          } else if (ev === 'readable') {
            var state = this._readableState;

            if (!state.endEmitted && !state.readableListening) {
              state.readableListening = state.needReadable = true;
              state.emittedReadable = false;

              if (!state.reading) {
                pna.nextTick(nReadingNextTick, this);
              } else if (state.length) {
                emitReadable(this);
              }
            }
          }

          return res;
        };

        Readable.prototype.addListener = Readable.prototype.on;

        function nReadingNextTick(self) {
          debug('readable nexttick read 0');
          self.read(0);
        } // pause() and resume() are remnants of the legacy readable stream API
        // If the user uses them, then switch into old mode.


        Readable.prototype.resume = function () {
          var state = this._readableState;

          if (!state.flowing) {
            debug('resume');
            state.flowing = true;
            resume(this, state);
          }

          return this;
        };

        function resume(stream, state) {
          if (!state.resumeScheduled) {
            state.resumeScheduled = true;
            pna.nextTick(resume_, stream, state);
          }
        }

        function resume_(stream, state) {
          if (!state.reading) {
            debug('resume read 0');
            stream.read(0);
          }

          state.resumeScheduled = false;
          state.awaitDrain = 0;
          stream.emit('resume');
          flow(stream);
          if (state.flowing && !state.reading) stream.read(0);
        }

        Readable.prototype.pause = function () {
          debug('call pause flowing=%j', this._readableState.flowing);

          if (false !== this._readableState.flowing) {
            debug('pause');
            this._readableState.flowing = false;
            this.emit('pause');
          }

          return this;
        };

        function flow(stream) {
          var state = stream._readableState;
          debug('flow', state.flowing);

          while (state.flowing && stream.read() !== null) { }
        } // wrap an old-style stream as the async data source.
        // This is *not* part of the readable stream interface.
        // It is an ugly unfortunate mess of history.


        Readable.prototype.wrap = function (stream) {
          var _this = this;

          var state = this._readableState;
          var paused = false;
          stream.on('end', function () {
            debug('wrapped end');

            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) _this.push(chunk);
            }

            _this.push(null);
          });
          stream.on('data', function (chunk) {
            debug('wrapped data');
            if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

            if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return;

            var ret = _this.push(chunk);

            if (!ret) {
              paused = true;
              stream.pause();
            }
          }); // proxy all the other methods.
          // important when wrapping filters and duplexes.

          for (var i in stream) {
            if (this[i] === undefined && typeof stream[i] === 'function') {
              this[i] = function (method) {
                return function () {
                  return stream[method].apply(stream, arguments);
                };
              }(i);
            }
          } // proxy certain important events.


          for (var n = 0; n < kProxyEvents.length; n++) {
            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
          } // when we try to consume some more bytes, simply unpause the
          // underlying stream.


          this._read = function (n) {
            debug('wrapped _read', n);

            if (paused) {
              paused = false;
              stream.resume();
            }
          };

          return this;
        };

        Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function () {
            return this._readableState.highWaterMark;
          }
        }); // exposed for testing purposes only.

        Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
        // Length is the combined lengths of all the buffers in the list.
        // This function is designed to be inlinable, so please take care when making
        // changes to the function body.

        function fromList(n, state) {
          // nothing buffered
          if (state.length === 0) return null;
          var ret;
          if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
            // read it all, truncate the list
            if (state.decoder) ret = state.buffer.join(''); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);
            state.buffer.clear();
          } else {
            // read part of list
            ret = fromListPartial(n, state.buffer, state.decoder);
          }
          return ret;
        } // Extracts only enough buffered data to satisfy the amount requested.
        // This function is designed to be inlinable, so please take care when making
        // changes to the function body.


        function fromListPartial(n, list, hasStrings) {
          var ret;

          if (n < list.head.data.length) {
            // slice is the same for buffers and strings
            ret = list.head.data.slice(0, n);
            list.head.data = list.head.data.slice(n);
          } else if (n === list.head.data.length) {
            // first chunk is a perfect match
            ret = list.shift();
          } else {
            // result spans more than one buffer
            ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
          }

          return ret;
        } // Copies a specified amount of characters from the list of buffered data
        // chunks.
        // This function is designed to be inlinable, so please take care when making
        // changes to the function body.


        function copyFromBufferString(n, list) {
          var p = list.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;

          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str; else ret += str.slice(0, n);
            n -= nb;

            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) list.head = p.next; else list.head = list.tail = null;
              } else {
                list.head = p;
                p.data = str.slice(nb);
              }

              break;
            }

            ++c;
          }

          list.length -= c;
          return ret;
        } // Copies a specified amount of bytes from the list of buffered data chunks.
        // This function is designed to be inlinable, so please take care when making
        // changes to the function body.


        function copyFromBuffer(n, list) {
          var ret = Buffer.allocUnsafe(n);
          var p = list.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;

          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;

            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) list.head = p.next; else list.head = list.tail = null;
              } else {
                list.head = p;
                p.data = buf.slice(nb);
              }

              break;
            }

            ++c;
          }

          list.length -= c;
          return ret;
        }

        function endReadable(stream) {
          var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
          // bug in node.  Should never happen.

          if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

          if (!state.endEmitted) {
            state.ended = true;
            pna.nextTick(endReadableNT, state, stream);
          }
        }

        function endReadableNT(state, stream) {
          // Check that we didn't get one last unshift.
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        }

        function indexOf(xs, x) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x) return i;
          }

          return -1;
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12), __webpack_require__(15)))

      /***/
    }),
/* 95 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(52).EventEmitter;

      /***/
    }),
/* 96 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";

      /*<replacement>*/

      var pna = __webpack_require__(38);
      /*</replacement>*/
      // undocumented cb() API, needed for core, not for public API


      function destroy(err, cb) {
        var _this = this;

        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;

        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
            pna.nextTick(emitErrorNT, this, err);
          }

          return this;
        } // we set destroyed to true before firing error callbacks in order
        // to make it re-entrance safe in case destroy() is called within callbacks


        if (this._readableState) {
          this._readableState.destroyed = true;
        } // if this is a duplex stream mark the writable part as destroyed as well


        if (this._writableState) {
          this._writableState.destroyed = true;
        }

        this._destroy(err || null, function (err) {
          if (!cb && err) {
            pna.nextTick(emitErrorNT, _this, err);

            if (_this._writableState) {
              _this._writableState.errorEmitted = true;
            }
          } else if (cb) {
            cb(err);
          }
        });

        return this;
      }

      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }

        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }

      function emitErrorNT(self, err) {
        self.emit('error', err);
      }

      module.exports = {
        destroy: destroy,
        undestroy: undestroy
      };

      /***/
    }),
/* 97 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      /*<replacement>*/

      var Buffer = __webpack_require__(299).Buffer;
      /*</replacement>*/


      var isEncoding = Buffer.isEncoding || function (encoding) {
        encoding = '' + encoding;

        switch (encoding && encoding.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return true;

          default:
            return false;
        }
      };

      function _normalizeEncoding(enc) {
        if (!enc) return 'utf8';
        var retried;

        while (true) {
          switch (enc) {
            case 'utf8':
            case 'utf-8':
              return 'utf8';

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 'utf16le';

            case 'latin1':
            case 'binary':
              return 'latin1';

            case 'base64':
            case 'ascii':
            case 'hex':
              return enc;

            default:
              if (retried) return; // undefined

              enc = ('' + enc).toLowerCase();
              retried = true;
          }
        }
      }

      ; // Do not cache `Buffer.isEncoding` when checking encoding names as some
      // modules monkey-patch it to support additional encodings

      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);

        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
        return nenc || enc;
      } // StringDecoder provides an interface for efficiently splitting a series of
      // buffers into a series of JS strings without breaking apart multi-byte
      // characters.


      exports.StringDecoder = StringDecoder;

      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;

        switch (this.encoding) {
          case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;

          case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;

          case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;

          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }

        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
      }

      StringDecoder.prototype.write = function (buf) {
        if (buf.length === 0) return '';
        var r;
        var i;

        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === undefined) return '';
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }

        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || '';
      };

      StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

      StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

      StringDecoder.prototype.fillLast = function (buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }

        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
      // continuation byte. If an invalid byte is detected, -2 is returned.


      function utf8CheckByte(byte) {
        if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4;
        return byte >> 6 === 0x02 ? -1 : -2;
      } // Checks at most 3 bytes at the end of a Buffer in order to detect an
      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
      // needed to complete the UTF-8 character (if applicable) are returned.


      function utf8CheckIncomplete(self, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);

        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 1;
          return nb;
        }

        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);

        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 2;
          return nb;
        }

        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);

        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0; else self.lastNeed = nb - 3;
          }

          return nb;
        }

        return 0;
      } // Validates as many continuation bytes for a multi-byte UTF-8 character as
      // needed or are available. If we see a non-continuation byte where we expect
      // one, we "replace" the validated continuation bytes we've seen so far with
      // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
      // behavior. The continuation byte check is included three times in the case
      // where all of the continuation bytes for a character exist in the same buffer.
      // It is also done this way as a slight performance increase instead of using a
      // loop.


      function utf8CheckExtraBytes(self, buf, p) {
        if ((buf[0] & 0xC0) !== 0x80) {
          self.lastNeed = 0;
          return '\ufffd';
        }

        if (self.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return '\ufffd';
          }

          if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
              self.lastNeed = 2;
              return '\ufffd';
            }
          }
        }
      } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== undefined) return r;

        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }

        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
      // partial character, the character's bytes are buffered until the required
      // number of bytes are available.


      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString('utf8', i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString('utf8', i, end);
      } // For UTF-8, a replacement character is added when ending on a partial
      // character.


      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + '\ufffd';
        return r;
      } // UTF-16LE typically needs two bytes per character, but even if we have an even
      // number of bytes available, we need to check if we end on a leading/high
      // surrogate. In that case, we need to wait for the next two bytes in order to
      // decode the last character properly.


      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString('utf16le', i);

          if (r) {
            var c = r.charCodeAt(r.length - 1);

            if (c >= 0xD800 && c <= 0xDBFF) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }

          return r;
        }

        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString('utf16le', i, buf.length - 1);
      } // For UTF-16LE we do not explicitly append special replacement characters if we
      // end on a partial character, we simply let v8 handle that.


      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';

        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString('utf16le', 0, end);
        }

        return r;
      }

      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString('base64', i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;

        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }

        return buf.toString('base64', i, buf.length - n);
      }

      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
        return r;
      } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }

      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : '';
      }

      /***/
    }),
/* 98 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      // a transform stream is a readable/writable stream where you do
      // something with the data.  Sometimes it's called a "filter",
      // but that's not a great name for it, since that implies a thing where
      // some bits pass through, and others are simply ignored.  (That would
      // be a valid example of a transform, of course.)
      //
      // While the output is causally related to the input, it's not a
      // necessarily symmetric or synchronous transformation.  For example,
      // a zlib stream might take multiple plain-text writes(), and then
      // emit a single compressed chunk some time in the future.
      //
      // Here's how this works:
      //
      // The Transform stream has all the aspects of the readable and writable
      // stream classes.  When you write(chunk), that calls _write(chunk,cb)
      // internally, and returns false if there's a lot of pending writes
      // buffered up.  When you call read(), that calls _read(n) until
      // there's enough pending readable data buffered up.
      //
      // In a transform stream, the written data is placed in a buffer.  When
      // _read(n) is called, it transforms the queued up data, calling the
      // buffered _write cb's as it consumes chunks.  If consuming a single
      // written chunk would result in multiple output chunks, then the first
      // outputted bit calls the readcb, and subsequent chunks just go into
      // the read buffer, and will cause it to emit 'readable' if necessary.
      //
      // This way, back-pressure is actually determined by the reading side,
      // since _read has to be called to start processing a new chunk.  However,
      // a pathological inflate type of transform can cause excessive buffering
      // here.  For example, imagine a stream where every byte of input is
      // interpreted as an integer from 0-255, and then results in that many
      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
      // 1kb of data being output.  In this case, you could write a very small
      // amount of input, and end up with a very large amount of output.  In
      // such a pathological inflating mechanism, there'd be no way to tell
      // the system to stop doing the transform.  A single 4MB write could
      // cause the system to run out of memory.
      //
      // However, even in such a pathological case, only a single written chunk
      // would be consumed, and then the rest would wait (un-transformed) until
      // the results of the previous transformed chunk were consumed.


      module.exports = Transform;

      var Duplex = __webpack_require__(16);
      /*<replacement>*/


      var util = Object.create(__webpack_require__(27));
      util.inherits = __webpack_require__(22);
      /*</replacement>*/

      util.inherits(Transform, Duplex);

      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;

        if (!cb) {
          return this.emit('error', new Error('write callback called multiple times'));
        }

        ts.writechunk = null;
        ts.writecb = null;
        if (data != null) // single equals check for both `null` and `undefined`
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;

        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }

      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }; // start out asking for a readable event once data is transformed.

        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.

        this._readableState.sync = false;

        if (options) {
          if (typeof options.transform === 'function') this._transform = options.transform;
          if (typeof options.flush === 'function') this._flush = options.flush;
        } // When the writable side finishes, then flush out anything remaining.


        this.on('prefinish', prefinish);
      }

      function prefinish() {
        var _this = this;

        if (typeof this._flush === 'function') {
          this._flush(function (er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }

      Transform.prototype.push = function (chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      }; // This is the part where you do stuff!
      // override this function in implementation classes.
      // 'chunk' is an input chunk.
      //
      // Call `push(newChunk)` to pass along transformed output
      // to the readable side.  You may call 'push' zero or more times.
      //
      // Call `cb(err)` when you are done with this chunk.  If you pass
      // an error, then that'll put the hurt on the whole operation.  If you
      // never call cb(), then you'll never get another chunk.


      Transform.prototype._transform = function (chunk, encoding, cb) {
        throw new Error('_transform() is not implemented');
      };

      Transform.prototype._write = function (chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;

        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      }; // Doesn't matter what the args are here.
      // _transform does all the work.
      // That we got here means that the readable side wants more data.


      Transform.prototype._read = function (n) {
        var ts = this._transformState;

        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;

          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          // mark that we need a transform, so that any data that comes in
          // will get processed, now that we've asked for it.
          ts.needTransform = true;
        }
      };

      Transform.prototype._destroy = function (err, cb) {
        var _this2 = this;

        Duplex.prototype._destroy.call(this, err, function (err2) {
          cb(err2);

          _this2.emit('close');
        });
      };

      function done(stream, er, data) {
        if (er) return stream.emit('error', er);
        if (data != null) // single equals check for both `null` and `undefined`
          stream.push(data); // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided

        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
        return stream.push(null);
      }

      /***/
    }),
/* 99 */
/***/ (function (module, exports, __webpack_require__) {

      var CVUtils = __webpack_require__(8);

      var Ndarray = __webpack_require__(51);

      var Interp2D = __webpack_require__(306).d2;

      var FrameGrabber = {};

      FrameGrabber.create = function (inputStream) {
        var _that = {};

        var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());

        var _canvasSize = inputStream.getCanvasSize();

        var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());

        var _topRight = inputStream.getTopRight();

        var _data = new Uint8Array(_size.x * _size.y);

        var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);

        var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);
        /* eslint-disable new-cap */


        var _grayImageArray = Ndarray(_grayData, [_videoSize.y, _videoSize.x]).transpose(1, 0);

        var _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0);

        var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);

        var _stepSizeX = _videoSize.x / _canvasSize.x;

        var _stepSizeY = _videoSize.y / _canvasSize.y;

        if (true) {
          console.log('FrameGrabber', JSON.stringify({
            videoSize: _grayImageArray.shape,
            canvasSize: _canvasImageArray.shape,
            stepSize: [_stepSizeX, _stepSizeY],
            size: _targetImageArray.shape,
            topRight: _topRight
          }));
        }
        /**
         * Uses the given array as frame-buffer
         */


        _that.attachData = function (data) {
          _data = data;
        };
        /**
         * Returns the used frame-buffer
         */


        _that.getData = function () {
          return _data;
        };
        /**
         * Fetches a frame from the input-stream and puts into the frame-buffer.
         * The image-data is converted to gray-scale and then half-sampled if configured.
         */


        _that.grab = function () {
          var frame = inputStream.getFrame();

          if (frame) {
            this.scaleAndCrop(frame);
            return true;
          }

          return false;
        }; // eslint-disable-next-line


        _that.scaleAndCrop = function (frame) {
          // 1. compute full-sized gray image
          CVUtils.computeGray(frame.data, _grayData); // 2. interpolate

          for (var y = 0; y < _canvasSize.y; y++) {
            for (var x = 0; x < _canvasSize.x; x++) {
              // eslint-disable-next-line no-bitwise
              _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
            }
          } // targetImageArray must be equal to targetSize


          if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
            throw new Error('Shapes do not match!');
          } // 3. crop


          for (var _y = 0; _y < _size.y; _y++) {
            for (var _x = 0; _x < _size.x; _x++) {
              _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);
            }
          }
        };

        _that.getSize = function () {
          return _size;
        };

        return _that;
      };

      module.exports = FrameGrabber;

      /***/
    }),
/* 100 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = {
        EPSILON: __webpack_require__(67),
        create: __webpack_require__(68),
        clone: __webpack_require__(145),
        angle: __webpack_require__(146),
        fromValues: __webpack_require__(69),
        copy: __webpack_require__(147),
        set: __webpack_require__(148),
        equals: __webpack_require__(149),
        exactEquals: __webpack_require__(150),
        add: __webpack_require__(151),
        subtract: __webpack_require__(72),
        sub: __webpack_require__(152),
        multiply: __webpack_require__(73),
        mul: __webpack_require__(153),
        divide: __webpack_require__(74),
        div: __webpack_require__(154),
        min: __webpack_require__(155),
        max: __webpack_require__(156),
        floor: __webpack_require__(157),
        ceil: __webpack_require__(158),
        round: __webpack_require__(159),
        scale: __webpack_require__(160),
        scaleAndAdd: __webpack_require__(161),
        distance: __webpack_require__(75),
        dist: __webpack_require__(162),
        squaredDistance: __webpack_require__(76),
        sqrDist: __webpack_require__(163),
        length: __webpack_require__(77),
        len: __webpack_require__(164),
        squaredLength: __webpack_require__(78),
        sqrLen: __webpack_require__(165),
        negate: __webpack_require__(166),
        inverse: __webpack_require__(167),
        normalize: __webpack_require__(70),
        dot: __webpack_require__(71),
        cross: __webpack_require__(168),
        lerp: __webpack_require__(169),
        random: __webpack_require__(170),
        transformMat4: __webpack_require__(171),
        transformMat3: __webpack_require__(172),
        transformQuat: __webpack_require__(173),
        rotateX: __webpack_require__(174),
        rotateY: __webpack_require__(175),
        rotateZ: __webpack_require__(176),
        forEach: __webpack_require__(177)
      };

      /***/
    }),
/* 101 */
/***/ (function (module, exports, __webpack_require__) {

      var basePick = __webpack_require__(246),
        flatRest = __webpack_require__(260);
      /**
       * Creates an object composed of the picked `object` properties.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pick(object, ['a', 'c']);
       * // => { 'a': 1, 'c': 3 }
       */


      var pick = flatRest(function (object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      module.exports = pick;

      /***/
    }),
/* 102 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);

      /**
       * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
       */

      var Rasterizer = {
        createContour2D: function createContour2D() {
          return {
            dir: null,
            index: null,
            firstVertex: null,
            insideContours: null,
            nextpeer: null,
            prevpeer: null
          };
        },
        CONTOUR_DIR: {
          CW_DIR: 0,
          CCW_DIR: 1,
          UNKNOWN_DIR: 2
        },
        DIR: {
          OUTSIDE_EDGE: -32767,
          INSIDE_EDGE: -32766
        },
        create: function create(imageWrapper, labelWrapper) {
          var imageData = imageWrapper.data;
          var labelData = labelWrapper.data;
          var width = imageWrapper.size.x;
          var height = imageWrapper.size.y;
          var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
          return {
            rasterize: function rasterize(depthlabel) {
              var color;
              var bc;
              var lc;
              var labelindex;
              var cx;
              var cy;
              var colorMap = [];
              var vertex;
              var p;
              var cc;
              var sc;
              var pos;
              var connectedCount = 0;
              var i;

              for (i = 0; i < 400; i++) {
                colorMap[i] = 0;
              }

              colorMap[0] = imageData[0];
              cc = null;

              for (cy = 1; cy < height - 1; cy++) {
                labelindex = 0;
                bc = colorMap[0];

                for (cx = 1; cx < width - 1; cx++) {
                  pos = cy * width + cx;

                  if (labelData[pos] === 0) {
                    color = imageData[pos];

                    if (color !== bc) {
                      if (labelindex === 0) {
                        lc = connectedCount + 1;
                        colorMap[lc] = color;
                        bc = color;
                        vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                        if (vertex !== null) {
                          connectedCount++;
                          labelindex = lc;
                          p = Rasterizer.createContour2D();
                          p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                          p.index = labelindex;
                          p.firstVertex = vertex;
                          p.nextpeer = cc;
                          p.insideContours = null;

                          if (cc !== null) {
                            cc.prevpeer = p;
                          }

                          cc = p;
                        }
                      } else {
                        vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                        if (vertex !== null) {
                          p = Rasterizer.createContour2D();
                          p.firstVertex = vertex;
                          p.insideContours = null;

                          if (depthlabel === 0) {
                            p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                          } else {
                            p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                          }

                          p.index = depthlabel;
                          sc = cc;

                          while (sc !== null && sc.index !== labelindex) {
                            sc = sc.nextpeer;
                          }

                          if (sc !== null) {
                            p.nextpeer = sc.insideContours;

                            if (sc.insideContours !== null) {
                              sc.insideContours.prevpeer = p;
                            }

                            sc.insideContours = p;
                          }
                        }
                      }
                    } else {
                      labelData[pos] = labelindex;
                    }
                  } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                    labelindex = 0;

                    if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                      bc = imageData[pos];
                    } else {
                      bc = colorMap[0];
                    }
                  } else {
                    labelindex = labelData[pos];
                    bc = colorMap[labelindex];
                  }
                }
              }

              sc = cc;

              while (sc !== null) {
                sc.index = depthlabel;
                sc = sc.nextpeer;
              }

              return {
                cc: cc,
                count: connectedCount
              };
            },
            debug: {
              drawContour: function drawContour(canvas, firstContour) {
                var ctx = canvas.getContext('2d');
                var pq = firstContour;
                var iq;
                var q;
                var p;
                ctx.strokeStyle = 'red';
                ctx.fillStyle = 'red';
                ctx.lineWidth = 1;

                if (pq !== null) {
                  iq = pq.insideContours;
                } else {
                  iq = null;
                }

                while (pq !== null) {
                  if (iq !== null) {
                    q = iq;
                    iq = iq.nextpeer;
                  } else {
                    q = pq;
                    pq = pq.nextpeer;

                    if (pq !== null) {
                      iq = pq.insideContours;
                    } else {
                      iq = null;
                    }
                  }

                  switch (q.dir) {
                    case Rasterizer.CONTOUR_DIR.CW_DIR:
                      ctx.strokeStyle = 'red';
                      break;

                    case Rasterizer.CONTOUR_DIR.CCW_DIR:
                      ctx.strokeStyle = 'blue';
                      break;

                    case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                      ctx.strokeStyle = 'green';
                      break;
                  }

                  p = q.firstVertex;
                  ctx.beginPath();
                  ctx.moveTo(p.x, p.y);

                  do {
                    p = p.next;
                    ctx.lineTo(p.x, p.y);
                  } while (p !== q.firstVertex);

                  ctx.stroke();
                }
              }
            }
          };
        }
      };
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

      /***/
    }),
/* 103 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
      /* eslint-disable no-param-reassign */

      /* eslint-disable no-bitwise */

      /* eslint-disable eqeqeq */

      /* @preserve ASM BEGIN */
      function Skeletonizer(stdlib, foreign, buffer) {
        'use asm';

        var images = new stdlib.Uint8Array(buffer);
        var size = foreign.size | 0;
        var imul = stdlib.Math.imul;

        function erode(inImagePtr, outImagePtr) {
          inImagePtr |= 0;
          outImagePtr |= 0;
          var v = 0;
          var u = 0;
          var sum = 0;
          var yStart1 = 0;
          var yStart2 = 0;
          var xStart1 = 0;
          var xStart2 = 0;
          var offset = 0;

          for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;

            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
              yStart1 = offset - size | 0;
              yStart2 = offset + size | 0;
              xStart1 = u - 1 | 0;
              xStart2 = u + 1 | 0;
              sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

              if ((sum | 0) == (5 | 0)) {
                images[outImagePtr + offset + u | 0] = 1;
              } else {
                images[outImagePtr + offset + u | 0] = 0;
              }
            }
          }
        }

        function subtract(aImagePtr, bImagePtr, outImagePtr) {
          aImagePtr |= 0;
          bImagePtr |= 0;
          outImagePtr |= 0;
          var length = 0;
          length = imul(size, size) | 0;

          while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
          }
        }

        function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
          aImagePtr |= 0;
          bImagePtr |= 0;
          outImagePtr |= 0;
          var length = 0;
          length = imul(size, size) | 0;

          while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
          }
        }

        function countNonZero(imagePtr) {
          imagePtr |= 0;
          var sum = 0;
          var length = 0;
          length = imul(size, size) | 0;

          while ((length | 0) > 0) {
            length = length - 1 | 0;
            sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
          }

          return sum | 0;
        }

        function init(imagePtr, value) {
          imagePtr |= 0;
          value |= 0;
          var length = 0;
          length = imul(size, size) | 0;

          while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[imagePtr + length | 0] = value;
          }
        }

        function dilate(inImagePtr, outImagePtr) {
          inImagePtr |= 0;
          outImagePtr |= 0;
          var v = 0;
          var u = 0;
          var sum = 0;
          var yStart1 = 0;
          var yStart2 = 0;
          var xStart1 = 0;
          var xStart2 = 0;
          var offset = 0;

          for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;

            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
              yStart1 = offset - size | 0;
              yStart2 = offset + size | 0;
              xStart1 = u - 1 | 0;
              xStart2 = u + 1 | 0;
              sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

              if ((sum | 0) > (0 | 0)) {
                images[outImagePtr + offset + u | 0] = 1;
              } else {
                images[outImagePtr + offset + u | 0] = 0;
              }
            }
          }
        }

        function memcpy(srcImagePtr, dstImagePtr) {
          srcImagePtr |= 0;
          dstImagePtr |= 0;
          var length = 0;
          length = imul(size, size) | 0;

          while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
          }
        }

        function zeroBorder(imagePtr) {
          imagePtr |= 0;
          var x = 0;
          var y = 0;

          for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
            images[imagePtr + x | 0] = 0;
            images[imagePtr + y | 0] = 0;
            y = y + size - 1 | 0;
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
          }

          for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
          }
        }

        function skeletonize() {
          var subImagePtr = 0;
          var erodedImagePtr = 0;
          var tempImagePtr = 0;
          var skelImagePtr = 0;
          var sum = 0;
          var done = 0;
          erodedImagePtr = imul(size, size) | 0;
          tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
          skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

          init(skelImagePtr, 0);
          zeroBorder(subImagePtr);

          do {
            erode(subImagePtr, erodedImagePtr);
            dilate(erodedImagePtr, tempImagePtr);
            subtract(subImagePtr, tempImagePtr, tempImagePtr);
            bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
            memcpy(erodedImagePtr, subImagePtr);
            sum = countNonZero(subImagePtr) | 0;
            done = (sum | 0) == 0 | 0;
          } while (!done);
        }

        return {
          skeletonize: skeletonize
        };
      }
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
      /* eslint-enable eqeqeq */

      /***/
    }),
/* 104 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
/* WEBPACK VAR INJECTION */(function (process, Buffer) {

        var path = __webpack_require__(280);

        var ndarray = __webpack_require__(51);

        var GifReader = __webpack_require__(283).GifReader;

        var pack = __webpack_require__(284);

        var through = __webpack_require__(290);

        var parseDataURI = __webpack_require__(305);

        function defaultImage(url, cb) {
          var img = new Image();
          img.crossOrigin = "Anonymous";

          img.onload = function () {
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var context = canvas.getContext('2d');
            context.drawImage(img, 0, 0);
            var pixels = context.getImageData(0, 0, img.width, img.height);
            cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4 * img.width, 1], 0));
          };

          img.onerror = function (err) {
            cb(err);
          };

          img.src = url;
        } //Animated gif loading


        function handleGif(data, cb) {
          var reader;

          try {
            reader = new GifReader(data);
          } catch (err) {
            cb(err);
            return;
          }

          if (reader.numFrames() > 0) {
            var nshape = [reader.numFrames(), reader.height, reader.width, 4];
            var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3]);
            var result = ndarray(ndata, nshape);

            try {
              for (var i = 0; i < reader.numFrames(); ++i) {
                reader.decodeAndBlitFrameRGBA(i, ndata.subarray(result.index(i, 0, 0, 0), result.index(i + 1, 0, 0, 0)));
              }
            } catch (err) {
              cb(err);
              return;
            }

            cb(null, result.transpose(0, 2, 1));
          } else {
            var nshape = [reader.height, reader.width, 4];
            var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
            var result = ndarray(ndata, nshape);

            try {
              reader.decodeAndBlitFrameRGBA(0, ndata);
            } catch (err) {
              cb(err);
              return;
            }

            cb(null, result.transpose(1, 0));
          }
        }

        function httpGif(url, cb) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';

          if (xhr.overrideMimeType) {
            xhr.overrideMimeType('application/binary');
          }

          xhr.onerror = function (err) {
            cb(err);
          };

          xhr.onload = function () {
            if (xhr.readyState !== 4) {
              return;
            }

            var data = new Uint8Array(xhr.response);
            handleGif(data, cb);
            return;
          };

          xhr.send();
        }

        function copyBuffer(buffer) {
          if (buffer[0] === undefined) {
            var n = buffer.length;
            var result = new Uint8Array(n);

            for (var i = 0; i < n; ++i) {
              result[i] = buffer.get(i);
            }

            return result;
          } else {
            return new Uint8Array(buffer);
          }
        }

        function dataGif(url, cb) {
          process.nextTick(function () {
            try {
              var buffer = parseDataURI(url);

              if (buffer) {
                handleGif(copyBuffer(buffer), cb);
              } else {
                cb(new Error('Error parsing data URI'));
              }
            } catch (err) {
              cb(err);
            }
          });
        }

        module.exports = function getPixels(url, type, cb) {
          if (!cb) {
            cb = type;
            type = '';
          }

          var ext = path.extname(url);

          switch (type || ext.toUpperCase()) {
            case '.GIF':
              httpGif(url, cb);
              break;

            default:
              if (Buffer.isBuffer(url)) {
                url = 'data:' + type + ';base64,' + url.toString('base64');
              }

              if (url.indexOf('data:image/gif;') === 0) {
                dataGif(url, cb);
              } else {
                defaultImage(url, cb);
              }

          }
        };
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(15), __webpack_require__(26).Buffer))

      /***/
    }),
/* 105 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(307);


      /***/
    }),
/* 106 */
/***/ (function (module, exports) {

      /*
       * typedefs.js
       * Normalizes browser-specific prefixes and provide some basic polyfills
       */
      if (typeof window !== 'undefined') {
        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = function () {
            return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
              /* function FrameRequestCallback */
              callback) {
              window.setTimeout(callback, 1000 / 60);
            };
          }();
        }
      }

      if (typeof Math.imul !== 'function') {
        /* eslint-disable no-bitwise */
        Math.imul = function (a, b) {
          var ah = a >>> 16 & 0xffff;
          var al = a & 0xffff;
          var bh = b >>> 16 & 0xffff;
          var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
          // the final |0 converts the unsigned value into a signed value

          return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
        };
        /* eslint-enable no-bitwise */

      }

      if (typeof Object.assign !== 'function') {
        Object.assign = function (target) {
          // .length of function is 2
          'use strict';

          if (target === null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
          }

          var to = Object(target);

          for (var index = 1; index < arguments.length; index++) {
            // eslint-disable-next-line prefer-rest-params
            var nextSource = arguments[index];

            if (nextSource !== null) {
              // Skip over if undefined or null
              // eslint-disable-next-line no-restricted-syntax
              for (var nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                  to[nextKey] = nextSource[nextKey];
                }
              }
            }
          }

          return to;
        };
      }

      /***/
    }),
/* 107 */
/***/ (function (module, exports) {

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      module.exports = _arrayWithHoles;

      /***/
    }),
/* 108 */
/***/ (function (module, exports) {

      function _iterableToArrayLimit(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      module.exports = _iterableToArrayLimit;

      /***/
    }),
/* 109 */
/***/ (function (module, exports) {

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      module.exports = _nonIterableRest;

      /***/
    }),
/* 110 */
/***/ (function (module, exports) {

      module.exports = clone;
      /**
       * Creates a new vec2 initialized with values from an existing vector
       *
       * @param {vec2} a vector to clone
       * @returns {vec2} a new 2D vector
       */

      function clone(a) {
        var out = new Float32Array(2);
        out[0] = a[0];
        out[1] = a[1];
        return out;
      }

      /***/
    }),
/* 111 */
/***/ (function (module, exports) {

      module.exports = fromValues;
      /**
       * Creates a new vec2 initialized with the given values
       *
       * @param {Number} x X component
       * @param {Number} y Y component
       * @returns {vec2} a new 2D vector
       */

      function fromValues(x, y) {
        var out = new Float32Array(2);
        out[0] = x;
        out[1] = y;
        return out;
      }

      /***/
    }),
/* 112 */
/***/ (function (module, exports) {

      module.exports = copy;
      /**
       * Copy the values from one vec2 to another
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the source vector
       * @returns {vec2} out
       */

      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        return out;
      }

      /***/
    }),
/* 113 */
/***/ (function (module, exports) {

      module.exports = set;
      /**
       * Set the components of a vec2 to the given values
       *
       * @param {vec2} out the receiving vector
       * @param {Number} x X component
       * @param {Number} y Y component
       * @returns {vec2} out
       */

      function set(out, x, y) {
        out[0] = x;
        out[1] = y;
        return out;
      }

      /***/
    }),
/* 114 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = equals;

      var EPSILON = __webpack_require__(58);
      /**
       * Returns whether or not the vectors have approximately the same elements in the same position.
       *
       * @param {vec2} a The first vector.
       * @param {vec2} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0];
        var a1 = a[1];
        var b0 = b[0];
        var b1 = b[1];
        return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
      }

      /***/
    }),
/* 115 */
/***/ (function (module, exports) {

      module.exports = exactEquals;
      /**
       * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
       *
       * @param {vec2} a The first vector.
       * @param {vec2} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */

      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
      }

      /***/
    }),
/* 116 */
/***/ (function (module, exports) {

      module.exports = add;
      /**
       * Adds two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */

      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        return out;
      }

      /***/
    }),
/* 117 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(60);

      /***/
    }),
/* 118 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(61);

      /***/
    }),
/* 119 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(62);

      /***/
    }),
/* 120 */
/***/ (function (module, exports) {

      module.exports = inverse;
      /**
       * Returns the inverse of the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to invert
       * @returns {vec2} out
       */

      function inverse(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        return out;
      }

      /***/
    }),
/* 121 */
/***/ (function (module, exports) {

      module.exports = min;
      /**
       * Returns the minimum of two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */

      function min(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        return out;
      }

      /***/
    }),
/* 122 */
/***/ (function (module, exports) {

      module.exports = max;
      /**
       * Returns the maximum of two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */

      function max(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        return out;
      }

      /***/
    }),
/* 123 */
/***/ (function (module, exports) {

      module.exports = rotate;
      /**
       * Rotates a vec2 by an angle
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to rotate
       * @param {Number} angle the angle of rotation (in radians)
       * @returns {vec2} out
       */

      function rotate(out, a, angle) {
        var c = Math.cos(angle),
          s = Math.sin(angle);
        var x = a[0],
          y = a[1];
        out[0] = x * c - y * s;
        out[1] = x * s + y * c;
        return out;
      }

      /***/
    }),
/* 124 */
/***/ (function (module, exports) {

      module.exports = floor;
      /**
       * Math.floor the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to floor
       * @returns {vec2} out
       */

      function floor(out, a) {
        out[0] = Math.floor(a[0]);
        out[1] = Math.floor(a[1]);
        return out;
      }

      /***/
    }),
/* 125 */
/***/ (function (module, exports) {

      module.exports = ceil;
      /**
       * Math.ceil the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to ceil
       * @returns {vec2} out
       */

      function ceil(out, a) {
        out[0] = Math.ceil(a[0]);
        out[1] = Math.ceil(a[1]);
        return out;
      }

      /***/
    }),
/* 126 */
/***/ (function (module, exports) {

      module.exports = round;
      /**
       * Math.round the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to round
       * @returns {vec2} out
       */

      function round(out, a) {
        out[0] = Math.round(a[0]);
        out[1] = Math.round(a[1]);
        return out;
      }

      /***/
    }),
/* 127 */
/***/ (function (module, exports) {

      module.exports = scale;
      /**
       * Scales a vec2 by a scalar number
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to scale
       * @param {Number} b amount to scale the vector by
       * @returns {vec2} out
       */

      function scale(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        return out;
      }

      /***/
    }),
/* 128 */
/***/ (function (module, exports) {

      module.exports = scaleAndAdd;
      /**
       * Adds two vec2's after scaling the second operand by a scalar value
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @param {Number} scale the amount to scale b by before adding
       * @returns {vec2} out
       */

      function scaleAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        return out;
      }

      /***/
    }),
/* 129 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(63);

      /***/
    }),
/* 130 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(64);

      /***/
    }),
/* 131 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(65);

      /***/
    }),
/* 132 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(66);

      /***/
    }),
/* 133 */
/***/ (function (module, exports) {

      module.exports = negate;
      /**
       * Negates the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to negate
       * @returns {vec2} out
       */

      function negate(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        return out;
      }

      /***/
    }),
/* 134 */
/***/ (function (module, exports) {

      module.exports = normalize;
      /**
       * Normalize a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to normalize
       * @returns {vec2} out
       */

      function normalize(out, a) {
        var x = a[0],
          y = a[1];
        var len = x * x + y * y;

        if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
        }

        return out;
      }

      /***/
    }),
/* 135 */
/***/ (function (module, exports) {

      module.exports = dot;
      /**
       * Calculates the dot product of two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} dot product of a and b
       */

      function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }

      /***/
    }),
/* 136 */
/***/ (function (module, exports) {

      module.exports = cross;
      /**
       * Computes the cross product of two vec2's
       * Note that the cross product must by definition produce a 3D vector
       *
       * @param {vec3} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec3} out
       */

      function cross(out, a, b) {
        var z = a[0] * b[1] - a[1] * b[0];
        out[0] = out[1] = 0;
        out[2] = z;
        return out;
      }

      /***/
    }),
/* 137 */
/***/ (function (module, exports) {

      module.exports = lerp;
      /**
       * Performs a linear interpolation between two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @param {Number} t interpolation amount between the two inputs
       * @returns {vec2} out
       */

      function lerp(out, a, b, t) {
        var ax = a[0],
          ay = a[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
      }

      /***/
    }),
/* 138 */
/***/ (function (module, exports) {

      module.exports = random;
      /**
       * Generates a random vector with the given scale
       *
       * @param {vec2} out the receiving vector
       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
       * @returns {vec2} out
       */

      function random(out, scale) {
        scale = scale || 1.0;
        var r = Math.random() * 2.0 * Math.PI;
        out[0] = Math.cos(r) * scale;
        out[1] = Math.sin(r) * scale;
        return out;
      }

      /***/
    }),
/* 139 */
/***/ (function (module, exports) {

      module.exports = transformMat2;
      /**
       * Transforms the vec2 with a mat2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat2} m matrix to transform with
       * @returns {vec2} out
       */

      function transformMat2(out, a, m) {
        var x = a[0],
          y = a[1];
        out[0] = m[0] * x + m[2] * y;
        out[1] = m[1] * x + m[3] * y;
        return out;
      }

      /***/
    }),
/* 140 */
/***/ (function (module, exports) {

      module.exports = transformMat2d;
      /**
       * Transforms the vec2 with a mat2d
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat2d} m matrix to transform with
       * @returns {vec2} out
       */

      function transformMat2d(out, a, m) {
        var x = a[0],
          y = a[1];
        out[0] = m[0] * x + m[2] * y + m[4];
        out[1] = m[1] * x + m[3] * y + m[5];
        return out;
      }

      /***/
    }),
/* 141 */
/***/ (function (module, exports) {

      module.exports = transformMat3;
      /**
       * Transforms the vec2 with a mat3
       * 3rd vector component is implicitly '1'
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat3} m matrix to transform with
       * @returns {vec2} out
       */

      function transformMat3(out, a, m) {
        var x = a[0],
          y = a[1];
        out[0] = m[0] * x + m[3] * y + m[6];
        out[1] = m[1] * x + m[4] * y + m[7];
        return out;
      }

      /***/
    }),
/* 142 */
/***/ (function (module, exports) {

      module.exports = transformMat4;
      /**
       * Transforms the vec2 with a mat4
       * 3rd vector component is implicitly '0'
       * 4th vector component is implicitly '1'
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat4} m matrix to transform with
       * @returns {vec2} out
       */

      function transformMat4(out, a, m) {
        var x = a[0],
          y = a[1];
        out[0] = m[0] * x + m[4] * y + m[12];
        out[1] = m[1] * x + m[5] * y + m[13];
        return out;
      }

      /***/
    }),
/* 143 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = forEach;

      var vec = __webpack_require__(59)();
      /**
       * Perform some operation over an array of vec2s.
       *
       * @param {Array} a the array of vectors to iterate over
       * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
       * @param {Number} offset Number of elements to skip at the beginning of the array
       * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
       * @param {Function} fn Function to call for each vector in the array
       * @param {Object} [arg] additional argument to pass to fn
       * @returns {Array} a
       * @function
       */


      function forEach(a, stride, offset, count, fn, arg) {
        var i, l;

        if (!stride) {
          stride = 2;
        }

        if (!offset) {
          offset = 0;
        }

        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }

        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
        }

        return a;
      }

      /***/
    }),
/* 144 */
/***/ (function (module, exports) {

      module.exports = limit;
      /**
       * Limit the magnitude of this vector to the value used for the `max`
       * parameter.
       *
       * @param  {vec2} the vector to limit
       * @param  {Number} max the maximum magnitude for the vector
       * @returns {vec2} out
       */

      function limit(out, a, max) {
        var mSq = a[0] * a[0] + a[1] * a[1];

        if (mSq > max * max) {
          var n = Math.sqrt(mSq);
          out[0] = a[0] / n * max;
          out[1] = a[1] / n * max;
        } else {
          out[0] = a[0];
          out[1] = a[1];
        }

        return out;
      }

      /***/
    }),
/* 145 */
/***/ (function (module, exports) {

      module.exports = clone;
      /**
       * Creates a new vec3 initialized with values from an existing vector
       *
       * @param {vec3} a vector to clone
       * @returns {vec3} a new 3D vector
       */

      function clone(a) {
        var out = new Float32Array(3);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
      }

      /***/
    }),
/* 146 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = angle;

      var fromValues = __webpack_require__(69);

      var normalize = __webpack_require__(70);

      var dot = __webpack_require__(71);
      /**
       * Get the angle between two 3D vectors
       * @param {vec3} a The first operand
       * @param {vec3} b The second operand
       * @returns {Number} The angle in radians
       */


      function angle(a, b) {
        var tempA = fromValues(a[0], a[1], a[2]);
        var tempB = fromValues(b[0], b[1], b[2]);
        normalize(tempA, tempA);
        normalize(tempB, tempB);
        var cosine = dot(tempA, tempB);

        if (cosine > 1.0) {
          return 0;
        } else {
          return Math.acos(cosine);
        }
      }

      /***/
    }),
/* 147 */
/***/ (function (module, exports) {

      module.exports = copy;
      /**
       * Copy the values from one vec3 to another
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the source vector
       * @returns {vec3} out
       */

      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
      }

      /***/
    }),
/* 148 */
/***/ (function (module, exports) {

      module.exports = set;
      /**
       * Set the components of a vec3 to the given values
       *
       * @param {vec3} out the receiving vector
       * @param {Number} x X component
       * @param {Number} y Y component
       * @param {Number} z Z component
       * @returns {vec3} out
       */

      function set(out, x, y, z) {
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
      }

      /***/
    }),
/* 149 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = equals;

      var EPSILON = __webpack_require__(67);
      /**
       * Returns whether or not the vectors have approximately the same elements in the same position.
       *
       * @param {vec3} a The first vector.
       * @param {vec3} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
      }

      /***/
    }),
/* 150 */
/***/ (function (module, exports) {

      module.exports = exactEquals;
      /**
       * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
       *
       * @param {vec3} a The first vector.
       * @param {vec3} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */

      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
      }

      /***/
    }),
/* 151 */
/***/ (function (module, exports) {

      module.exports = add;
      /**
       * Adds two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */

      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        return out;
      }

      /***/
    }),
/* 152 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(72);

      /***/
    }),
/* 153 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(73);

      /***/
    }),
/* 154 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(74);

      /***/
    }),
/* 155 */
/***/ (function (module, exports) {

      module.exports = min;
      /**
       * Returns the minimum of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */

      function min(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        out[2] = Math.min(a[2], b[2]);
        return out;
      }

      /***/
    }),
/* 156 */
/***/ (function (module, exports) {

      module.exports = max;
      /**
       * Returns the maximum of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */

      function max(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        out[2] = Math.max(a[2], b[2]);
        return out;
      }

      /***/
    }),
/* 157 */
/***/ (function (module, exports) {

      module.exports = floor;
      /**
       * Math.floor the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to floor
       * @returns {vec3} out
       */

      function floor(out, a) {
        out[0] = Math.floor(a[0]);
        out[1] = Math.floor(a[1]);
        out[2] = Math.floor(a[2]);
        return out;
      }

      /***/
    }),
/* 158 */
/***/ (function (module, exports) {

      module.exports = ceil;
      /**
       * Math.ceil the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to ceil
       * @returns {vec3} out
       */

      function ceil(out, a) {
        out[0] = Math.ceil(a[0]);
        out[1] = Math.ceil(a[1]);
        out[2] = Math.ceil(a[2]);
        return out;
      }

      /***/
    }),
/* 159 */
/***/ (function (module, exports) {

      module.exports = round;
      /**
       * Math.round the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to round
       * @returns {vec3} out
       */

      function round(out, a) {
        out[0] = Math.round(a[0]);
        out[1] = Math.round(a[1]);
        out[2] = Math.round(a[2]);
        return out;
      }

      /***/
    }),
/* 160 */
/***/ (function (module, exports) {

      module.exports = scale;
      /**
       * Scales a vec3 by a scalar number
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to scale
       * @param {Number} b amount to scale the vector by
       * @returns {vec3} out
       */

      function scale(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        return out;
      }

      /***/
    }),
/* 161 */
/***/ (function (module, exports) {

      module.exports = scaleAndAdd;
      /**
       * Adds two vec3's after scaling the second operand by a scalar value
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {Number} scale the amount to scale b by before adding
       * @returns {vec3} out
       */

      function scaleAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        out[2] = a[2] + b[2] * scale;
        return out;
      }

      /***/
    }),
/* 162 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(75);

      /***/
    }),
/* 163 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(76);

      /***/
    }),
/* 164 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(77);

      /***/
    }),
/* 165 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(78);

      /***/
    }),
/* 166 */
/***/ (function (module, exports) {

      module.exports = negate;
      /**
       * Negates the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to negate
       * @returns {vec3} out
       */

      function negate(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        out[2] = -a[2];
        return out;
      }

      /***/
    }),
/* 167 */
/***/ (function (module, exports) {

      module.exports = inverse;
      /**
       * Returns the inverse of the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to invert
       * @returns {vec3} out
       */

      function inverse(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        out[2] = 1.0 / a[2];
        return out;
      }

      /***/
    }),
/* 168 */
/***/ (function (module, exports) {

      module.exports = cross;
      /**
       * Computes the cross product of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */

      function cross(out, a, b) {
        var ax = a[0],
          ay = a[1],
          az = a[2],
          bx = b[0],
          by = b[1],
          bz = b[2];
        out[0] = ay * bz - az * by;
        out[1] = az * bx - ax * bz;
        out[2] = ax * by - ay * bx;
        return out;
      }

      /***/
    }),
/* 169 */
/***/ (function (module, exports) {

      module.exports = lerp;
      /**
       * Performs a linear interpolation between two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {Number} t interpolation amount between the two inputs
       * @returns {vec3} out
       */

      function lerp(out, a, b, t) {
        var ax = a[0],
          ay = a[1],
          az = a[2];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        out[2] = az + t * (b[2] - az);
        return out;
      }

      /***/
    }),
/* 170 */
/***/ (function (module, exports) {

      module.exports = random;
      /**
       * Generates a random vector with the given scale
       *
       * @param {vec3} out the receiving vector
       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
       * @returns {vec3} out
       */

      function random(out, scale) {
        scale = scale || 1.0;
        var r = Math.random() * 2.0 * Math.PI;
        var z = Math.random() * 2.0 - 1.0;
        var zScale = Math.sqrt(1.0 - z * z) * scale;
        out[0] = Math.cos(r) * zScale;
        out[1] = Math.sin(r) * zScale;
        out[2] = z * scale;
        return out;
      }

      /***/
    }),
/* 171 */
/***/ (function (module, exports) {

      module.exports = transformMat4;
      /**
       * Transforms the vec3 with a mat4.
       * 4th vector component is implicitly '1'
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {mat4} m matrix to transform with
       * @returns {vec3} out
       */

      function transformMat4(out, a, m) {
        var x = a[0],
          y = a[1],
          z = a[2],
          w = m[3] * x + m[7] * y + m[11] * z + m[15];
        w = w || 1.0;
        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return out;
      }

      /***/
    }),
/* 172 */
/***/ (function (module, exports) {

      module.exports = transformMat3;
      /**
       * Transforms the vec3 with a mat3.
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {mat4} m the 3x3 matrix to transform with
       * @returns {vec3} out
       */

      function transformMat3(out, a, m) {
        var x = a[0],
          y = a[1],
          z = a[2];
        out[0] = x * m[0] + y * m[3] + z * m[6];
        out[1] = x * m[1] + y * m[4] + z * m[7];
        out[2] = x * m[2] + y * m[5] + z * m[8];
        return out;
      }

      /***/
    }),
/* 173 */
/***/ (function (module, exports) {

      module.exports = transformQuat;
      /**
       * Transforms the vec3 with a quat
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {quat} q quaternion to transform with
       * @returns {vec3} out
       */

      function transformQuat(out, a, q) {
        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
        var x = a[0],
          y = a[1],
          z = a[2],
          qx = q[0],
          qy = q[1],
          qz = q[2],
          qw = q[3],
          // calculate quat * vec
          ix = qw * x + qy * z - qz * y,
          iy = qw * y + qz * x - qx * z,
          iz = qw * z + qx * y - qy * x,
          iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return out;
      }

      /***/
    }),
/* 174 */
/***/ (function (module, exports) {

      module.exports = rotateX;
      /**
       * Rotate a 3D vector around the x-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */

      function rotateX(out, a, b, c) {
        var by = b[1];
        var bz = b[2]; // Translate point to the origin

        var py = a[1] - by;
        var pz = a[2] - bz;
        var sc = Math.sin(c);
        var cc = Math.cos(c); // perform rotation and translate to correct position

        out[0] = a[0];
        out[1] = by + py * cc - pz * sc;
        out[2] = bz + py * sc + pz * cc;
        return out;
      }

      /***/
    }),
/* 175 */
/***/ (function (module, exports) {

      module.exports = rotateY;
      /**
       * Rotate a 3D vector around the y-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */

      function rotateY(out, a, b, c) {
        var bx = b[0];
        var bz = b[2]; // translate point to the origin

        var px = a[0] - bx;
        var pz = a[2] - bz;
        var sc = Math.sin(c);
        var cc = Math.cos(c); // perform rotation and translate to correct position

        out[0] = bx + pz * sc + px * cc;
        out[1] = a[1];
        out[2] = bz + pz * cc - px * sc;
        return out;
      }

      /***/
    }),
/* 176 */
/***/ (function (module, exports) {

      module.exports = rotateZ;
      /**
       * Rotate a 3D vector around the z-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */

      function rotateZ(out, a, b, c) {
        var bx = b[0];
        var by = b[1]; //Translate point to the origin

        var px = a[0] - bx;
        var py = a[1] - by;
        var sc = Math.sin(c);
        var cc = Math.cos(c); // perform rotation and translate to correct position

        out[0] = bx + px * cc - py * sc;
        out[1] = by + px * sc + py * cc;
        out[2] = a[2];
        return out;
      }

      /***/
    }),
/* 177 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = forEach;

      var vec = __webpack_require__(68)();
      /**
       * Perform some operation over an array of vec3s.
       *
       * @param {Array} a the array of vectors to iterate over
       * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
       * @param {Number} offset Number of elements to skip at the beginning of the array
       * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
       * @param {Function} fn Function to call for each vector in the array
       * @param {Object} [arg] additional argument to pass to fn
       * @returns {Array} a
       * @function
       */


      function forEach(a, stride, offset, count, fn, arg) {
        var i, l;

        if (!stride) {
          stride = 3;
        }

        if (!offset) {
          offset = 0;
        }

        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }

        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
        }

        return a;
      }

      /***/
    }),
/* 178 */
/***/ (function (module, exports) {

      function _setPrototypeOf(o, p) {
        module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      module.exports = _setPrototypeOf;

      /***/
    }),
/* 179 */
/***/ (function (module, exports, __webpack_require__) {

      var Stack = __webpack_require__(180),
        assignMergeValue = __webpack_require__(82),
        baseFor = __webpack_require__(210),
        baseMergeDeep = __webpack_require__(212),
        isObject = __webpack_require__(13),
        keysIn = __webpack_require__(90),
        safeGet = __webpack_require__(88);
      /**
       * The base implementation of `_.merge` without support for multiple sources.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} [customizer] The function to customize merged values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */


      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }

        baseFor(source, function (srcValue, key) {
          stack || (stack = new Stack());

          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

            if (newValue === undefined) {
              newValue = srcValue;
            }

            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }

      module.exports = baseMerge;

      /***/
    }),
/* 180 */
/***/ (function (module, exports, __webpack_require__) {

      var ListCache = __webpack_require__(29),
        stackClear = __webpack_require__(186),
        stackDelete = __webpack_require__(187),
        stackGet = __webpack_require__(188),
        stackHas = __webpack_require__(189),
        stackSet = __webpack_require__(190);
      /**
       * Creates a stack cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */


      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      } // Add methods to `Stack`.


      Stack.prototype.clear = stackClear;
      Stack.prototype['delete'] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module.exports = Stack;

      /***/
    }),
/* 181 */
/***/ (function (module, exports) {

      /**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }

      module.exports = listCacheClear;

      /***/
    }),
/* 182 */
/***/ (function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(30);
      /** Used for built-in method references. */


      var arrayProto = Array.prototype;
      /** Built-in value references. */

      var splice = arrayProto.splice;
      /**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */

      function listCacheDelete(key) {
        var data = this.__data__,
          index = assocIndexOf(data, key);

        if (index < 0) {
          return false;
        }

        var lastIndex = data.length - 1;

        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }

        --this.size;
        return true;
      }

      module.exports = listCacheDelete;

      /***/
    }),
/* 183 */
/***/ (function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(30);
      /**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */


      function listCacheGet(key) {
        var data = this.__data__,
          index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
      }

      module.exports = listCacheGet;

      /***/
    }),
/* 184 */
/***/ (function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(30);
      /**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */


      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }

      module.exports = listCacheHas;

      /***/
    }),
/* 185 */
/***/ (function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(30);
      /**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */


      function listCacheSet(key, value) {
        var data = this.__data__,
          index = assocIndexOf(data, key);

        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }

        return this;
      }

      module.exports = listCacheSet;

      /***/
    }),
/* 186 */
/***/ (function (module, exports, __webpack_require__) {

      var ListCache = __webpack_require__(29);
      /**
       * Removes all key-value entries from the stack.
       *
       * @private
       * @name clear
       * @memberOf Stack
       */


      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }

      module.exports = stackClear;

      /***/
    }),
/* 187 */
/***/ (function (module, exports) {

      /**
       * Removes `key` and its value from the stack.
       *
       * @private
       * @name delete
       * @memberOf Stack
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function stackDelete(key) {
        var data = this.__data__,
          result = data['delete'](key);
        this.size = data.size;
        return result;
      }

      module.exports = stackDelete;

      /***/
    }),
/* 188 */
/***/ (function (module, exports) {

      /**
       * Gets the stack value for `key`.
       *
       * @private
       * @name get
       * @memberOf Stack
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function stackGet(key) {
        return this.__data__.get(key);
      }

      module.exports = stackGet;

      /***/
    }),
/* 189 */
/***/ (function (module, exports) {

      /**
       * Checks if a stack value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Stack
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function stackHas(key) {
        return this.__data__.has(key);
      }

      module.exports = stackHas;

      /***/
    }),
/* 190 */
/***/ (function (module, exports, __webpack_require__) {

      var ListCache = __webpack_require__(29),
        Map = __webpack_require__(79),
        MapCache = __webpack_require__(81);
      /** Used as the size to enable large array optimizations. */


      var LARGE_ARRAY_SIZE = 200;
      /**
       * Sets the stack `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Stack
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the stack cache instance.
       */

      function stackSet(key, value) {
        var data = this.__data__;

        if (data instanceof ListCache) {
          var pairs = data.__data__;

          if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }

          data = this.__data__ = new MapCache(pairs);
        }

        data.set(key, value);
        this.size = data.size;
        return this;
      }

      module.exports = stackSet;

      /***/
    }),
/* 191 */
/***/ (function (module, exports, __webpack_require__) {

      var isFunction = __webpack_require__(44),
        isMasked = __webpack_require__(194),
        isObject = __webpack_require__(13),
        toSource = __webpack_require__(196);
      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */


      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      /** Used to detect host constructors (Safari). */

      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      /** Used for built-in method references. */

      var funcProto = Function.prototype,
        objectProto = Object.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Used to detect if a method is native. */

      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
      /**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */

      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }

        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }

      module.exports = baseIsNative;

      /***/
    }),
/* 192 */
/***/ (function (module, exports, __webpack_require__) {

      var Symbol = __webpack_require__(32);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */

      var nativeObjectToString = objectProto.toString;
      /** Built-in value references. */

      var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */

      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) { }

        var result = nativeObjectToString.call(value);

        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }

        return result;
      }

      module.exports = getRawTag;

      /***/
    }),
/* 193 */
/***/ (function (module, exports) {

      /** Used for built-in method references. */
      var objectProto = Object.prototype;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */

      var nativeObjectToString = objectProto.toString;
      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */

      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

      module.exports = objectToString;

      /***/
    }),
/* 194 */
/***/ (function (module, exports, __webpack_require__) {

      var coreJsData = __webpack_require__(195);
      /** Used to detect methods masquerading as native. */


      var maskSrcKey = function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? 'Symbol(src)_1.' + uid : '';
      }();
      /**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */


      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }

      module.exports = isMasked;

      /***/
    }),
/* 195 */
/***/ (function (module, exports, __webpack_require__) {

      var root = __webpack_require__(20);
      /** Used to detect overreaching core-js shims. */


      var coreJsData = root['__core-js_shared__'];
      module.exports = coreJsData;

      /***/
    }),
/* 196 */
/***/ (function (module, exports) {

      /** Used for built-in method references. */
      var funcProto = Function.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */

      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) { }

          try {
            return func + '';
          } catch (e) { }
        }

        return '';
      }

      module.exports = toSource;

      /***/
    }),
/* 197 */
/***/ (function (module, exports) {

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }

      module.exports = getValue;

      /***/
    }),
/* 198 */
/***/ (function (module, exports, __webpack_require__) {

      var Hash = __webpack_require__(199),
        ListCache = __webpack_require__(29),
        Map = __webpack_require__(79);
      /**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */


      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          'hash': new Hash(),
          'map': new (Map || ListCache)(),
          'string': new Hash()
        };
      }

      module.exports = mapCacheClear;

      /***/
    }),
/* 199 */
/***/ (function (module, exports, __webpack_require__) {

      var hashClear = __webpack_require__(200),
        hashDelete = __webpack_require__(201),
        hashGet = __webpack_require__(202),
        hashHas = __webpack_require__(203),
        hashSet = __webpack_require__(204);
      /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */


      function Hash(entries) {
        var index = -1,
          length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      } // Add methods to `Hash`.


      Hash.prototype.clear = hashClear;
      Hash.prototype['delete'] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;

      /***/
    }),
/* 200 */
/***/ (function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(33);
      /**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */


      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }

      module.exports = hashClear;

      /***/
    }),
/* 201 */
/***/ (function (module, exports) {

      /**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }

      module.exports = hashDelete;

      /***/
    }),
/* 202 */
/***/ (function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(33);
      /** Used to stand-in for `undefined` hash values. */


      var HASH_UNDEFINED = '__lodash_hash_undefined__';
      /** Used for built-in method references. */

      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */

      function hashGet(key) {
        var data = this.__data__;

        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined : result;
        }

        return hasOwnProperty.call(data, key) ? data[key] : undefined;
      }

      module.exports = hashGet;

      /***/
    }),
/* 203 */
/***/ (function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(33);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */

      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
      }

      module.exports = hashHas;

      /***/
    }),
/* 204 */
/***/ (function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(33);
      /** Used to stand-in for `undefined` hash values. */


      var HASH_UNDEFINED = '__lodash_hash_undefined__';
      /**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */

      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
        return this;
      }

      module.exports = hashSet;

      /***/
    }),
/* 205 */
/***/ (function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(34);
      /**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */


      function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
      }

      module.exports = mapCacheDelete;

      /***/
    }),
/* 206 */
/***/ (function (module, exports) {

      /**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */
      function isKeyable(value) {
        var type = typeof value;
        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
      }

      module.exports = isKeyable;

      /***/
    }),
/* 207 */
/***/ (function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(34);
      /**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */


      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }

      module.exports = mapCacheGet;

      /***/
    }),
/* 208 */
/***/ (function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(34);
      /**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */


      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }

      module.exports = mapCacheHas;

      /***/
    }),
/* 209 */
/***/ (function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(34);
      /**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */


      function mapCacheSet(key, value) {
        var data = getMapData(this, key),
          size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }

      module.exports = mapCacheSet;

      /***/
    }),
/* 210 */
/***/ (function (module, exports, __webpack_require__) {

      var createBaseFor = __webpack_require__(211);
      /**
       * The base implementation of `baseForOwn` which iterates over `object`
       * properties returned by `keysFunc` and invokes `iteratee` for each property.
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */


      var baseFor = createBaseFor();
      module.exports = baseFor;

      /***/
    }),
/* 211 */
/***/ (function (module, exports) {

      /**
       * Creates a base function for methods like `_.forIn` and `_.forOwn`.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */
      function createBaseFor(fromRight) {
        return function (object, iteratee, keysFunc) {
          var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

          while (length--) {
            var key = props[fromRight ? length : ++index];

            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }

          return object;
        };
      }

      module.exports = createBaseFor;

      /***/
    }),
/* 212 */
/***/ (function (module, exports, __webpack_require__) {

      var assignMergeValue = __webpack_require__(82),
        cloneBuffer = __webpack_require__(213),
        cloneTypedArray = __webpack_require__(214),
        copyArray = __webpack_require__(217),
        initCloneObject = __webpack_require__(218),
        isArguments = __webpack_require__(35),
        isArray = __webpack_require__(14),
        isArrayLikeObject = __webpack_require__(222),
        isBuffer = __webpack_require__(86),
        isFunction = __webpack_require__(44),
        isObject = __webpack_require__(13),
        isPlainObject = __webpack_require__(224),
        isTypedArray = __webpack_require__(87),
        safeGet = __webpack_require__(88),
        toPlainObject = __webpack_require__(228);
      /**
       * A specialized version of `baseMerge` for arrays and objects which performs
       * deep merges and tracks traversed objects enabling objects with circular
       * references to be merged.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {string} key The key of the value to merge.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} mergeFunc The function to merge values.
       * @param {Function} [customizer] The function to customize assigned values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */


      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }

        var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
        var isCommon = newValue === undefined;

        if (isCommon) {
          var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;

          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;

            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }

        if (isCommon) {
          // Recursively merge objects and arrays (susceptible to call stack limits).
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack['delete'](srcValue);
        }

        assignMergeValue(object, key, newValue);
      }

      module.exports = baseMergeDeep;

      /***/
    }),
/* 213 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (module) {
        var root = __webpack_require__(20);
        /** Detect free variable `exports`. */


        var freeExports = true && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Built-in value references. */

        var Buffer = moduleExports ? root.Buffer : undefined,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */

        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }

          var length = buffer.length,
            result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result);
          return result;
        }

        module.exports = cloneBuffer;
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(46)(module)))

      /***/
    }),
/* 214 */
/***/ (function (module, exports, __webpack_require__) {

      var cloneArrayBuffer = __webpack_require__(215);
      /**
       * Creates a clone of `typedArray`.
       *
       * @private
       * @param {Object} typedArray The typed array to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned typed array.
       */


      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }

      module.exports = cloneTypedArray;

      /***/
    }),
/* 215 */
/***/ (function (module, exports, __webpack_require__) {

      var Uint8Array = __webpack_require__(216);
      /**
       * Creates a clone of `arrayBuffer`.
       *
       * @private
       * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */


      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
      }

      module.exports = cloneArrayBuffer;

      /***/
    }),
/* 216 */
/***/ (function (module, exports, __webpack_require__) {

      var root = __webpack_require__(20);
      /** Built-in value references. */


      var Uint8Array = root.Uint8Array;
      module.exports = Uint8Array;

      /***/
    }),
/* 217 */
/***/ (function (module, exports) {

      /**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */
      function copyArray(source, array) {
        var index = -1,
          length = source.length;
        array || (array = Array(length));

        while (++index < length) {
          array[index] = source[index];
        }

        return array;
      }

      module.exports = copyArray;

      /***/
    }),
/* 218 */
/***/ (function (module, exports, __webpack_require__) {

      var baseCreate = __webpack_require__(219),
        getPrototype = __webpack_require__(84),
        isPrototype = __webpack_require__(85);
      /**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */


      function initCloneObject(object) {
        return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }

      module.exports = initCloneObject;

      /***/
    }),
/* 219 */
/***/ (function (module, exports, __webpack_require__) {

      var isObject = __webpack_require__(13);
      /** Built-in value references. */


      var objectCreate = Object.create;
      /**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} proto The object to inherit from.
       * @returns {Object} Returns the new object.
       */

      var baseCreate = function () {
        function object() { }

        return function (proto) {
          if (!isObject(proto)) {
            return {};
          }

          if (objectCreate) {
            return objectCreate(proto);
          }

          object.prototype = proto;
          var result = new object();
          object.prototype = undefined;
          return result;
        };
      }();

      module.exports = baseCreate;

      /***/
    }),
/* 220 */
/***/ (function (module, exports) {

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg));
        };
      }

      module.exports = overArg;

      /***/
    }),
/* 221 */
/***/ (function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(25),
        isObjectLike = __webpack_require__(21);
      /** `Object#toString` result references. */


      var argsTag = '[object Arguments]';
      /**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */

      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }

      module.exports = baseIsArguments;

      /***/
    }),
/* 222 */
/***/ (function (module, exports, __webpack_require__) {

      var isArrayLike = __webpack_require__(47),
        isObjectLike = __webpack_require__(21);
      /**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */


      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }

      module.exports = isArrayLikeObject;

      /***/
    }),
/* 223 */
/***/ (function (module, exports) {

      /**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */
      function stubFalse() {
        return false;
      }

      module.exports = stubFalse;

      /***/
    }),
/* 224 */
/***/ (function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(25),
        getPrototype = __webpack_require__(84),
        isObjectLike = __webpack_require__(21);
      /** `Object#toString` result references. */


      var objectTag = '[object Object]';
      /** Used for built-in method references. */

      var funcProto = Function.prototype,
        objectProto = Object.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Used to infer the `Object` constructor. */

      var objectCtorString = funcToString.call(Object);
      /**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */

      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }

        var proto = getPrototype(value);

        if (proto === null) {
          return true;
        }

        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }

      module.exports = isPlainObject;

      /***/
    }),
/* 225 */
/***/ (function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(25),
        isLength = __webpack_require__(48),
        isObjectLike = __webpack_require__(21);
      /** `Object#toString` result references. */


      var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
      /** Used to identify `toStringTag` values of typed arrays. */

      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      /**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */

      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }

      module.exports = baseIsTypedArray;

      /***/
    }),
/* 226 */
/***/ (function (module, exports) {

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      }

      module.exports = baseUnary;

      /***/
    }),
/* 227 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (module) {
        var freeGlobal = __webpack_require__(80);
        /** Detect free variable `exports`. */


        var freeExports = true && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Detect free variable `process` from Node.js. */

        var freeProcess = moduleExports && freeGlobal.process;
        /** Used to access faster Node.js helpers. */

        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;

            if (types) {
              return types;
            } // Legacy `process.binding('util')` for Node.js < 10.


            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) { }
        }();

        module.exports = nodeUtil;
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(46)(module)))

      /***/
    }),
/* 228 */
/***/ (function (module, exports, __webpack_require__) {

      var copyObject = __webpack_require__(229),
        keysIn = __webpack_require__(90);
      /**
       * Converts `value` to a plain object flattening inherited enumerable string
       * keyed properties of `value` to own properties of the plain object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Object} Returns the converted plain object.
       * @example
       *
       * function Foo() {
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.assign({ 'a': 1 }, new Foo);
       * // => { 'a': 1, 'b': 2 }
       *
       * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
       * // => { 'a': 1, 'b': 2, 'c': 3 }
       */


      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }

      module.exports = toPlainObject;

      /***/
    }),
/* 229 */
/***/ (function (module, exports, __webpack_require__) {

      var assignValue = __webpack_require__(89),
        baseAssignValue = __webpack_require__(45);
      /**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */


      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1,
          length = props.length;

        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

          if (newValue === undefined) {
            newValue = source[key];
          }

          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }

        return object;
      }

      module.exports = copyObject;

      /***/
    }),
/* 230 */
/***/ (function (module, exports, __webpack_require__) {

      var baseTimes = __webpack_require__(231),
        isArguments = __webpack_require__(35),
        isArray = __webpack_require__(14),
        isBuffer = __webpack_require__(86),
        isIndex = __webpack_require__(36),
        isTypedArray = __webpack_require__(87);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */

      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
            key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
            isIndex(key, length)))) {
            result.push(key);
          }
        }

        return result;
      }

      module.exports = arrayLikeKeys;

      /***/
    }),
/* 231 */
/***/ (function (module, exports) {

      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
          result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }

        return result;
      }

      module.exports = baseTimes;

      /***/
    }),
/* 232 */
/***/ (function (module, exports, __webpack_require__) {

      var isObject = __webpack_require__(13),
        isPrototype = __webpack_require__(85),
        nativeKeysIn = __webpack_require__(233);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */

      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }

        var isProto = isPrototype(object),
          result = [];

        for (var key in object) {
          if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }

        return result;
      }

      module.exports = baseKeysIn;

      /***/
    }),
/* 233 */
/***/ (function (module, exports) {

      /**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */
      function nativeKeysIn(object) {
        var result = [];

        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }

        return result;
      }

      module.exports = nativeKeysIn;

      /***/
    }),
/* 234 */
/***/ (function (module, exports, __webpack_require__) {

      var baseRest = __webpack_require__(235),
        isIterateeCall = __webpack_require__(240);
      /**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */


      function createAssigner(assigner) {
        return baseRest(function (object, sources) {
          var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;
          customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
          }

          object = Object(object);

          while (++index < length) {
            var source = sources[index];

            if (source) {
              assigner(object, source, index, customizer);
            }
          }

          return object;
        });
      }

      module.exports = createAssigner;

      /***/
    }),
/* 235 */
/***/ (function (module, exports, __webpack_require__) {

      var identity = __webpack_require__(91),
        overRest = __webpack_require__(92),
        setToString = __webpack_require__(93);
      /**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */


      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + '');
      }

      module.exports = baseRest;

      /***/
    }),
/* 236 */
/***/ (function (module, exports) {

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);

          case 1:
            return func.call(thisArg, args[0]);

          case 2:
            return func.call(thisArg, args[0], args[1]);

          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }

        return func.apply(thisArg, args);
      }

      module.exports = apply;

      /***/
    }),
/* 237 */
/***/ (function (module, exports, __webpack_require__) {

      var constant = __webpack_require__(238),
        defineProperty = __webpack_require__(83),
        identity = __webpack_require__(91);
      /**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */


      var baseSetToString = !defineProperty ? identity : function (func, string) {
        return defineProperty(func, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': constant(string),
          'writable': true
        });
      };
      module.exports = baseSetToString;

      /***/
    }),
/* 238 */
/***/ (function (module, exports) {

      /**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */
      function constant(value) {
        return function () {
          return value;
        };
      }

      module.exports = constant;

      /***/
    }),
/* 239 */
/***/ (function (module, exports) {

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
        HOT_SPAN = 16;
      /* Built-in method references for those with the same name as other `lodash` methods. */

      var nativeNow = Date.now;
      /**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */

      function shortOut(func) {
        var count = 0,
          lastCalled = 0;
        return function () {
          var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;

          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }

          return func.apply(undefined, arguments);
        };
      }

      module.exports = shortOut;

      /***/
    }),
/* 240 */
/***/ (function (module, exports, __webpack_require__) {

      var eq = __webpack_require__(31),
        isArrayLike = __webpack_require__(47),
        isIndex = __webpack_require__(36),
        isObject = __webpack_require__(13);
      /**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */


      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }

        var type = typeof index;

        if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
          return eq(object[index], value);
        }

        return false;
      }

      module.exports = isIterateeCall;

      /***/
    }),
/* 241 */
/***/ (function (module, exports, __webpack_require__) {

      var arrayLikeToArray = __webpack_require__(57);

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return arrayLikeToArray(arr);
      }

      module.exports = _arrayWithoutHoles;

      /***/
    }),
/* 242 */
/***/ (function (module, exports) {

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }

      module.exports = _iterableToArray;

      /***/
    }),
/* 243 */
/***/ (function (module, exports) {

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      module.exports = _nonIterableSpread;

      /***/
    }),
/* 244 */
/***/ (function (module, exports, __webpack_require__) {

      var getPrototypeOf = __webpack_require__(2);

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      module.exports = _superPropBase;

      /***/
    }),
/* 245 */
/***/ (function (module, exports, __webpack_require__) {

      /**
       * Copyright (c) 2014-present, Facebook, Inc.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var runtime = function (exports) {
        "use strict";

        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined; // More compressible than void 0.

        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

        function wrap(innerFn, outerFn, self, tryLocsList) {
          // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
          // .throw, and .return methods.

          generator._invoke = makeInvokeMethod(innerFn, self, context);
          return generator;
        }

        exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
        // record like context.tryEntries[i].completion. This interface could
        // have been (and was previously) designed to take a closure to be
        // invoked without arguments, but in all the cases we care about we
        // already have an existing method we want to call, so there's no need
        // to create a new function object. We can even get away with assuming
        // the method takes exactly one argument, since that happens to be true
        // in every case, so we don't have to touch the arguments object. The
        // only additional allocation required is the completion record, which
        // has a stable shape and so hopefully should be cheap to allocate.

        function tryCatch(fn, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }

        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
        // breaking out of the dispatch switch statement.

        var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
        // .constructor.prototype properties for functions that return Generator
        // objects. For full spec compliance, you may wish to configure your
        // minifier not to mangle the names of these two functions.

        function Generator() { }

        function GeneratorFunction() { }

        function GeneratorFunctionPrototype() { } // This is a polyfill for %IteratorPrototype% for environments that
        // don't natively support it.


        var IteratorPrototype = {};

        IteratorPrototype[iteratorSymbol] = function () {
          return this;
        };

        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          // This environment has a native %IteratorPrototype%; use it instead
          // of the polyfill.
          IteratorPrototype = NativeIteratorPrototype;
        }

        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
        // Iterator interface in terms of a single ._invoke method.

        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function (method) {
            prototype[method] = function (arg) {
              return this._invoke(method, arg);
            };
          });
        }

        exports.isGeneratorFunction = function (genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };

        exports.mark = function (genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;

            if (!(toStringTagSymbol in genFun)) {
              genFun[toStringTagSymbol] = "GeneratorFunction";
            }
          }

          genFun.prototype = Object.create(Gp);
          return genFun;
        }; // Within the body of any async function, `await x` is transformed to
        // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
        // `hasOwn.call(value, "__await")` to determine if the yielded value is
        // meant to be awaited.


        exports.awrap = function (arg) {
          return {
            __await: arg
          };
        };

        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);

            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;

              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function (value) {
                  invoke("next", value, resolve, reject);
                }, function (err) {
                  invoke("throw", err, resolve, reject);
                });
              }

              return PromiseImpl.resolve(value).then(function (unwrapped) {
                // When a yielded Promise is resolved, its final value becomes
                // the .value of the Promise<{value,done}> result for the
                // current iteration.
                result.value = unwrapped;
                resolve(result);
              }, function (error) {
                // If a rejected Promise was yielded, throw the rejection back
                // into the async generator function so it can be handled there.
                return invoke("throw", error, resolve, reject);
              });
            }
          }

          var previousPromise;

          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }

            return previousPromise = // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
                // invocations of the iterator.
                callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          } // Define the unified helper method that is used to implement .next,
          // .throw, and .return (see defineIteratorMethods).


          this._invoke = enqueue;
        }

        defineIteratorMethods(AsyncIterator.prototype);

        AsyncIterator.prototype[asyncIteratorSymbol] = function () {
          return this;
        };

        exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
        // AsyncIterator objects; they just return a Promise for the value of
        // the final result produced by the iterator.

        exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0) PromiseImpl = Promise;
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
          return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
            : iter.next().then(function (result) {
              return result.done ? result.value : iter.next();
            });
        };

        function makeInvokeMethod(innerFn, self, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }

            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              } // Be forgiving, per 25.3.3.3.3 of the spec:
              // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


              return doneResult();
            }

            context.method = method;
            context.arg = arg;

            while (true) {
              var delegate = context.delegate;

              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);

                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }

              if (context.method === "next") {
                // Setting context._sent for legacy support of Babel's
                // function.sent implementation.
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }

                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }

              state = GenStateExecuting;
              var record = tryCatch(innerFn, self, context);

              if (record.type === "normal") {
                // If an exception is thrown from innerFn, we leave state ===
                // GenStateExecuting and loop back for another invocation.
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;

                if (record.arg === ContinueSentinel) {
                  continue;
                }

                return {
                  value: record.arg,
                  done: context.done
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted; // Dispatch the exception by looping back around to the
                // context.dispatchException(context.arg) call above.

                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        } // Call delegate.iterator[context.method](context.arg) and handle the
        // result, either by returning a { value, done } result from the
        // delegate iterator, or by modifying context.method and context.arg,
        // setting context.delegate to null, and returning the ContinueSentinel.


        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];

          if (method === undefined) {
            // A .throw or .return when the delegate iterator has no .throw
            // method always terminates the yield* loop.
            context.delegate = null;

            if (context.method === "throw") {
              // Note: ["return"] must be used for ES3 parsing compatibility.
              if (delegate.iterator["return"]) {
                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                context.method = "return";
                context.arg = undefined;
                maybeInvokeDelegate(delegate, context);

                if (context.method === "throw") {
                  // If maybeInvokeDelegate(context) changed context.method from
                  // "return" to "throw", let that override the TypeError below.
                  return ContinueSentinel;
                }
              }

              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }

            return ContinueSentinel;
          }

          var record = tryCatch(method, delegate.iterator, context.arg);

          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }

          var info = record.arg;

          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }

          if (info.done) {
            // Assign the result of the finished delegate to the temporary
            // variable specified by delegate.resultName (see delegateYield).
            context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

            context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
            // exception, let the outer generator proceed normally. If
            // context.method was "next", forget context.arg since it has been
            // "consumed" by the delegate iterator. If context.method was
            // "return", allow the original .return call to continue in the
            // outer generator.

            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined;
            }
          } else {
            // Re-yield the result returned by the delegate method.
            return info;
          } // The delegate iterator is finished, so forget it and continue with
          // the outer generator.


          context.delegate = null;
          return ContinueSentinel;
        } // Define Generator.prototype.{next,throw,return} in terms of the
        // unified ._invoke helper method.


        defineIteratorMethods(Gp);
        Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
        // @@iterator function is called on it. Some browsers' implementations of the
        // iterator prototype chain incorrectly implement this, causing the Generator
        // object to not be returned from this call. This ensures that doesn't happen.
        // See https://github.com/facebook/regenerator/issues/274 for more details.

        Gp[iteratorSymbol] = function () {
          return this;
        };

        Gp.toString = function () {
          return "[object Generator]";
        };

        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };

          if (1 in locs) {
            entry.catchLoc = locs[1];
          }

          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }

          this.tryEntries.push(entry);
        }

        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }

        function Context(tryLocsList) {
          // The root entry object (effectively a try statement without a catch
          // or a finally block) gives us a place to store values thrown from
          // locations where there is no enclosing try statement.
          this.tryEntries = [{
            tryLoc: "root"
          }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }

        exports.keys = function (object) {
          var keys = [];

          for (var key in object) {
            keys.push(key);
          }

          keys.reverse(); // Rather than returning an object with a next method, we keep
          // things simple and return the next function itself.

          return function next() {
            while (keys.length) {
              var key = keys.pop();

              if (key in object) {
                next.value = key;
                next.done = false;
                return next;
              }
            } // To avoid creating an additional object, we just hang the .value
            // and .done properties off the next function object itself. This
            // also ensures that the minifier will not anonymize the function.


            next.done = true;
            return next;
          };
        };

        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];

            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }

            if (typeof iterable.next === "function") {
              return iterable;
            }

            if (!isNaN(iterable.length)) {
              var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }

                  next.value = undefined;
                  next.done = true;
                  return next;
                };

              return next.next = next;
            }
          } // Return an iterator with no values.


          return {
            next: doneResult
          };
        }

        exports.values = values;

        function doneResult() {
          return {
            value: undefined,
            done: true
          };
        }

        Context.prototype = {
          constructor: Context,
          reset: function (skipTempReset) {
            this.prev = 0;
            this.next = 0; // Resetting context._sent for legacy support of Babel's
            // function.sent implementation.

            this.sent = this._sent = undefined;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined;
            this.tryEntries.forEach(resetTryEntry);

            if (!skipTempReset) {
              for (var name in this) {
                // Not sure about the optimal order of these conditions:
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;

            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }

            return this.rval;
          },
          dispatchException: function (exception) {
            if (this.done) {
              throw exception;
            }

            var context = this;

            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;

              if (caught) {
                // If the dispatched exception was caught by a catch block,
                // then let that catch block handle the exception normally.
                context.method = "next";
                context.arg = undefined;
              }

              return !!caught;
            }

            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;

              if (entry.tryLoc === "root") {
                // Exception thrown outside of any try block that could handle
                // it, so set the completion value of the entire function to
                // throw the exception.
                return handle("end");
              }

              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");

                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function (type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];

              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }

            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              // Ignore the finally entry if control is not jumping to a
              // location outside the try/catch block.
              finallyEntry = null;
            }

            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;

            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }

            return this.complete(record);
          },
          complete: function (record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }

            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }

            return ContinueSentinel;
          },
          finish: function (finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];

              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function (tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];

              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;

                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }

                return thrown;
              }
            } // The context.catch method must only be called with a location
            // argument that corresponds to a known catch block.


            throw new Error("illegal catch attempt");
          },
          delegateYield: function (iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName: resultName,
              nextLoc: nextLoc
            };

            if (this.method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              this.arg = undefined;
            }

            return ContinueSentinel;
          }
        }; // Regardless of whether this script is executing as a CommonJS module
        // or not, return the runtime object so that we can declare the variable
        // regeneratorRuntime in the outer scope, which allows this module to be
        // injected easily by `bin/regenerator --include-runtime script.js`.

        return exports;
      }( // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        true ? module.exports : undefined);

      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        // This module should not be running in strict mode, so the above
        // assignment should always work unless something is misconfigured. Just
        // in case runtime.js accidentally runs in strict mode, we can escape
        // strict mode using a global Function call. This could conceivably fail
        // if a Content Security Policy forbids using Function, but in that case
        // the proper solution is to fix the accidental strict mode problem. If
        // you've misconfigured your bundler to force strict mode and applied a
        // CSP to forbid Function, and you're not willing to fix either of those
        // problems, please detail your unique predicament in a GitHub issue.
        Function("r", "regeneratorRuntime = r")(runtime);
      }

      /***/
    }),
/* 246 */
/***/ (function (module, exports, __webpack_require__) {

      var basePickBy = __webpack_require__(247),
        hasIn = __webpack_require__(257);
      /**
       * The base implementation of `_.pick` without support for individual
       * property identifiers.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @returns {Object} Returns the new object.
       */


      function basePick(object, paths) {
        return basePickBy(object, paths, function (value, path) {
          return hasIn(object, path);
        });
      }

      module.exports = basePick;

      /***/
    }),
/* 247 */
/***/ (function (module, exports, __webpack_require__) {

      var baseGet = __webpack_require__(248),
        baseSet = __webpack_require__(256),
        castPath = __webpack_require__(37);
      /**
       * The base implementation of  `_.pickBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @param {Function} predicate The function invoked per property.
       * @returns {Object} Returns the new object.
       */


      function basePickBy(object, paths, predicate) {
        var index = -1,
          length = paths.length,
          result = {};

        while (++index < length) {
          var path = paths[index],
            value = baseGet(object, path);

          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }

        return result;
      }

      module.exports = basePickBy;

      /***/
    }),
/* 248 */
/***/ (function (module, exports, __webpack_require__) {

      var castPath = __webpack_require__(37),
        toKey = __webpack_require__(50);
      /**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */


      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0,
          length = path.length;

        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }

        return index && index == length ? object : undefined;
      }

      module.exports = baseGet;

      /***/
    }),
/* 249 */
/***/ (function (module, exports, __webpack_require__) {

      var isArray = __webpack_require__(14),
        isSymbol = __webpack_require__(49);
      /** Used to match property names within property paths. */


      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;
      /**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */

      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }

        var type = typeof value;

        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
          return true;
        }

        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }

      module.exports = isKey;

      /***/
    }),
/* 250 */
/***/ (function (module, exports, __webpack_require__) {

      var memoizeCapped = __webpack_require__(251);
      /** Used to match property names within property paths. */


      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      /** Used to match backslashes in property paths. */

      var reEscapeChar = /\\(\\)?/g;
      /**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */

      var stringToPath = memoizeCapped(function (string) {
        var result = [];

        if (string.charCodeAt(0) === 46
          /* . */
        ) {
          result.push('');
        }

        string.replace(rePropName, function (match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
        });
        return result;
      });
      module.exports = stringToPath;

      /***/
    }),
/* 251 */
/***/ (function (module, exports, __webpack_require__) {

      var memoize = __webpack_require__(252);
      /** Used as the maximum memoize cache size. */


      var MAX_MEMOIZE_SIZE = 500;
      /**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */

      function memoizeCapped(func) {
        var result = memoize(func, function (key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }

          return key;
        });
        var cache = result.cache;
        return result;
      }

      module.exports = memoizeCapped;

      /***/
    }),
/* 252 */
/***/ (function (module, exports, __webpack_require__) {

      var MapCache = __webpack_require__(81);
      /** Error message constants. */


      var FUNC_ERROR_TEXT = 'Expected a function';
      /**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */

      function memoize(func, resolver) {
        if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        var memoized = function () {
          var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

          if (cache.has(key)) {
            return cache.get(key);
          }

          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };

        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      } // Expose `MapCache`.


      memoize.Cache = MapCache;
      module.exports = memoize;

      /***/
    }),
/* 253 */
/***/ (function (module, exports, __webpack_require__) {

      var baseToString = __webpack_require__(254);
      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */


      function toString(value) {
        return value == null ? '' : baseToString(value);
      }

      module.exports = toString;

      /***/
    }),
/* 254 */
/***/ (function (module, exports, __webpack_require__) {

      var Symbol = __webpack_require__(32),
        arrayMap = __webpack_require__(255),
        isArray = __webpack_require__(14),
        isSymbol = __webpack_require__(49);
      /** Used as references for various `Number` constants. */


      var INFINITY = 1 / 0;
      /** Used to convert symbols to primitives and strings. */

      var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;
      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */

      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
          return value;
        }

        if (isArray(value)) {
          // Recursively convert values (susceptible to call stack limits).
          return arrayMap(value, baseToString) + '';
        }

        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : '';
        }

        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }

      module.exports = baseToString;

      /***/
    }),
/* 255 */
/***/ (function (module, exports) {

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }

        return result;
      }

      module.exports = arrayMap;

      /***/
    }),
/* 256 */
/***/ (function (module, exports, __webpack_require__) {

      var assignValue = __webpack_require__(89),
        castPath = __webpack_require__(37),
        isIndex = __webpack_require__(36),
        isObject = __webpack_require__(13),
        toKey = __webpack_require__(50);
      /**
       * The base implementation of `_.set`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */


      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }

        path = castPath(path, object);
        var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

        while (nested != null && ++index < length) {
          var key = toKey(path[index]),
            newValue = value;

          if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            return object;
          }

          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined;

            if (newValue === undefined) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }

          assignValue(nested, key, newValue);
          nested = nested[key];
        }

        return object;
      }

      module.exports = baseSet;

      /***/
    }),
/* 257 */
/***/ (function (module, exports, __webpack_require__) {

      var baseHasIn = __webpack_require__(258),
        hasPath = __webpack_require__(259);
      /**
       * Checks if `path` is a direct or inherited property of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.hasIn(object, 'a');
       * // => true
       *
       * _.hasIn(object, 'a.b');
       * // => true
       *
       * _.hasIn(object, ['a', 'b']);
       * // => true
       *
       * _.hasIn(object, 'b');
       * // => false
       */


      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }

      module.exports = hasIn;

      /***/
    }),
/* 258 */
/***/ (function (module, exports) {

      /**
       * The base implementation of `_.hasIn` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }

      module.exports = baseHasIn;

      /***/
    }),
/* 259 */
/***/ (function (module, exports, __webpack_require__) {

      var castPath = __webpack_require__(37),
        isArguments = __webpack_require__(35),
        isArray = __webpack_require__(14),
        isIndex = __webpack_require__(36),
        isLength = __webpack_require__(48),
        toKey = __webpack_require__(50);
      /**
       * Checks if `path` exists on `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @param {Function} hasFunc The function to check properties.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       */


      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1,
          length = path.length,
          result = false;

        while (++index < length) {
          var key = toKey(path[index]);

          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }

          object = object[key];
        }

        if (result || ++index != length) {
          return result;
        }

        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }

      module.exports = hasPath;

      /***/
    }),
/* 260 */
/***/ (function (module, exports, __webpack_require__) {

      var flatten = __webpack_require__(261),
        overRest = __webpack_require__(92),
        setToString = __webpack_require__(93);
      /**
       * A specialized version of `baseRest` which flattens the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */


      function flatRest(func) {
        return setToString(overRest(func, undefined, flatten), func + '');
      }

      module.exports = flatRest;

      /***/
    }),
/* 261 */
/***/ (function (module, exports, __webpack_require__) {

      var baseFlatten = __webpack_require__(262);
      /**
       * Flattens `array` a single level deep.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, [3, [4]], 5]]);
       * // => [1, 2, [3, [4]], 5]
       */


      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }

      module.exports = flatten;

      /***/
    }),
/* 262 */
/***/ (function (module, exports, __webpack_require__) {

      var arrayPush = __webpack_require__(263),
        isFlattenable = __webpack_require__(264);
      /**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */


      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1,
          length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);

        while (++index < length) {
          var value = array[index];

          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              // Recursively flatten arrays (susceptible to call stack limits).
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }

        return result;
      }

      module.exports = baseFlatten;

      /***/
    }),
/* 263 */
/***/ (function (module, exports) {

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
          length = values.length,
          offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }

        return array;
      }

      module.exports = arrayPush;

      /***/
    }),
/* 264 */
/***/ (function (module, exports, __webpack_require__) {

      var Symbol = __webpack_require__(32),
        isArguments = __webpack_require__(35),
        isArray = __webpack_require__(14);
      /** Built-in value references. */


      var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
      /**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */

      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }

      module.exports = isFlattenable;

      /***/
    }),
/* 265 */
/***/ (function (module, exports) {

      module.exports = determinant;
      /**
       * Calculates the determinant of a mat2
       *
       * @alias mat2.determinant
       * @param {mat2} a the source matrix
       * @returns {Number} determinant of a
       */

      function determinant(a) {
        return a[0] * a[3] - a[2] * a[1];
      }

      /***/
    }),
/* 266 */
/***/ (function (module, exports) {

      module.exports = transpose;
      /**
       * Transpose the values of a mat2
       *
       * @alias mat2.transpose
       * @param {mat2} out the receiving matrix
       * @param {mat2} a the source matrix
       * @returns {mat2} out
       */

      function transpose(out, a) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (out === a) {
          var a1 = a[1];
          out[1] = a[2];
          out[2] = a1;
        } else {
          out[0] = a[0];
          out[1] = a[2];
          out[2] = a[1];
          out[3] = a[3];
        }

        return out;
      }

      /***/
    }),
/* 267 */
/***/ (function (module, exports) {

      module.exports = multiply;
      /**
       * Multiplies two mat2's
       *
       * @alias mat2.multiply
       * @param {mat2} out the receiving matrix
       * @param {mat2} a the first operand
       * @param {mat2} b the second operand
       * @returns {mat2} out
       */

      function multiply(out, a, b) {
        var a0 = a[0],
          a1 = a[1],
          a2 = a[2],
          a3 = a[3];
        var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
        out[0] = a0 * b0 + a2 * b1;
        out[1] = a1 * b0 + a3 * b1;
        out[2] = a0 * b2 + a2 * b3;
        out[3] = a1 * b2 + a3 * b3;
        return out;
      }

      /***/
    }),
/* 268 */
/***/ (function (module, exports) {

      module.exports = identity;
      /**
       * Set a mat2 to the identity matrix
       *
       * @alias mat2.identity
       * @param {mat2} out the receiving matrix
       * @returns {mat2} out
       */

      function identity(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }

      /***/
    }),
/* 269 */
/***/ (function (module, exports) {

      module.exports = adjoint;
      /**
       * Calculates the adjugate of a mat2
       *
       * @alias mat2.adjoint
       * @param {mat2} out the receiving matrix
       * @param {mat2} a the source matrix
       * @returns {mat2} out
       */

      function adjoint(out, a) {
        // Caching this value is nessecary if out == a
        var a0 = a[0];
        out[0] = a[3];
        out[1] = -a[1];
        out[2] = -a[2];
        out[3] = a0;
        return out;
      }

      /***/
    }),
/* 270 */
/***/ (function (module, exports) {

      module.exports = rotate;
      /**
       * Rotates a mat2 by the given angle
       *
       * @alias mat2.rotate
       * @param {mat2} out the receiving matrix
       * @param {mat2} a the matrix to rotate
       * @param {Number} rad the angle to rotate the matrix by
       * @returns {mat2} out
       */

      function rotate(out, a, rad) {
        var a0 = a[0],
          a1 = a[1],
          a2 = a[2],
          a3 = a[3];
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out[0] = a0 * c + a2 * s;
        out[1] = a1 * c + a3 * s;
        out[2] = a0 * -s + a2 * c;
        out[3] = a1 * -s + a3 * c;
        return out;
      }

      /***/
    }),
/* 271 */
/***/ (function (module, exports) {

      module.exports = invert;
      /**
       * Inverts a mat2
       *
       * @alias mat2.invert
       * @param {mat2} out the receiving matrix
       * @param {mat2} a the source matrix
       * @returns {mat2} out
       */

      function invert(out, a) {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var det = a0 * a3 - a2 * a1;
        if (!det) return null;
        det = 1.0 / det;
        out[0] = a3 * det;
        out[1] = -a1 * det;
        out[2] = -a2 * det;
        out[3] = a0 * det;
        return out;
      }

      /***/
    }),
/* 272 */
/***/ (function (module, exports) {

      module.exports = create;
      /**
       * Creates a new identity mat2
       *
       * @alias mat2.create
       * @returns {mat2} a new 2x2 matrix
       */

      function create() {
        var out = new Float32Array(4);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }

      /***/
    }),
/* 273 */
/***/ (function (module, exports) {

      module.exports = scale;
      /**
       * Scales the mat2 by the dimensions in the given vec2
       *
       * @alias mat2.scale
       * @param {mat2} out the receiving matrix
       * @param {mat2} a the matrix to rotate
       * @param {vec2} v the vec2 to scale the matrix by
       * @returns {mat2} out
       **/

      function scale(out, a, v) {
        var a0 = a[0],
          a1 = a[1],
          a2 = a[2],
          a3 = a[3];
        var v0 = v[0],
          v1 = v[1];
        out[0] = a0 * v0;
        out[1] = a1 * v0;
        out[2] = a2 * v1;
        out[3] = a3 * v1;
        return out;
      }

      /***/
    }),
/* 274 */
/***/ (function (module, exports) {

      module.exports = copy;
      /**
       * Copy the values from one mat2 to another
       *
       * @alias mat2.copy
       * @param {mat2} out the receiving matrix
       * @param {mat2} a the source matrix
       * @returns {mat2} out
       */

      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return out;
      }

      /***/
    }),
/* 275 */
/***/ (function (module, exports) {

      module.exports = frob;
      /**
       * Returns Frobenius norm of a mat2
       *
       * @alias mat2.frob
       * @param {mat2} a the matrix to calculate Frobenius norm of
       * @returns {Number} Frobenius norm
       */

      function frob(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
      }

      /***/
    }),
/* 276 */
/***/ (function (module, exports) {

      module.exports = ldu;
      /**
       * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
       *
       * @alias mat2.ldu
       * @param {mat2} L the lower triangular matrix
       * @param {mat2} D the diagonal matrix
       * @param {mat2} U the upper triangular matrix
       * @param {mat2} a the input matrix to factorize
       */

      function ldu(L, D, U, a) {
        L[2] = a[2] / a[0];
        U[0] = a[0];
        U[1] = a[1];
        U[3] = a[3] - L[2] * U[1];
        return [L, D, U];
      }

      /***/
    }),
/* 277 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      } // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications


      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;

      function getLens(b64) {
        var len = b64.length;

        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        } // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42


        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      } // base64 is 4/3 + up to two characters of the original data


      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i;

        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        return arr;
      }

      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
      }

      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];

        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }

        return output.join('');
      }

      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3
        // go through the array every three bytes, we'll deal with trailing stuff later

        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        } // pad the end with zeros, but make sure to not forget the extra bytes


        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
        }

        return parts.join('');
      }

      /***/
    }),
/* 278 */
/***/ (function (module, exports) {

      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;

        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) { }

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;

        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) { }

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }

        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };

      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);

          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }

          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }

          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }

        e = e << mLen | m;
        eLen += mLen;

        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }

        buffer[offset + i - d] |= s * 128;
      };

      /***/
    }),
/* 279 */
/***/ (function (module, exports) {

      var toString = {}.toString;

      module.exports = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
      };

      /***/
    }),
/* 280 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
        // backported and transplited with Babel, with backwards-compat fixes
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // resolves . and .. elements in a path array with directory names there
        // must be no slashes, empty elements, or device names (c:\) in the array
        // (so also no leading and trailing slashes - it does not distinguish
        // relative and absolute paths)
        function normalizeArray(parts, allowAboveRoot) {
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;

          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];

            if (last === '.') {
              parts.splice(i, 1);
            } else if (last === '..') {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          } // if the path is allowed to go above the root, restore leading ..s


          if (allowAboveRoot) {
            for (; up--; up) {
              parts.unshift('..');
            }
          }

          return parts;
        } // path.resolve([from ...], to)
        // posix version


        exports.resolve = function () {
          var resolvedPath = '',
            resolvedAbsolute = false;

          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

            if (typeof path !== 'string') {
              throw new TypeError('Arguments to path.resolve must be strings');
            } else if (!path) {
              continue;
            }

            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charAt(0) === '/';
          } // At this point the path should be resolved to a full absolute path, but
          // handle relative paths to be safe (might happen when process.cwd() fails)
          // Normalize the path


          resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
            return !!p;
          }), !resolvedAbsolute).join('/');
          return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
        }; // path.normalize(path)
        // posix version


        exports.normalize = function (path) {
          var isAbsolute = exports.isAbsolute(path),
            trailingSlash = substr(path, -1) === '/'; // Normalize the path

          path = normalizeArray(filter(path.split('/'), function (p) {
            return !!p;
          }), !isAbsolute).join('/');

          if (!path && !isAbsolute) {
            path = '.';
          }

          if (path && trailingSlash) {
            path += '/';
          }

          return (isAbsolute ? '/' : '') + path;
        }; // posix version


        exports.isAbsolute = function (path) {
          return path.charAt(0) === '/';
        }; // posix version


        exports.join = function () {
          var paths = Array.prototype.slice.call(arguments, 0);
          return exports.normalize(filter(paths, function (p, index) {
            if (typeof p !== 'string') {
              throw new TypeError('Arguments to path.join must be strings');
            }

            return p;
          }).join('/'));
        }; // path.relative(from, to)
        // posix version


        exports.relative = function (from, to) {
          from = exports.resolve(from).substr(1);
          to = exports.resolve(to).substr(1);

          function trim(arr) {
            var start = 0;

            for (; start < arr.length; start++) {
              if (arr[start] !== '') break;
            }

            var end = arr.length - 1;

            for (; end >= 0; end--) {
              if (arr[end] !== '') break;
            }

            if (start > end) return [];
            return arr.slice(start, end - start + 1);
          }

          var fromParts = trim(from.split('/'));
          var toParts = trim(to.split('/'));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;

          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }

          var outputParts = [];

          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push('..');
          }

          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join('/');
        };

        exports.sep = '/';
        exports.delimiter = ':';

        exports.dirname = function (path) {
          if (typeof path !== 'string') path = path + '';
          if (path.length === 0) return '.';
          var code = path.charCodeAt(0);
          var hasRoot = code === 47
            /*/*/
            ;
          var end = -1;
          var matchedSlash = true;

          for (var i = path.length - 1; i >= 1; --i) {
            code = path.charCodeAt(i);

            if (code === 47
              /*/*/
            ) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              // We saw the first non-path separator
              matchedSlash = false;
            }
          }

          if (end === -1) return hasRoot ? '/' : '.';

          if (hasRoot && end === 1) {
            // return '//';
            // Backwards-compat fix:
            return '/';
          }

          return path.slice(0, end);
        };

        function basename(path) {
          if (typeof path !== 'string') path = path + '';
          var start = 0;
          var end = -1;
          var matchedSlash = true;
          var i;

          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47
              /*/*/
            ) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // path component
              matchedSlash = false;
              end = i + 1;
            }
          }

          if (end === -1) return '';
          return path.slice(start, end);
        } // Uses a mixed approach for backwards-compatibility, as ext behavior changed
        // in new Node.js versions, so only basename() above is backported here


        exports.basename = function (path, ext) {
          var f = basename(path);

          if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
          }

          return f;
        };

        exports.extname = function (path) {
          if (typeof path !== 'string') path = path + '';
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
          // after any path separator we find

          var preDotState = 0;

          for (var i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);

            if (code === 47
              /*/*/
            ) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }

              continue;
            }

            if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // extension
              matchedSlash = false;
              end = i + 1;
            }

            if (code === 46
              /*.*/
            ) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1) startDot = i; else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
              // We saw a non-dot and non-path separator before our dot, so we should
              // have a good chance at having a non-empty extension
              preDotState = -1;
            }
          }

          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
            preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return '';
          }

          return path.slice(startDot, end);
        };

        function filter(xs, f) {
          if (xs.filter) return xs.filter(f);
          var res = [];

          for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
          }

          return res;
        } // String.prototype.substr - negative index don't work in IE8


        var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
          return str.substr(start, len);
        } : function (str, start, len) {
          if (start < 0) start = str.length + start;
          return str.substr(start, len);
        };
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(15)))

      /***/
    }),
/* 281 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      function iota(n) {
        var result = new Array(n);

        for (var i = 0; i < n; ++i) {
          result[i] = i;
        }

        return result;
      }

      module.exports = iota;

      /***/
    }),
/* 282 */
/***/ (function (module, exports) {

      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      // The _isBuffer check is for Safari 5-7 support, because it's missing
      // Object.prototype.constructor. Remove this eventually
      module.exports = function (obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };

      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
      } // For Node v0.10 support. Remove this eventually.


      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
      }

      /***/
    }),
/* 283 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
      // (c) Dean McNamee <dean@gmail.com>, 2013.
      //
      // https://github.com/deanm/omggif
      //
      // Permission is hereby granted, free of charge, to any person obtaining a copy
      // of this software and associated documentation files (the "Software"), to
      // deal in the Software without restriction, including without limitation the
      // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
      // sell copies of the Software, and to permit persons to whom the Software is
      // furnished to do so, subject to the following conditions:
      //
      // The above copyright notice and this permission notice shall be included in
      // all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
      // IN THE SOFTWARE.
      //
      // omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
      // including animation and compression.  It does not rely on any specific
      // underlying system, so should run in the browser, Node, or Plask.


      function GifWriter(buf, width, height, gopts) {
        var p = 0;
        var gopts = gopts === undefined ? {} : gopts;
        var loop_count = gopts.loop === undefined ? null : gopts.loop;
        var global_palette = gopts.palette === undefined ? null : gopts.palette;
        if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");

        function check_palette_and_num_colors(palette) {
          var num_colors = palette.length;

          if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
            throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
          }

          return num_colors;
        } // - Header.


        buf[p++] = 0x47;
        buf[p++] = 0x49;
        buf[p++] = 0x46; // GIF

        buf[p++] = 0x38;
        buf[p++] = 0x39;
        buf[p++] = 0x61; // 89a
        // Handling of Global Color Table (palette) and background index.

        var gp_num_colors_pow2 = 0;
        var background = 0;

        if (global_palette !== null) {
          var gp_num_colors = check_palette_and_num_colors(global_palette);

          while (gp_num_colors >>= 1) ++gp_num_colors_pow2;

          gp_num_colors = 1 << gp_num_colors_pow2;
          --gp_num_colors_pow2;

          if (gopts.background !== undefined) {
            background = gopts.background;
            if (background >= gp_num_colors) throw new Error("Background index out of range."); // The GIF spec states that a background index of 0 should be ignored, so
            // this is probably a mistake and you really want to set it to another
            // slot in the palette.  But actually in the end most browsers, etc end
            // up ignoring this almost completely (including for dispose background).

            if (background === 0) throw new Error("Background index explicitly passed as 0.");
          }
        } // - Logical Screen Descriptor.
        // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.


        buf[p++] = width & 0xff;
        buf[p++] = width >> 8 & 0xff;
        buf[p++] = height & 0xff;
        buf[p++] = height >> 8 & 0xff; // NOTE: Indicates 0-bpp original color resolution (unused?).

        buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.
          gp_num_colors_pow2; // NOTE: No sort flag (unused?).

        buf[p++] = background; // Background Color Index.

        buf[p++] = 0; // Pixel aspect ratio (unused?).
        // - Global Color Table

        if (global_palette !== null) {
          for (var i = 0, il = global_palette.length; i < il; ++i) {
            var rgb = global_palette[i];
            buf[p++] = rgb >> 16 & 0xff;
            buf[p++] = rgb >> 8 & 0xff;
            buf[p++] = rgb & 0xff;
          }
        }

        if (loop_count !== null) {
          // Netscape block for looping.
          if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid."); // Extension code, label, and length.

          buf[p++] = 0x21;
          buf[p++] = 0xff;
          buf[p++] = 0x0b; // NETSCAPE2.0

          buf[p++] = 0x4e;
          buf[p++] = 0x45;
          buf[p++] = 0x54;
          buf[p++] = 0x53;
          buf[p++] = 0x43;
          buf[p++] = 0x41;
          buf[p++] = 0x50;
          buf[p++] = 0x45;
          buf[p++] = 0x32;
          buf[p++] = 0x2e;
          buf[p++] = 0x30; // Sub-block

          buf[p++] = 0x03;
          buf[p++] = 0x01;
          buf[p++] = loop_count & 0xff;
          buf[p++] = loop_count >> 8 & 0xff;
          buf[p++] = 0x00; // Terminator.
        }

        var ended = false;

        this.addFrame = function (x, y, w, h, indexed_pixels, opts) {
          if (ended === true) {
            --p;
            ended = false;
          } // Un-end.


          opts = opts === undefined ? {} : opts; // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
          // canvas width/height, I imagine?

          if (x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error("x/y invalid.");
          if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
          if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
          var using_local_palette = true;
          var palette = opts.palette;

          if (palette === undefined || palette === null) {
            using_local_palette = false;
            palette = global_palette;
          }

          if (palette === undefined || palette === null) throw new Error("Must supply either a local or global palette.");
          var num_colors = check_palette_and_num_colors(palette); // Compute the min_code_size (power of 2), destroying num_colors.

          var min_code_size = 0;

          while (num_colors >>= 1) ++min_code_size;

          num_colors = 1 << min_code_size; // Now we can easily get it back.

          var delay = opts.delay === undefined ? 0 : opts.delay; // From the spec:
          //     0 -   No disposal specified. The decoder is
          //           not required to take any action.
          //     1 -   Do not dispose. The graphic is to be left
          //           in place.
          //     2 -   Restore to background color. The area used by the
          //           graphic must be restored to the background color.
          //     3 -   Restore to previous. The decoder is required to
          //           restore the area overwritten by the graphic with
          //           what was there prior to rendering the graphic.
          //  4-7 -    To be defined.
          // NOTE(deanm): Dispose background doesn't really work, apparently most
          // browsers ignore the background palette index and clear to transparency.

          var disposal = opts.disposal === undefined ? 0 : opts.disposal;
          if (disposal < 0 || disposal > 3) // 4-7 is reserved.
            throw new Error("Disposal out of range.");
          var use_transparency = false;
          var transparent_index = 0;

          if (opts.transparent !== undefined && opts.transparent !== null) {
            use_transparency = true;
            transparent_index = opts.transparent;
            if (transparent_index < 0 || transparent_index >= num_colors) throw new Error("Transparent color index.");
          }

          if (disposal !== 0 || use_transparency || delay !== 0) {
            // - Graphics Control Extension
            buf[p++] = 0x21;
            buf[p++] = 0xf9; // Extension / Label.

            buf[p++] = 4; // Byte size.

            buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
            buf[p++] = delay & 0xff;
            buf[p++] = delay >> 8 & 0xff;
            buf[p++] = transparent_index; // Transparent color index.

            buf[p++] = 0; // Block Terminator.
          } // - Image Descriptor


          buf[p++] = 0x2c; // Image Seperator.

          buf[p++] = x & 0xff;
          buf[p++] = x >> 8 & 0xff; // Left.

          buf[p++] = y & 0xff;
          buf[p++] = y >> 8 & 0xff; // Top.

          buf[p++] = w & 0xff;
          buf[p++] = w >> 8 & 0xff;
          buf[p++] = h & 0xff;
          buf[p++] = h >> 8 & 0xff; // NOTE: No sort flag (unused?).
          // TODO(deanm): Support interlace.

          buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0; // - Local Color Table

          if (using_local_palette === true) {
            for (var i = 0, il = palette.length; i < il; ++i) {
              var rgb = palette[i];
              buf[p++] = rgb >> 16 & 0xff;
              buf[p++] = rgb >> 8 & 0xff;
              buf[p++] = rgb & 0xff;
            }
          }

          p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
          return p;
        };

        this.end = function () {
          if (ended === false) {
            buf[p++] = 0x3b; // Trailer.

            ended = true;
          }

          return p;
        };

        this.getOutputBuffer = function () {
          return buf;
        };

        this.setOutputBuffer = function (v) {
          buf = v;
        };

        this.getOutputBufferPosition = function () {
          return p;
        };

        this.setOutputBufferPosition = function (v) {
          p = v;
        };
      } // Main compression routine, palette indexes -> LZW code stream.
      // |index_stream| must have at least one entry.


      function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
        buf[p++] = min_code_size;
        var cur_subblock = p++; // Pointing at the length field.

        var clear_code = 1 << min_code_size;
        var code_mask = clear_code - 1;
        var eoi_code = clear_code + 1;
        var next_code = eoi_code + 1;
        var cur_code_size = min_code_size + 1; // Number of bits per code.

        var cur_shift = 0; // We have at most 12-bit codes, so we should have to hold a max of 19
        // bits here (and then we would write out).

        var cur = 0;

        function emit_bytes_to_buffer(bit_block_size) {
          while (cur_shift >= bit_block_size) {
            buf[p++] = cur & 0xff;
            cur >>= 8;
            cur_shift -= 8;

            if (p === cur_subblock + 256) {
              // Finished a subblock.
              buf[cur_subblock] = 255;
              cur_subblock = p++;
            }
          }
        }

        function emit_code(c) {
          cur |= c << cur_shift;
          cur_shift += cur_code_size;
          emit_bytes_to_buffer(8);
        } // I am not an expert on the topic, and I don't want to write a thesis.
        // However, it is good to outline here the basic algorithm and the few data
        // structures and optimizations here that make this implementation fast.
        // The basic idea behind LZW is to build a table of previously seen runs
        // addressed by a short id (herein called output code).  All data is
        // referenced by a code, which represents one or more values from the
        // original input stream.  All input bytes can be referenced as the same
        // value as an output code.  So if you didn't want any compression, you
        // could more or less just output the original bytes as codes (there are
        // some details to this, but it is the idea).  In order to achieve
        // compression, values greater then the input range (codes can be up to
        // 12-bit while input only 8-bit) represent a sequence of previously seen
        // inputs.  The decompressor is able to build the same mapping while
        // decoding, so there is always a shared common knowledge between the
        // encoding and decoder, which is also important for "timing" aspects like
        // how to handle variable bit width code encoding.
        //
        // One obvious but very important consequence of the table system is there
        // is always a unique id (at most 12-bits) to map the runs.  'A' might be
        // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
        // can be used for an effecient lookup strategy for the code mapping.  We
        // need to know if a run has been seen before, and be able to map that run
        // to the output code.  Since we start with known unique ids (input bytes),
        // and then from those build more unique ids (table entries), we can
        // continue this chain (almost like a linked list) to always have small
        // integer values that represent the current byte chains in the encoder.
        // This means instead of tracking the input bytes (AAAABCD) to know our
        // current state, we can track the table entry for AAAABC (it is guaranteed
        // to exist by the nature of the algorithm) and the next character D.
        // Therefor the tuple of (table_entry, byte) is guaranteed to also be
        // unique.  This allows us to create a simple lookup key for mapping input
        // sequences to codes (table indices) without having to store or search
        // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
        // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
        // key.  This leads to a integer value at most 20-bits, which can always
        // fit in an SMI value and be used as a fast sparse array / object key.
        // Output code for the current contents of the index buffer.


        var ib_code = index_stream[0] & code_mask; // Load first input index.

        var code_table = {}; // Key'd on our 20-bit "tuple".

        emit_code(clear_code); // Spec says first code should be a clear code.
        // First index already loaded, process the rest of the stream.

        for (var i = 1, il = index_stream.length; i < il; ++i) {
          var k = index_stream[i] & code_mask;
          var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.

          var cur_code = code_table[cur_key]; // buffer + k.
          // Check if we have to create a new code table entry.

          if (cur_code === undefined) {
            // We don't have buffer + k.
            // Emit index buffer (without k).
            // This is an inline version of emit_code, because this is the core
            // writing routine of the compressor (and V8 cannot inline emit_code
            // because it is a closure here in a different context).  Additionally
            // we can call emit_byte_to_buffer less often, because we can have
            // 30-bits (from our 31-bit signed SMI), and we know our codes will only
            // be 12-bits, so can safely have 18-bits there without overflow.
            // emit_code(ib_code);
            cur |= ib_code << cur_shift;
            cur_shift += cur_code_size;

            while (cur_shift >= 8) {
              buf[p++] = cur & 0xff;
              cur >>= 8;
              cur_shift -= 8;

              if (p === cur_subblock + 256) {
                // Finished a subblock.
                buf[cur_subblock] = 255;
                cur_subblock = p++;
              }
            }

            if (next_code === 4096) {
              // Table full, need a clear.
              emit_code(clear_code);
              next_code = eoi_code + 1;
              cur_code_size = min_code_size + 1;
              code_table = {};
            } else {
              // Table not full, insert a new entry.
              // Increase our variable bit code sizes if necessary.  This is a bit
              // tricky as it is based on "timing" between the encoding and
              // decoder.  From the encoders perspective this should happen after
              // we've already emitted the index buffer and are about to create the
              // first table entry that would overflow our current code bit size.
              if (next_code >= 1 << cur_code_size) ++cur_code_size;
              code_table[cur_key] = next_code++; // Insert into code table.
            }

            ib_code = k; // Index buffer to single input k.
          } else {
            ib_code = cur_code; // Index buffer to sequence in code table.
          }
        }

        emit_code(ib_code); // There will still be something in the index buffer.

        emit_code(eoi_code); // End Of Information.
        // Flush / finalize the sub-blocks stream to the buffer.

        emit_bytes_to_buffer(1); // Finish the sub-blocks, writing out any unfinished lengths and
        // terminating with a sub-block of length 0.  If we have already started
        // but not yet used a sub-block it can just become the terminator.

        if (cur_subblock + 1 === p) {
          // Started but unused.
          buf[cur_subblock] = 0;
        } else {
          // Started and used, write length and additional terminator block.
          buf[cur_subblock] = p - cur_subblock - 1;
          buf[p++] = 0;
        }

        return p;
      }

      function GifReader(buf) {
        var p = 0; // - Header (GIF87a or GIF89a).

        if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 || buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
          throw new Error("Invalid GIF 87a/89a header.");
        } // - Logical Screen Descriptor.


        var width = buf[p++] | buf[p++] << 8;
        var height = buf[p++] | buf[p++] << 8;
        var pf0 = buf[p++]; // <Packed Fields>.

        var global_palette_flag = pf0 >> 7;
        var num_global_colors_pow2 = pf0 & 0x7;
        var num_global_colors = 1 << num_global_colors_pow2 + 1;
        var background = buf[p++];
        buf[p++]; // Pixel aspect ratio (unused?).

        var global_palette_offset = null;
        var global_palette_size = null;

        if (global_palette_flag) {
          global_palette_offset = p;
          global_palette_size = num_global_colors;
          p += num_global_colors * 3; // Seek past palette.
        }

        var no_eof = true;
        var frames = [];
        var delay = 0;
        var transparent_index = null;
        var disposal = 0; // 0 - No disposal specified.

        var loop_count = null;
        this.width = width;
        this.height = height;

        while (no_eof && p < buf.length) {
          switch (buf[p++]) {
            case 0x21:
              // Graphics Control Extension Block
              switch (buf[p++]) {
                case 0xff:
                  // Application specific block
                  // Try if it's a Netscape block (with animation loop counter).
                  if (buf[p] !== 0x0b || // 21 FF already read, check block size.
                    // NETSCAPE2.0
                    buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 && buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 && buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 && buf[p + 10] == 0x2e && buf[p + 11] == 0x30 && // Sub-block
                    buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {
                    p += 14;
                    loop_count = buf[p++] | buf[p++] << 8;
                    p++; // Skip terminator.
                  } else {
                    // We don't know what it is, just try to get past it.
                    p += 12;

                    while (true) {
                      // Seek through subblocks.
                      var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

                      if (!(block_size >= 0)) throw Error("Invalid block size");
                      if (block_size === 0) break; // 0 size is terminator

                      p += block_size;
                    }
                  }

                  break;

                case 0xf9:
                  // Graphics Control Extension
                  if (buf[p++] !== 0x4 || buf[p + 4] !== 0) throw new Error("Invalid graphics extension block.");
                  var pf1 = buf[p++];
                  delay = buf[p++] | buf[p++] << 8;
                  transparent_index = buf[p++];
                  if ((pf1 & 1) === 0) transparent_index = null;
                  disposal = pf1 >> 2 & 0x7;
                  p++; // Skip terminator.

                  break;

                case 0xfe:
                  // Comment Extension.
                  while (true) {
                    // Seek through subblocks.
                    var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

                    if (!(block_size >= 0)) throw Error("Invalid block size");
                    if (block_size === 0) break; // 0 size is terminator
                    // console.log(buf.slice(p, p+block_size).toString('ascii'));

                    p += block_size;
                  }

                  break;

                default:
                  throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
              }

              break;

            case 0x2c:
              // Image Descriptor.
              var x = buf[p++] | buf[p++] << 8;
              var y = buf[p++] | buf[p++] << 8;
              var w = buf[p++] | buf[p++] << 8;
              var h = buf[p++] | buf[p++] << 8;
              var pf2 = buf[p++];
              var local_palette_flag = pf2 >> 7;
              var interlace_flag = pf2 >> 6 & 1;
              var num_local_colors_pow2 = pf2 & 0x7;
              var num_local_colors = 1 << num_local_colors_pow2 + 1;
              var palette_offset = global_palette_offset;
              var palette_size = global_palette_size;
              var has_local_palette = false;

              if (local_palette_flag) {
                var has_local_palette = true;
                palette_offset = p; // Override with local palette.

                palette_size = num_local_colors;
                p += num_local_colors * 3; // Seek past palette.
              }

              var data_offset = p;
              p++; // codesize

              while (true) {
                var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break; // 0 size is terminator

                p += block_size;
              }

              frames.push({
                x: x,
                y: y,
                width: w,
                height: h,
                has_local_palette: has_local_palette,
                palette_offset: palette_offset,
                palette_size: palette_size,
                data_offset: data_offset,
                data_length: p - data_offset,
                transparent_index: transparent_index,
                interlaced: !!interlace_flag,
                delay: delay,
                disposal: disposal
              });
              break;

            case 0x3b:
              // Trailer Marker (end of file).
              no_eof = false;
              break;

            default:
              throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
              break;
          }
        }

        this.numFrames = function () {
          return frames.length;
        };

        this.loopCount = function () {
          return loop_count;
        };

        this.frameInfo = function (frame_num) {
          if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
          return frames[frame_num];
        };

        this.decodeAndBlitFrameBGRA = function (frame_num, pixels) {
          var frame = this.frameInfo(frame_num);
          var num_pixels = frame.width * frame.height;
          var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

          GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
          var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
          // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
          // the profile, not sure if it's related to using a Uint8Array.

          var trans = frame.transparent_index;
          if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
          // That is a subrect within the framerect, so the additional pixels
          // must be skipped over after we finished a scanline.

          var framewidth = frame.width;
          var framestride = width - framewidth;
          var xleft = framewidth; // Number of subrect pixels left in scanline.
          // Output indicies of the top left and bottom right corners of the subrect.

          var opbeg = (frame.y * width + frame.x) * 4;
          var opend = ((frame.y + frame.height) * width + frame.x) * 4;
          var op = opbeg;
          var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
          // 7 rows for the first two passes, then 3 then 1.

          if (frame.interlaced === true) {
            scanstride += width * 4 * 7; // Pass 1.
          }

          var interlaceskip = 8; // Tracking the row interval in the current pass.

          for (var i = 0, il = index_stream.length; i < il; ++i) {
            var index = index_stream[i];

            if (xleft === 0) {
              // Beginning of new scan line
              op += scanstride;
              xleft = framewidth;

              if (op >= opend) {
                // Catch the wrap to switch passes when interlacing.
                scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

                op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
                interlaceskip >>= 1;
              }
            }

            if (index === trans) {
              op += 4;
            } else {
              var r = buf[palette_offset + index * 3];
              var g = buf[palette_offset + index * 3 + 1];
              var b = buf[palette_offset + index * 3 + 2];
              pixels[op++] = b;
              pixels[op++] = g;
              pixels[op++] = r;
              pixels[op++] = 255;
            }

            --xleft;
          }
        }; // I will go to copy and paste hell one day...


        this.decodeAndBlitFrameRGBA = function (frame_num, pixels) {
          var frame = this.frameInfo(frame_num);
          var num_pixels = frame.width * frame.height;
          var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

          GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
          var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
          // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
          // the profile, not sure if it's related to using a Uint8Array.

          var trans = frame.transparent_index;
          if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
          // That is a subrect within the framerect, so the additional pixels
          // must be skipped over after we finished a scanline.

          var framewidth = frame.width;
          var framestride = width - framewidth;
          var xleft = framewidth; // Number of subrect pixels left in scanline.
          // Output indicies of the top left and bottom right corners of the subrect.

          var opbeg = (frame.y * width + frame.x) * 4;
          var opend = ((frame.y + frame.height) * width + frame.x) * 4;
          var op = opbeg;
          var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
          // 7 rows for the first two passes, then 3 then 1.

          if (frame.interlaced === true) {
            scanstride += width * 4 * 7; // Pass 1.
          }

          var interlaceskip = 8; // Tracking the row interval in the current pass.

          for (var i = 0, il = index_stream.length; i < il; ++i) {
            var index = index_stream[i];

            if (xleft === 0) {
              // Beginning of new scan line
              op += scanstride;
              xleft = framewidth;

              if (op >= opend) {
                // Catch the wrap to switch passes when interlacing.
                scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

                op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
                interlaceskip >>= 1;
              }
            }

            if (index === trans) {
              op += 4;
            } else {
              var r = buf[palette_offset + index * 3];
              var g = buf[palette_offset + index * 3 + 1];
              var b = buf[palette_offset + index * 3 + 2];
              pixels[op++] = r;
              pixels[op++] = g;
              pixels[op++] = b;
              pixels[op++] = 255;
            }

            --xleft;
          }
        };
      }

      function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
        var min_code_size = code_stream[p++];
        var clear_code = 1 << min_code_size;
        var eoi_code = clear_code + 1;
        var next_code = eoi_code + 1;
        var cur_code_size = min_code_size + 1; // Number of bits per code.
        // NOTE: This shares the same name as the encoder, but has a different
        // meaning here.  Here this masks each code coming from the code stream.

        var code_mask = (1 << cur_code_size) - 1;
        var cur_shift = 0;
        var cur = 0;
        var op = 0; // Output pointer.

        var subblock_size = code_stream[p++]; // TODO(deanm): Would using a TypedArray be any faster?  At least it would
        // solve the fast mode / backing store uncertainty.
        // var code_table = Array(4096);

        var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.

        var prev_code = null; // Track code-1.

        while (true) {
          // Read up to two bytes, making sure we always 12-bits for max sized code.
          while (cur_shift < 16) {
            if (subblock_size === 0) break; // No more data to be read.

            cur |= code_stream[p++] << cur_shift;
            cur_shift += 8;

            if (subblock_size === 1) {
              // Never let it get to 0 to hold logic above.
              subblock_size = code_stream[p++]; // Next subblock.
            } else {
              --subblock_size;
            }
          } // TODO(deanm): We should never really get here, we should have received
          // and EOI.


          if (cur_shift < cur_code_size) break;
          var code = cur & code_mask;
          cur >>= cur_code_size;
          cur_shift -= cur_code_size; // TODO(deanm): Maybe should check that the first code was a clear code,
          // at least this is what you're supposed to do.  But actually our encoder
          // now doesn't emit a clear code first anyway.

          if (code === clear_code) {
            // We don't actually have to clear the table.  This could be a good idea
            // for greater error checking, but we don't really do any anyway.  We
            // will just track it with next_code and overwrite old entries.
            next_code = eoi_code + 1;
            cur_code_size = min_code_size + 1;
            code_mask = (1 << cur_code_size) - 1; // Don't update prev_code ?

            prev_code = null;
            continue;
          } else if (code === eoi_code) {
            break;
          } // We have a similar situation as the decoder, where we want to store
          // variable length entries (code table entries), but we want to do in a
          // faster manner than an array of arrays.  The code below stores sort of a
          // linked list within the code table, and then "chases" through it to
          // construct the dictionary entries.  When a new entry is created, just the
          // last byte is stored, and the rest (prefix) of the entry is only
          // referenced by its table entry.  Then the code chases through the
          // prefixes until it reaches a single byte code.  We have to chase twice,
          // first to compute the length, and then to actually copy the data to the
          // output (backwards, since we know the length).  The alternative would be
          // storing something in an intermediate stack, but that doesn't make any
          // more sense.  I implemented an approach where it also stored the length
          // in the code table, although it's a bit tricky because you run out of
          // bits (12 + 12 + 8), but I didn't measure much improvements (the table
          // entries are generally not the long).  Even when I created benchmarks for
          // very long table entries the complexity did not seem worth it.
          // The code table stores the prefix entry in 12 bits and then the suffix
          // byte in 8 bits, so each entry is 20 bits.


          var chase_code = code < next_code ? code : prev_code; // Chase what we will output, either {CODE} or {CODE-1}.

          var chase_length = 0;
          var chase = chase_code;

          while (chase > clear_code) {
            chase = code_table[chase] >> 8;
            ++chase_length;
          }

          var k = chase;
          var op_end = op + chase_length + (chase_code !== code ? 1 : 0);

          if (op_end > output_length) {
            console.log("Warning, gif stream longer than expected.");
            return;
          } // Already have the first byte from the chase, might as well write it fast.


          output[op++] = k;
          op += chase_length;
          var b = op; // Track pointer, writing backwards.

          if (chase_code !== code) // The case of emitting {CODE-1} + k.
            output[op++] = k;
          chase = chase_code;

          while (chase_length--) {
            chase = code_table[chase];
            output[--b] = chase & 0xff; // Write backwards.

            chase >>= 8; // Pull down to the prefix code.
          }

          if (prev_code !== null && next_code < 4096) {
            code_table[next_code++] = prev_code << 8 | k; // TODO(deanm): Figure out this clearing vs code growth logic better.  I
            // have an feeling that it should just happen somewhere else, for now it
            // is awkward between when we grow past the max and then hit a clear code.
            // For now just check if we hit the max 12-bits (then a clear code should
            // follow, also of course encoded in 12-bits).

            if (next_code >= code_mask + 1 && cur_code_size < 12) {
              ++cur_code_size;
              code_mask = code_mask << 1 | 1;
            }
          }

          prev_code = code;
        }

        if (op !== output_length) {
          console.log("Warning, gif stream shorter than expected.");
        }

        return output;
      } // CommonJS.


      try {
        exports.GifWriter = GifWriter;
        exports.GifReader = GifReader;
      } catch (e) { }

      /***/
    }),
/* 284 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var ndarray = __webpack_require__(51);

      var do_convert = __webpack_require__(285);

      module.exports = function convert(arr, result) {
        var shape = [],
          c = arr,
          sz = 1;

        while (Array.isArray(c)) {
          shape.push(c.length);
          sz *= c.length;
          c = c[0];
        }

        if (shape.length === 0) {
          return ndarray();
        }

        if (!result) {
          result = ndarray(new Float64Array(sz), shape);
        }

        do_convert(result, arr);
        return result;
      };

      /***/
    }),
/* 285 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(286)({
        "args": ["array", "scalar", "index"],
        "pre": {
          "body": "{}",
          "args": [],
          "thisVars": [],
          "localVars": []
        },
        "body": {
          "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
          "args": [{
            "name": "_inline_1_arg0_",
            "lvalue": true,
            "rvalue": false,
            "count": 1
          }, {
            "name": "_inline_1_arg1_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
          }, {
            "name": "_inline_1_arg2_",
            "lvalue": false,
            "rvalue": true,
            "count": 4
          }],
          "thisVars": [],
          "localVars": ["_inline_1_i", "_inline_1_v"]
        },
        "post": {
          "body": "{}",
          "args": [],
          "thisVars": [],
          "localVars": []
        },
        "funcName": "convert",
        "blockSize": 64
      });

      /***/
    }),
/* 286 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var createThunk = __webpack_require__(287);

      function Procedure() {
        this.argTypes = [];
        this.shimArgs = [];
        this.arrayArgs = [];
        this.arrayBlockIndices = [];
        this.scalarArgs = [];
        this.offsetArgs = [];
        this.offsetArgIndex = [];
        this.indexArgs = [];
        this.shapeArgs = [];
        this.funcName = "";
        this.pre = null;
        this.body = null;
        this.post = null;
        this.debug = false;
      }

      function compileCwise(user_args) {
        //Create procedure
        var proc = new Procedure(); //Parse blocks

        proc.pre = user_args.pre;
        proc.body = user_args.body;
        proc.post = user_args.post; //Parse arguments

        var proc_args = user_args.args.slice(0);
        proc.argTypes = proc_args;

        for (var i = 0; i < proc_args.length; ++i) {
          var arg_type = proc_args[i];

          if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
            proc.argTypes[i] = "array";
            proc.arrayArgs.push(i);
            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
            proc.shimArgs.push("array" + i);

            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
              throw new Error("cwise: pre() block may not reference array args");
            }

            if (i < proc.post.args.length && proc.post.args[i].count > 0) {
              throw new Error("cwise: post() block may not reference array args");
            }
          } else if (arg_type === "scalar") {
            proc.scalarArgs.push(i);
            proc.shimArgs.push("scalar" + i);
          } else if (arg_type === "index") {
            proc.indexArgs.push(i);

            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
              throw new Error("cwise: pre() block may not reference array index");
            }

            if (i < proc.body.args.length && proc.body.args[i].lvalue) {
              throw new Error("cwise: body() block may not write to array index");
            }

            if (i < proc.post.args.length && proc.post.args[i].count > 0) {
              throw new Error("cwise: post() block may not reference array index");
            }
          } else if (arg_type === "shape") {
            proc.shapeArgs.push(i);

            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
              throw new Error("cwise: pre() block may not write to array shape");
            }

            if (i < proc.body.args.length && proc.body.args[i].lvalue) {
              throw new Error("cwise: body() block may not write to array shape");
            }

            if (i < proc.post.args.length && proc.post.args[i].lvalue) {
              throw new Error("cwise: post() block may not write to array shape");
            }
          } else if (typeof arg_type === "object" && arg_type.offset) {
            proc.argTypes[i] = "offset";
            proc.offsetArgs.push({
              array: arg_type.array,
              offset: arg_type.offset
            });
            proc.offsetArgIndex.push(i);
          } else {
            throw new Error("cwise: Unknown argument type " + proc_args[i]);
          }
        } //Make sure at least one array argument was specified


        if (proc.arrayArgs.length <= 0) {
          throw new Error("cwise: No array arguments specified");
        } //Make sure arguments are correct


        if (proc.pre.args.length > proc_args.length) {
          throw new Error("cwise: Too many arguments in pre() block");
        }

        if (proc.body.args.length > proc_args.length) {
          throw new Error("cwise: Too many arguments in body() block");
        }

        if (proc.post.args.length > proc_args.length) {
          throw new Error("cwise: Too many arguments in post() block");
        } //Check debug flag


        proc.debug = !!user_args.printCode || !!user_args.debug; //Retrieve name

        proc.funcName = user_args.funcName || "cwise"; //Read in block size

        proc.blockSize = user_args.blockSize || 64;
        return createThunk(proc);
      }

      module.exports = compileCwise;

      /***/
    }),
/* 287 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
      // The function below is called when constructing a cwise function object, and does the following:
      // A function object is constructed which accepts as argument a compilation function and returns another function.
      // It is this other function that is eventually returned by createThunk, and this function is the one that actually
      // checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
      // The compilation passed to the first function object is used for compiling new functions.
      // Once this function object is created, it is called with compile as argument, where the first argument of compile
      // is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
      // So createThunk roughly works like this:
      // function createThunk(proc) {
      //   var thunk = function(compileBound) {
      //     var CACHED = {}
      //     return function(arrays and scalars) {
      //       if (dtype and order of arrays in CACHED) {
      //         var func = CACHED[dtype and order of arrays]
      //       } else {
      //         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
      //       }
      //       return func(arrays and scalars)
      //     }
      //   }
      //   return thunk(compile.bind1(proc))
      // }

      var compile = __webpack_require__(288);

      function createThunk(proc) {
        var code = ["'use strict'", "var CACHED={}"];
        var vars = [];
        var thunkName = proc.funcName + "_cwise_thunk"; //Build thunk

        code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
        var typesig = [];
        var string_typesig = [];
        var proc_args = [["array", proc.arrayArgs[0], ".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
          Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"].join("")];
        var shapeLengthConditions = [],
          shapeConditions = []; // Process array arguments

        for (var i = 0; i < proc.arrayArgs.length; ++i) {
          var j = proc.arrayArgs[i];
          vars.push(["t", j, "=array", j, ".dtype,", "r", j, "=array", j, ".order"].join(""));
          typesig.push("t" + j);
          typesig.push("r" + j);
          string_typesig.push("t" + j);
          string_typesig.push("r" + j + ".join()");
          proc_args.push("array" + j + ".data");
          proc_args.push("array" + j + ".stride");
          proc_args.push("array" + j + ".offset|0");

          if (i > 0) {
            // Gather conditions to check for shape equality (ignoring block indices)
            shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
            shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
          }
        } // Check for shape equality


        if (proc.arrayArgs.length > 1) {
          code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
          code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
          code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
          code.push("}");
        } // Process scalar arguments


        for (var i = 0; i < proc.scalarArgs.length; ++i) {
          proc_args.push("scalar" + proc.scalarArgs[i]);
        } // Check for cached function (and if not present, generate it)


        vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
        vars.push("proc=CACHED[type]");
        code.push("var " + vars.join(","));
        code.push(["if(!proc){", "CACHED[type]=proc=compile([", typesig.join(","), "])}", "return proc(", proc_args.join(","), ")}"].join(""));

        if (proc.debug) {
          console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
        } //Compile thunk


        var thunk = new Function("compile", code.join("\n"));
        return thunk(compile.bind(undefined, proc));
      }

      module.exports = createThunk;

      /***/
    }),
/* 288 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var uniq = __webpack_require__(289); // This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
      // TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.


      function innerFill(order, proc, body) {
        var dimension = order.length,
          nargs = proc.arrayArgs.length,
          has_index = proc.indexArgs.length > 0,
          code = [],
          vars = [],
          idx = 0,
          pidx = 0,
          i,
          j;

        for (i = 0; i < dimension; ++i) {
          // Iteration variables
          vars.push(["i", i, "=0"].join(""));
        } //Compute scan deltas


        for (j = 0; j < nargs; ++j) {
          for (i = 0; i < dimension; ++i) {
            pidx = idx;
            idx = order[i];

            if (i === 0) {
              // The innermost/fastest dimension's delta is simply its stride
              vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
            } else {
              // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
              vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
            }
          }
        }

        if (vars.length > 0) {
          code.push("var " + vars.join(","));
        } //Scan loop


        for (i = dimension - 1; i >= 0; --i) {
          // Start at largest stride and work your way inwards
          idx = order[i];
          code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
        } //Push body of inner loop


        code.push(body); //Advance scan pointers

        for (i = 0; i < dimension; ++i) {
          pidx = idx;
          idx = order[i];

          for (j = 0; j < nargs; ++j) {
            code.push(["p", j, "+=d", j, "s", i].join(""));
          }

          if (has_index) {
            if (i > 0) {
              code.push(["index[", pidx, "]-=s", pidx].join(""));
            }

            code.push(["++index[", idx, "]"].join(""));
          }

          code.push("}");
        }

        return code.join("\n");
      } // Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
      // TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
      //       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.


      function outerFill(matched, order, proc, body) {
        var dimension = order.length,
          nargs = proc.arrayArgs.length,
          blockSize = proc.blockSize,
          has_index = proc.indexArgs.length > 0,
          code = [];

        for (var i = 0; i < nargs; ++i) {
          code.push(["var offset", i, "=p", i].join(""));
        } //Generate loops for unmatched dimensions
        // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
        // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).


        for (var i = matched; i < dimension; ++i) {
          code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join("")); // Iterate back to front

          code.push(["if(j", i, "<", blockSize, "){"].join("")); // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).

          code.push(["s", order[i], "=j", i].join(""));
          code.push(["j", i, "=0"].join(""));
          code.push(["}else{s", order[i], "=", blockSize].join(""));
          code.push(["j", i, "-=", blockSize, "}"].join(""));

          if (has_index) {
            code.push(["index[", order[i], "]=j", i].join(""));
          }
        }

        for (var i = 0; i < nargs; ++i) {
          var indexStr = ["offset" + i];

          for (var j = matched; j < dimension; ++j) {
            indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
          }

          code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
        }

        code.push(innerFill(order, proc, body));

        for (var i = matched; i < dimension; ++i) {
          code.push("}");
        }

        return code.join("\n");
      } //Count the number of compatible inner orders
      // This is the length of the longest common prefix of the arrays in orders.
      // Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
      // This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.


      function countMatches(orders) {
        var matched = 0,
          dimension = orders[0].length;

        while (matched < dimension) {
          for (var j = 1; j < orders.length; ++j) {
            if (orders[j][matched] !== orders[0][matched]) {
              return matched;
            }
          }

          ++matched;
        }

        return matched;
      } //Processes a block according to the given data types
      // Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.


      function processBlock(block, proc, dtypes) {
        var code = block.body;
        var pre = [];
        var post = [];

        for (var i = 0; i < block.args.length; ++i) {
          var carg = block.args[i];

          if (carg.count <= 0) {
            continue;
          }

          var re = new RegExp(carg.name, "g");
          var ptrStr = "";
          var arrNum = proc.arrayArgs.indexOf(i);

          switch (proc.argTypes[i]) {
            case "offset":
              var offArgIndex = proc.offsetArgIndex.indexOf(i);
              var offArg = proc.offsetArgs[offArgIndex];
              arrNum = offArg.array;
              ptrStr = "+q" + offArgIndex;
            // Adds offset to the "pointer" in the array

            case "array":
              ptrStr = "p" + arrNum + ptrStr;
              var localStr = "l" + i;
              var arrStr = "a" + arrNum;

              if (proc.arrayBlockIndices[arrNum] === 0) {
                // Argument to body is just a single value from this array
                if (carg.count === 1) {
                  // Argument/array used only once(?)
                  if (dtypes[arrNum] === "generic") {
                    if (carg.lvalue) {
                      pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)

                      code = code.replace(re, localStr);
                      post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                    } else {
                      code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
                    }
                  } else {
                    code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
                  }
                } else if (dtypes[arrNum] === "generic") {
                  pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

                  code = code.replace(re, localStr);

                  if (carg.lvalue) {
                    post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                  }
                } else {
                  pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

                  code = code.replace(re, localStr);

                  if (carg.lvalue) {
                    post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
                  }
                }
              } else {
                // Argument to body is a "block"
                var reStrArr = [carg.name],
                  ptrStrArr = [ptrStr];

                for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                  reStrArr.push("\\s*\\[([^\\]]+)\\]");
                  ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j); // Matched index times stride
                }

                re = new RegExp(reStrArr.join(""), "g");
                ptrStr = ptrStrArr.join("+");

                if (dtypes[arrNum] === "generic") {
                  /*if(carg.lvalue) {
                    pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                    code = code.replace(re, localStr)
                    post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
                  } else {
                    code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
                  }*/
                  throw new Error("cwise: Generic arrays not supported in combination with blocks!");
                } else {
                  // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                  code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
                }
              }

              break;

            case "scalar":
              code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
              break;

            case "index":
              code = code.replace(re, "index");
              break;

            case "shape":
              code = code.replace(re, "shape");
              break;
          }
        }

        return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
      }

      function typeSummary(dtypes) {
        var summary = new Array(dtypes.length);
        var allEqual = true;

        for (var i = 0; i < dtypes.length; ++i) {
          var t = dtypes[i];
          var digits = t.match(/\d+/);

          if (!digits) {
            digits = "";
          } else {
            digits = digits[0];
          }

          if (t.charAt(0) === 0) {
            summary[i] = "u" + t.charAt(1) + digits;
          } else {
            summary[i] = t.charAt(0) + digits;
          }

          if (i > 0) {
            allEqual = allEqual && summary[i] === summary[i - 1];
          }
        }

        if (allEqual) {
          return summary[0];
        }

        return summary.join("");
      } //Generates a cwise operator


      function generateCWiseOp(proc, typesig) {
        //Compute dimension
        // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
        var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
        var orders = new Array(proc.arrayArgs.length);
        var dtypes = new Array(proc.arrayArgs.length);

        for (var i = 0; i < proc.arrayArgs.length; ++i) {
          dtypes[i] = typesig[2 * i];
          orders[i] = typesig[2 * i + 1];
        } //Determine where block and loop indices start and end


        var blockBegin = [],
          blockEnd = []; // These indices are exposed as blocks

        var loopBegin = [],
          loopEnd = []; // These indices are iterated over

        var loopOrders = []; // orders restricted to the loop indices

        for (var i = 0; i < proc.arrayArgs.length; ++i) {
          if (proc.arrayBlockIndices[i] < 0) {
            loopBegin.push(0);
            loopEnd.push(dimension);
            blockBegin.push(dimension);
            blockEnd.push(dimension + proc.arrayBlockIndices[i]);
          } else {
            loopBegin.push(proc.arrayBlockIndices[i]); // Non-negative

            loopEnd.push(proc.arrayBlockIndices[i] + dimension);
            blockBegin.push(0);
            blockEnd.push(proc.arrayBlockIndices[i]);
          }

          var newOrder = [];

          for (var j = 0; j < orders[i].length; j++) {
            if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
              newOrder.push(orders[i][j] - loopBegin[i]); // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
            }
          }

          loopOrders.push(newOrder);
        } //First create arguments for procedure


        var arglist = ["SS"]; // SS is the overall shape over which we iterate

        var code = ["'use strict'"];
        var vars = [];

        for (var j = 0; j < dimension; ++j) {
          vars.push(["s", j, "=SS[", j, "]"].join("")); // The limits for each dimension.
        }

        for (var i = 0; i < proc.arrayArgs.length; ++i) {
          arglist.push("a" + i); // Actual data array

          arglist.push("t" + i); // Strides

          arglist.push("p" + i); // Offset in the array at which the data starts (also used for iterating over the data)

          for (var j = 0; j < dimension; ++j) {
            // Unpack the strides into vars for looping
            vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
          }

          for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
            // Unpack the strides into vars for block iteration
            vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
          }
        }

        for (var i = 0; i < proc.scalarArgs.length; ++i) {
          arglist.push("Y" + i);
        }

        if (proc.shapeArgs.length > 0) {
          vars.push("shape=SS.slice(0)"); // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
        }

        if (proc.indexArgs.length > 0) {
          // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
          var zeros = new Array(dimension);

          for (var i = 0; i < dimension; ++i) {
            zeros[i] = "0";
          }

          vars.push(["index=[", zeros.join(","), "]"].join(""));
        }

        for (var i = 0; i < proc.offsetArgs.length; ++i) {
          // Offset arguments used for stencil operations
          var off_arg = proc.offsetArgs[i];
          var init_string = [];

          for (var j = 0; j < off_arg.offset.length; ++j) {
            if (off_arg.offset[j] === 0) {
              continue;
            } else if (off_arg.offset[j] === 1) {
              init_string.push(["t", off_arg.array, "p", j].join(""));
            } else {
              init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
            }
          }

          if (init_string.length === 0) {
            vars.push("q" + i + "=0");
          } else {
            vars.push(["q", i, "=", init_string.join("+")].join(""));
          }
        } //Prepare this variables


        var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
        vars = vars.concat(thisVars);

        if (vars.length > 0) {
          code.push("var " + vars.join(","));
        }

        for (var i = 0; i < proc.arrayArgs.length; ++i) {
          code.push("p" + i + "|=0");
        } //Inline prelude


        if (proc.pre.body.length > 3) {
          code.push(processBlock(proc.pre, proc, dtypes));
        } //Process body


        var body = processBlock(proc.body, proc, dtypes);
        var matched = countMatches(loopOrders);

        if (matched < dimension) {
          code.push(outerFill(matched, loopOrders[0], proc, body)); // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
        } else {
          code.push(innerFill(loopOrders[0], proc, body));
        } //Inline epilog


        if (proc.post.body.length > 3) {
          code.push(processBlock(proc.post, proc, dtypes));
        }

        if (proc.debug) {
          console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
        }

        var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
        var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
        return f();
      }

      module.exports = generateCWiseOp;

      /***/
    }),
/* 289 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      function unique_pred(list, compare) {
        var ptr = 1,
          len = list.length,
          a = list[0],
          b = list[0];

        for (var i = 1; i < len; ++i) {
          b = a;
          a = list[i];

          if (compare(a, b)) {
            if (i === ptr) {
              ptr++;
              continue;
            }

            list[ptr++] = a;
          }
        }

        list.length = ptr;
        return list;
      }

      function unique_eq(list) {
        var ptr = 1,
          len = list.length,
          a = list[0],
          b = list[0];

        for (var i = 1; i < len; ++i, b = a) {
          b = a;
          a = list[i];

          if (a !== b) {
            if (i === ptr) {
              ptr++;
              continue;
            }

            list[ptr++] = a;
          }
        }

        list.length = ptr;
        return list;
      }

      function unique(list, compare, sorted) {
        if (list.length === 0) {
          return list;
        }

        if (compare) {
          if (!sorted) {
            list.sort(compare);
          }

          return unique_pred(list, compare);
        }

        if (!sorted) {
          list.sort();
        }

        return unique_eq(list);
      }

      module.exports = unique;

      /***/
    }),
/* 290 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (process) {
        var Stream = __webpack_require__(291); // through
        //
        // a stream that does nothing but re-emit the input.
        // useful for aggregating a series of changing but not ending streams into one stream)


        exports = module.exports = through;
        through.through = through; //create a readable writable stream.

        function through(write, end, opts) {
          write = write || function (data) {
            this.queue(data);
          };

          end = end || function () {
            this.queue(null);
          };

          var ended = false,
            destroyed = false,
            buffer = [],
            _ended = false;
          var stream = new Stream();
          stream.readable = stream.writable = true;
          stream.paused = false; //  stream.autoPause   = !(opts && opts.autoPause   === false)

          stream.autoDestroy = !(opts && opts.autoDestroy === false);

          stream.write = function (data) {
            write.call(this, data);
            return !stream.paused;
          };

          function drain() {
            while (buffer.length && !stream.paused) {
              var data = buffer.shift();
              if (null === data) return stream.emit('end'); else stream.emit('data', data);
            }
          }

          stream.queue = stream.push = function (data) {
            //    console.error(ended)
            if (_ended) return stream;
            if (data === null) _ended = true;
            buffer.push(data);
            drain();
            return stream;
          }; //this will be registered as the first 'end' listener
          //must call destroy next tick, to make sure we're after any
          //stream piped from here.
          //this is only a problem if end is not emitted synchronously.
          //a nicer way to do this is to make sure this is the last listener for 'end'


          stream.on('end', function () {
            stream.readable = false;
            if (!stream.writable && stream.autoDestroy) process.nextTick(function () {
              stream.destroy();
            });
          });

          function _end() {
            stream.writable = false;
            end.call(stream);
            if (!stream.readable && stream.autoDestroy) stream.destroy();
          }

          stream.end = function (data) {
            if (ended) return;
            ended = true;
            if (arguments.length) stream.write(data);

            _end(); // will emit or queue


            return stream;
          };

          stream.destroy = function () {
            if (destroyed) return;
            destroyed = true;
            ended = true;
            buffer.length = 0;
            stream.writable = stream.readable = false;
            stream.emit('close');
            return stream;
          };

          stream.pause = function () {
            if (stream.paused) return;
            stream.paused = true;
            return stream;
          };

          stream.resume = function () {
            if (stream.paused) {
              stream.paused = false;
              stream.emit('resume');
            }

            drain(); //may have become paused again,
            //as drain emits 'data'.

            if (!stream.paused) stream.emit('drain');
            return stream;
          };

          return stream;
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(15)))

      /***/
    }),
/* 291 */
/***/ (function (module, exports, __webpack_require__) {

      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      module.exports = Stream;

      var EE = __webpack_require__(52).EventEmitter;

      var inherits = __webpack_require__(22);

      inherits(Stream, EE);
      Stream.Readable = __webpack_require__(53);
      Stream.Writable = __webpack_require__(301);
      Stream.Duplex = __webpack_require__(302);
      Stream.Transform = __webpack_require__(303);
      Stream.PassThrough = __webpack_require__(304); // Backwards-compat with node 0.4.x

      Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
      // part of this class) is overridden in the Readable class.

      function Stream() {
        EE.call(this);
      }

      Stream.prototype.pipe = function (dest, options) {
        var source = this;

        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }

        source.on('data', ondata);

        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }

        dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
        // source gets the 'end' or 'close' events.  Only dest.end() once.

        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on('end', onend);
          source.on('close', onclose);
        }

        var didOnEnd = false;

        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }

        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === 'function') dest.destroy();
        } // don't leave dangling pipes when there are errors.


        function onerror(er) {
          cleanup();

          if (EE.listenerCount(this, 'error') === 0) {
            throw er; // Unhandled stream error in pipe.
          }
        }

        source.on('error', onerror);
        dest.on('error', onerror); // remove all the event listeners that were added.

        function cleanup() {
          source.removeListener('data', ondata);
          dest.removeListener('drain', ondrain);
          source.removeListener('end', onend);
          source.removeListener('close', onclose);
          source.removeListener('error', onerror);
          dest.removeListener('error', onerror);
          source.removeListener('end', cleanup);
          source.removeListener('close', cleanup);
          dest.removeListener('close', cleanup);
        }

        source.on('end', cleanup);
        source.on('close', cleanup);
        dest.on('close', cleanup);
        dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

        return dest;
      };

      /***/
    }),
/* 292 */
/***/ (function (module, exports) {

      var toString = {}.toString;

      module.exports = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
      };

      /***/
    }),
/* 293 */
/***/ (function (module, exports) {

      /* (ignored) */

      /***/
    }),
/* 294 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var Buffer = __webpack_require__(54).Buffer;

      var util = __webpack_require__(295);

      function copyBuffer(src, target, offset) {
        src.copy(target, offset);
      }

      module.exports = function () {
        function BufferList() {
          _classCallCheck(this, BufferList);

          this.head = null;
          this.tail = null;
          this.length = 0;
        }

        BufferList.prototype.push = function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry; else this.head = entry;
          this.tail = entry;
          ++this.length;
        };

        BufferList.prototype.unshift = function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        };

        BufferList.prototype.shift = function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next;
          --this.length;
          return ret;
        };

        BufferList.prototype.clear = function clear() {
          this.head = this.tail = null;
          this.length = 0;
        };

        BufferList.prototype.join = function join(s) {
          if (this.length === 0) return '';
          var p = this.head;
          var ret = '' + p.data;

          while (p = p.next) {
            ret += s + p.data;
          }

          return ret;
        };

        BufferList.prototype.concat = function concat(n) {
          if (this.length === 0) return Buffer.alloc(0);
          if (this.length === 1) return this.head.data;
          var ret = Buffer.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;

          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }

          return ret;
        };

        return BufferList;
      }();

      if (util && util.inspect && util.inspect.custom) {
        module.exports.prototype[util.inspect.custom] = function () {
          var obj = util.inspect({
            length: this.length
          });
          return this.constructor.name + ' ' + obj;
        };
      }

      /***/
    }),
/* 295 */
/***/ (function (module, exports) {

      /* (ignored) */

      /***/
    }),
/* 296 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (global) {
        var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
        var apply = Function.prototype.apply; // DOM APIs, for completeness

        exports.setTimeout = function () {
          return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
        };

        exports.setInterval = function () {
          return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
        };

        exports.clearTimeout = exports.clearInterval = function (timeout) {
          if (timeout) {
            timeout.close();
          }
        };

        function Timeout(id, clearFn) {
          this._id = id;
          this._clearFn = clearFn;
        }

        Timeout.prototype.unref = Timeout.prototype.ref = function () { };

        Timeout.prototype.close = function () {
          this._clearFn.call(scope, this._id);
        }; // Does not start the time, just sets up the members needed.


        exports.enroll = function (item, msecs) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = msecs;
        };

        exports.unenroll = function (item) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = -1;
        };

        exports._unrefActive = exports.active = function (item) {
          clearTimeout(item._idleTimeoutId);
          var msecs = item._idleTimeout;

          if (msecs >= 0) {
            item._idleTimeoutId = setTimeout(function onTimeout() {
              if (item._onTimeout) item._onTimeout();
            }, msecs);
          }
        }; // setimmediate attaches itself to the global object


        __webpack_require__(297); // On some exotic environments, it's not clear which object `setimmediate` was
        // able to install onto.  Search each possibility in the same order as the
        // `setimmediate` library.


        exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
        exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12)))

      /***/
    }),
/* 297 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (global, process) {
        (function (global, undefined) {
          "use strict";

          if (global.setImmediate) {
            return;
          }

          var nextHandle = 1; // Spec says greater than zero

          var tasksByHandle = {};
          var currentlyRunningATask = false;
          var doc = global.document;
          var registerImmediate;

          function setImmediate(callback) {
            // Callback can either be a function or a string
            if (typeof callback !== "function") {
              callback = new Function("" + callback);
            } // Copy function arguments


            var args = new Array(arguments.length - 1);

            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i + 1];
            } // Store and register the task


            var task = {
              callback: callback,
              args: args
            };
            tasksByHandle[nextHandle] = task;
            registerImmediate(nextHandle);
            return nextHandle++;
          }

          function clearImmediate(handle) {
            delete tasksByHandle[handle];
          }

          function run(task) {
            var callback = task.callback;
            var args = task.args;

            switch (args.length) {
              case 0:
                callback();
                break;

              case 1:
                callback(args[0]);
                break;

              case 2:
                callback(args[0], args[1]);
                break;

              case 3:
                callback(args[0], args[1], args[2]);
                break;

              default:
                callback.apply(undefined, args);
                break;
            }
          }

          function runIfPresent(handle) {
            // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
            // So if we're currently running a task, we'll need to delay this invocation.
            if (currentlyRunningATask) {
              // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
              // "too much recursion" error.
              setTimeout(runIfPresent, 0, handle);
            } else {
              var task = tasksByHandle[handle];

              if (task) {
                currentlyRunningATask = true;

                try {
                  run(task);
                } finally {
                  clearImmediate(handle);
                  currentlyRunningATask = false;
                }
              }
            }
          }

          function installNextTickImplementation() {
            registerImmediate = function (handle) {
              process.nextTick(function () {
                runIfPresent(handle);
              });
            };
          }

          function canUsePostMessage() {
            // The test against `importScripts` prevents this implementation from being installed inside a web worker,
            // where `global.postMessage` means something completely different and can't be used for this purpose.
            if (global.postMessage && !global.importScripts) {
              var postMessageIsAsynchronous = true;
              var oldOnMessage = global.onmessage;

              global.onmessage = function () {
                postMessageIsAsynchronous = false;
              };

              global.postMessage("", "*");
              global.onmessage = oldOnMessage;
              return postMessageIsAsynchronous;
            }
          }

          function installPostMessageImplementation() {
            // Installs an event handler on `global` for the `message` event: see
            // * https://developer.mozilla.org/en/DOM/window.postMessage
            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
            var messagePrefix = "setImmediate$" + Math.random() + "$";

            var onGlobalMessage = function (event) {
              if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
              }
            };

            if (global.addEventListener) {
              global.addEventListener("message", onGlobalMessage, false);
            } else {
              global.attachEvent("onmessage", onGlobalMessage);
            }

            registerImmediate = function (handle) {
              global.postMessage(messagePrefix + handle, "*");
            };
          }

          function installMessageChannelImplementation() {
            var channel = new MessageChannel();

            channel.port1.onmessage = function (event) {
              var handle = event.data;
              runIfPresent(handle);
            };

            registerImmediate = function (handle) {
              channel.port2.postMessage(handle);
            };
          }

          function installReadyStateChangeImplementation() {
            var html = doc.documentElement;

            registerImmediate = function (handle) {
              // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
              // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
              var script = doc.createElement("script");

              script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
              };

              html.appendChild(script);
            };
          }

          function installSetTimeoutImplementation() {
            registerImmediate = function (handle) {
              setTimeout(runIfPresent, 0, handle);
            };
          } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


          var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
          attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

          if ({}.toString.call(global.process) === "[object process]") {
            // For Node.js before 0.9
            installNextTickImplementation();
          } else if (canUsePostMessage()) {
            // For non-IE10 modern browsers
            installPostMessageImplementation();
          } else if (global.MessageChannel) {
            // For web workers, where supported
            installMessageChannelImplementation();
          } else if (doc && "onreadystatechange" in doc.createElement("script")) {
            // For IE 6–8
            installReadyStateChangeImplementation();
          } else {
            // For older browsers
            installSetTimeoutImplementation();
          }

          attachTo.setImmediate = setImmediate;
          attachTo.clearImmediate = clearImmediate;
        })(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12), __webpack_require__(15)))

      /***/
    }),
/* 298 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (global) {/**
 * Module exports.
 */
        module.exports = deprecate;
        /**
         * Mark that a method should not be used.
         * Returns a modified function which warns once by default.
         *
         * If `localStorage.noDeprecation = true` is set, then it is a no-op.
         *
         * If `localStorage.throwDeprecation = true` is set, then deprecated functions
         * will throw an Error when invoked.
         *
         * If `localStorage.traceDeprecation = true` is set, then deprecated functions
         * will invoke `console.trace()` instead of `console.error()`.
         *
         * @param {Function} fn - the function to deprecate
         * @param {String} msg - the string to print to the console when `fn` is invoked
         * @returns {Function} a new "deprecated" version of `fn`
         * @api public
         */

        function deprecate(fn, msg) {
          if (config('noDeprecation')) {
            return fn;
          }

          var warned = false;

          function deprecated() {
            if (!warned) {
              if (config('throwDeprecation')) {
                throw new Error(msg);
              } else if (config('traceDeprecation')) {
                console.trace(msg);
              } else {
                console.warn(msg);
              }

              warned = true;
            }

            return fn.apply(this, arguments);
          }

          return deprecated;
        }
        /**
         * Checks `localStorage` for boolean values for the given `name`.
         *
         * @param {String} name
         * @returns {Boolean}
         * @api private
         */


        function config(name) {
          // accessing global.localStorage can trigger a DOMException in sandboxed iframes
          try {
            if (!global.localStorage) return false;
          } catch (_) {
            return false;
          }

          var val = global.localStorage[name];
          if (null == val) return false;
          return String(val).toLowerCase() === 'true';
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12)))

      /***/
    }),
/* 299 */
/***/ (function (module, exports, __webpack_require__) {

      /* eslint-disable node/no-deprecated-api */
      var buffer = __webpack_require__(26);

      var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }

      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        // Copy properties from require('buffer')
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }

      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }

      SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

      copyProps(Buffer, SafeBuffer);

      SafeBuffer.from = function (arg, encodingOrOffset, length) {
        if (typeof arg === 'number') {
          throw new TypeError('Argument must not be a number');
        }

        return Buffer(arg, encodingOrOffset, length);
      };

      SafeBuffer.alloc = function (size, fill, encoding) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        var buf = Buffer(size);

        if (fill !== undefined) {
          if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }

        return buf;
      };

      SafeBuffer.allocUnsafe = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        return Buffer(size);
      };

      SafeBuffer.allocUnsafeSlow = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        return buffer.SlowBuffer(size);
      };

      /***/
    }),
/* 300 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      // a passthrough stream.
      // basically just the most minimal sort of Transform stream.
      // Every written chunk gets output as-is.


      module.exports = PassThrough;

      var Transform = __webpack_require__(98);
      /*<replacement>*/


      var util = Object.create(__webpack_require__(27));
      util.inherits = __webpack_require__(22);
      /*</replacement>*/

      util.inherits(PassThrough, Transform);

      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }

      PassThrough.prototype._transform = function (chunk, encoding, cb) {
        cb(null, chunk);
      };

      /***/
    }),
/* 301 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(55);

      /***/
    }),
/* 302 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(16);

      /***/
    }),
/* 303 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(53).Transform;

      /***/
    }),
/* 304 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(53).PassThrough;

      /***/
    }),
/* 305 */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (Buffer) {/**
 * Module exports.
 */
        module.exports = dataUriToBuffer;
        /**
         * Returns a `Buffer` instance from the given data URI `uri`.
         *
         * @param {String} uri Data URI to turn into a Buffer instance
         * @return {Buffer} Buffer instance from Data URI
         * @api public
         */

        function dataUriToBuffer(uri) {
          if (!/^data\:/i.test(uri)) {
            throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
          } // strip newlines


          uri = uri.replace(/\r?\n/g, ''); // split the URI up into the "metadata" and the "data" portions

          var firstComma = uri.indexOf(',');
          if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI'); // remove the "data:" scheme and parse the metadata

          var meta = uri.substring(5, firstComma).split(';');
          var base64 = false;
          var charset = 'US-ASCII';

          for (var i = 0; i < meta.length; i++) {
            if ('base64' == meta[i]) {
              base64 = true;
            } else if (0 == meta[i].indexOf('charset=')) {
              charset = meta[i].substring(8);
            }
          } // get the encoded data portion and decode URI-encoded chars


          var data = unescape(uri.substring(firstComma + 1));
          var encoding = base64 ? 'base64' : 'ascii';
          var buffer = new Buffer(data, encoding); // set `.type` property to MIME type

          buffer.type = meta[0] || 'text/plain'; // set the `.charset` property

          buffer.charset = charset;
          return buffer;
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(26).Buffer))

      /***/
    }),
/* 306 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      function interp1d(arr, x) {
        var ix = Math.floor(x),
          fx = x - ix,
          s0 = 0 <= ix && ix < arr.shape[0],
          s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
          w0 = s0 ? +arr.get(ix) : 0.0,
          w1 = s1 ? +arr.get(ix + 1) : 0.0;
        return (1.0 - fx) * w0 + fx * w1;
      }

      function interp2d(arr, x, y) {
        var ix = Math.floor(x),
          fx = x - ix,
          s0 = 0 <= ix && ix < arr.shape[0],
          s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
          iy = Math.floor(y),
          fy = y - iy,
          t0 = 0 <= iy && iy < arr.shape[1],
          t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
          w00 = s0 && t0 ? arr.get(ix, iy) : 0.0,
          w01 = s0 && t1 ? arr.get(ix, iy + 1) : 0.0,
          w10 = s1 && t0 ? arr.get(ix + 1, iy) : 0.0,
          w11 = s1 && t1 ? arr.get(ix + 1, iy + 1) : 0.0;
        return (1.0 - fy) * ((1.0 - fx) * w00 + fx * w10) + fy * ((1.0 - fx) * w01 + fx * w11);
      }

      function interp3d(arr, x, y, z) {
        var ix = Math.floor(x),
          fx = x - ix,
          s0 = 0 <= ix && ix < arr.shape[0],
          s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
          iy = Math.floor(y),
          fy = y - iy,
          t0 = 0 <= iy && iy < arr.shape[1],
          t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
          iz = Math.floor(z),
          fz = z - iz,
          u0 = 0 <= iz && iz < arr.shape[2],
          u1 = 0 <= iz + 1 && iz + 1 < arr.shape[2],
          w000 = s0 && t0 && u0 ? arr.get(ix, iy, iz) : 0.0,
          w010 = s0 && t1 && u0 ? arr.get(ix, iy + 1, iz) : 0.0,
          w100 = s1 && t0 && u0 ? arr.get(ix + 1, iy, iz) : 0.0,
          w110 = s1 && t1 && u0 ? arr.get(ix + 1, iy + 1, iz) : 0.0,
          w001 = s0 && t0 && u1 ? arr.get(ix, iy, iz + 1) : 0.0,
          w011 = s0 && t1 && u1 ? arr.get(ix, iy + 1, iz + 1) : 0.0,
          w101 = s1 && t0 && u1 ? arr.get(ix + 1, iy, iz + 1) : 0.0,
          w111 = s1 && t1 && u1 ? arr.get(ix + 1, iy + 1, iz + 1) : 0.0;
        return (1.0 - fz) * ((1.0 - fy) * ((1.0 - fx) * w000 + fx * w100) + fy * ((1.0 - fx) * w010 + fx * w110)) + fz * ((1.0 - fy) * ((1.0 - fx) * w001 + fx * w101) + fy * ((1.0 - fx) * w011 + fx * w111));
      }

      function interpNd(arr) {
        var d = arr.shape.length | 0,
          ix = new Array(d),
          fx = new Array(d),
          s0 = new Array(d),
          s1 = new Array(d),
          i,
          t;

        for (i = 0; i < d; ++i) {
          t = +arguments[i + 1];
          ix[i] = Math.floor(t);
          fx[i] = t - ix[i];
          s0[i] = 0 <= ix[i] && ix[i] < arr.shape[i];
          s1[i] = 0 <= ix[i] + 1 && ix[i] + 1 < arr.shape[i];
        }

        var r = 0.0,
          j,
          w,
          idx;

        i_loop: for (i = 0; i < 1 << d; ++i) {
          w = 1.0;
          idx = arr.offset;

          for (j = 0; j < d; ++j) {
            if (i & 1 << j) {
              if (!s1[j]) {
                continue i_loop;
              }

              w *= fx[j];
              idx += arr.stride[j] * (ix[j] + 1);
            } else {
              if (!s0[j]) {
                continue i_loop;
              }

              w *= 1.0 - fx[j];
              idx += arr.stride[j] * ix[j];
            }
          }

          r += w * arr.data[idx];
        }

        return r;
      }

      function interpolate(arr, x, y, z) {
        switch (arr.shape.length) {
          case 0:
            return 0.0;

          case 1:
            return interp1d(arr, x);

          case 2:
            return interp2d(arr, x, y);

          case 3:
            return interp3d(arr, x, y, z);

          default:
            return interpNd.apply(undefined, arguments);
        }
      }

      module.exports = interpolate;
      module.exports.d1 = interp1d;
      module.exports.d2 = interp2d;
      module.exports.d3 = interp3d;

      /***/
    }),
/* 307 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
      // ESM COMPAT FLAG
      __webpack_require__.r(__webpack_exports__);

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function () { return /* reexport */ barcode_decoder; });
      __webpack_require__.d(__webpack_exports__, "BarcodeReader", function () { return /* reexport */ barcode_reader; });
      __webpack_require__.d(__webpack_exports__, "CameraAccess", function () { return /* reexport */ camera_access; });
      __webpack_require__.d(__webpack_exports__, "ImageDebug", function () { return /* reexport */ image_debug["a" /* default */]; });
      __webpack_require__.d(__webpack_exports__, "ImageWrapper", function () { return /* reexport */ image_wrapper["a" /* default */]; });
      __webpack_require__.d(__webpack_exports__, "ResultCollector", function () { return /* reexport */ result_collector; });

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
      var helpers_typeof = __webpack_require__(23);
      var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

      // EXTERNAL MODULE: ./src/common/typedefs.js
      var typedefs = __webpack_require__(106);

      // EXTERNAL MODULE: ./src/common/image_wrapper.ts
      var image_wrapper = __webpack_require__(11);

      // CONCATENATED MODULE: ./src/decoder/bresenham.js
      var Bresenham = {};
      var Slope = {
        DIR: {
          UP: 1,
          DOWN: -1
        }
      };
      /**
       * Scans a line of the given image from point p1 to p2 and returns a result object containing
       * gray-scale values (0-255) of the underlying pixels in addition to the min
       * and max values.
       * @param {Object} imageWrapper
       * @param {Object} p1 The start point {x,y}
       * @param {Object} p2 The end point {x,y}
       * @returns {line, min, max}
       */

      Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
        /* eslint-disable no-bitwise */
        var x0 = p1.x | 0;
        var y0 = p1.y | 0;
        var x1 = p2.x | 0;
        var y1 = p2.y | 0;
        /* eslint-disable no-bitwise */

        var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
        var error;
        var y;
        var tmp;
        var x;
        var line = [];
        var imageData = imageWrapper.data;
        var width = imageWrapper.size.x;
        var val;
        var min = 255;
        var max = 0;

        function read(a, b) {
          val = imageData[b * width + a];
          min = val < min ? val : min;
          max = val > max ? val : max;
          line.push(val);
        }

        if (steep) {
          tmp = x0;
          x0 = y0;
          y0 = tmp;
          tmp = x1;
          x1 = y1;
          y1 = tmp;
        }

        if (x0 > x1) {
          tmp = x0;
          x0 = x1;
          x1 = tmp;
          tmp = y0;
          y0 = y1;
          y1 = tmp;
        }

        var deltaX = x1 - x0;
        var deltaY = Math.abs(y1 - y0);
        error = deltaX / 2 | 0;
        y = y0;
        var yStep = y0 < y1 ? 1 : -1;

        for (x = x0; x < x1; x++) {
          if (steep) {
            read(y, x);
          } else {
            read(x, y);
          }

          error -= deltaY;

          if (error < 0) {
            y += yStep;
            error += deltaX;
          }
        }

        return {
          line: line,
          min: min,
          max: max
        };
      };
      /**
       * Converts the result from getBarcodeLine into a binary representation
       * also considering the frequency and slope of the signal for more robust results
       * @param {Object} result {line, min, max}
       */


      Bresenham.toBinaryLine = function (result) {
        var min = result.min;
        var max = result.max;
        var line = result.line;
        var slope;
        var slope2;
        var center = min + (max - min) / 2;
        var extrema = [];
        var currentDir;
        var dir;
        var threshold = (max - min) / 12;
        var rThreshold = -threshold;
        var i;
        var j; // 1. find extrema

        currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
        extrema.push({
          pos: 0,
          val: line[0]
        });

        for (i = 0; i < line.length - 2; i++) {
          slope = line[i + 1] - line[i];
          slope2 = line[i + 2] - line[i + 1];

          if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
            dir = Slope.DIR.DOWN;
          } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
            dir = Slope.DIR.UP;
          } else {
            dir = currentDir;
          }

          if (currentDir !== dir) {
            extrema.push({
              pos: i,
              val: line[i]
            });
            currentDir = dir;
          }
        }

        extrema.push({
          pos: line.length,
          val: line[line.length - 1]
        });

        for (j = extrema[0].pos; j < extrema[1].pos; j++) {
          line[j] = line[j] > center ? 0 : 1;
        } // iterate over extrema and convert to binary based on avg between minmax


        for (i = 1; i < extrema.length - 1; i++) {
          if (extrema[i + 1].val > extrema[i].val) {
            threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
          } else {
            threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
          }

          for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
            line[j] = line[j] > threshold ? 0 : 1;
          }
        }

        return {
          line: line,
          threshold: threshold
        };
      };
      /**
       * Used for development only
       */


      Bresenham.debug = {
        printFrequency: function printFrequency(line, canvas) {
          var i;
          var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

          canvas.width = line.length; // eslint-disable-next-line no-param-reassign

          canvas.height = 256;
          ctx.beginPath();
          ctx.strokeStyle = 'blue';

          for (i = 0; i < line.length; i++) {
            ctx.moveTo(i, 255);
            ctx.lineTo(i, 255 - line[i]);
          }

          ctx.stroke();
          ctx.closePath();
        },
        printPattern: function printPattern(line, canvas) {
          var ctx = canvas.getContext('2d');
          var i; // eslint-disable-next-line no-param-reassign

          canvas.width = line.length;
          ctx.fillColor = 'black';

          for (i = 0; i < line.length; i++) {
            if (line[i] === 1) {
              ctx.fillRect(i, 0, 1, 100);
            }
          }
        }
      };
/* harmony default export */ var bresenham = (Bresenham);
      // EXTERNAL MODULE: ./src/common/image_debug.ts
      var image_debug = __webpack_require__(9);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
      var classCallCheck = __webpack_require__(3);
      var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
      var createClass = __webpack_require__(4);
      var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
      var assertThisInitialized = __webpack_require__(1);
      var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
      var inherits = __webpack_require__(6);
      var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
      var possibleConstructorReturn = __webpack_require__(5);
      var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
      var getPrototypeOf = __webpack_require__(2);
      var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
      var defineProperty = __webpack_require__(0);
      var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

      // EXTERNAL MODULE: ./src/common/array_helper.ts
      var array_helper = __webpack_require__(10);

      // CONCATENATED MODULE: ./src/reader/barcode_reader.ts




      var BarcodeDirection;

      (function (BarcodeDirection) {
        BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
        BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
      })(BarcodeDirection || (BarcodeDirection = {}));

      ;
      ;
      ;
      ;
      ;
      ;
      var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
        createClass_default()(BarcodeReader, null, [{
          key: "Exception",
          get: function get() {
            return {
              StartNotFoundException: 'Start-Info was not found!',
              CodeNotFoundException: 'Code could not be found!',
              PatternNotFoundException: 'Pattern could not be found!'
            };
          }
        }]);

        function BarcodeReader(config, supplements) {
          classCallCheck_default()(this, BarcodeReader);

          defineProperty_default()(this, "_row", []);

          defineProperty_default()(this, "config", {});

          defineProperty_default()(this, "supplements", []);

          defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

          defineProperty_default()(this, "FORMAT", 'unknown');

          defineProperty_default()(this, "CONFIG_KEYS", {});

          this._row = [];
          this.config = config || {};

          if (supplements) {
            this.supplements = supplements;
          }

          return this;
        }

        createClass_default()(BarcodeReader, [{
          key: "_nextUnset",
          value: function _nextUnset(line) {
            var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            for (var i = start; i < line.length; i++) {
              if (!line[i]) return i;
            }

            return line.length;
          }
        }, {
          key: "_matchPattern",
          value: function _matchPattern(counter, code, maxSingleError) {
            var error = 0;
            var singleError = 0;
            var sum = 0;
            var modulo = 0;
            var barWidth = 0;
            var count = 0;
            var scaled = 0;
            maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

            for (var i = 0; i < counter.length; i++) {
              sum += counter[i];
              modulo += code[i];
            }

            if (sum < modulo) {
              return Number.MAX_VALUE;
            }

            barWidth = sum / modulo;
            maxSingleError *= barWidth;

            for (var _i = 0; _i < counter.length; _i++) {
              count = counter[_i];
              scaled = code[_i] * barWidth;
              singleError = Math.abs(count - scaled) / scaled;

              if (singleError > maxSingleError) {
                return Number.MAX_VALUE;
              }

              error += singleError;
            }

            return error / modulo;
          }
        }, {
          key: "_nextSet",
          value: function _nextSet(line) {
            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            for (var i = offset; i < line.length; i++) {
              if (line[i]) return i;
            }

            return line.length;
          }
        }, {
          key: "_correctBars",
          value: function _correctBars(counter, correction, indices) {
            var length = indices.length;
            var tmp = 0;

            while (length--) {
              tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

              if (tmp > 1) {
                counter[indices[length]] = tmp;
              }
            }
          }
        }, {
          key: "decodePattern",
          value: function decodePattern(pattern) {
            // console.warn('* decodePattern', pattern);
            this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

            var result = this._decode(); // console.warn('* first result=', result);


            if (result === null) {
              this._row.reverse();

              result = this._decode(); // console.warn('* reversed result=', result);

              if (result) {
                result.direction = BarcodeDirection.Reverse;
                result.start = this._row.length - result.start;
                result.end = this._row.length - result.end;
              }
            } else {
              result.direction = BarcodeDirection.Forward;
            }

            if (result) {
              result.format = this.FORMAT;
            } // console.warn('* returning', result);


            return result;
          }
        }, {
          key: "_matchRange",
          value: function _matchRange(start, end, value) {
            var i;
            start = start < 0 ? 0 : start;

            for (i = start; i < end; i++) {
              if (this._row[i] !== value) {
                return false;
              }
            }

            return true;
          }
        }, {
          key: "_fillCounters",
          value: function _fillCounters() {
            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
            var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
            var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var counters = [];
            var counterPos = 0;
            counters[counterPos] = 0;

            for (var i = offset; i < end; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counters[counterPos]++;
              } else {
                counterPos++;
                counters[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return counters;
          }
        }, {
          key: "_toCounters",
          value: function _toCounters(start, counters) {
            var numCounters = counters.length;
            var end = this._row.length;
            var isWhite = !this._row[start];
            var counterPos = 0;
            array_helper["a" /* default */].init(counters, 0);

            for (var i = start; i < end; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counters[counterPos]++;
              } else {
                counterPos++;

                if (counterPos === numCounters) {
                  break;
                } else {
                  counters[counterPos] = 1;
                  isWhite = !isWhite;
                }
              }
            }

            return counters;
          }
        }]);

        return BarcodeReader;
      }();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
      // CONCATENATED MODULE: ./src/reader/code_128_reader.ts








      function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }



      var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
        inherits_default()(Code128Reader, _BarcodeReader);

        var _super = _createSuper(Code128Reader);

        function Code128Reader() {
          var _this;

          classCallCheck_default()(this, Code128Reader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

          defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

          defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

          defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

          defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

          defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

          defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

          defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

          defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

          defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

          defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

          defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
            bar: [0, 2, 4],
            space: [1, 3, 5]
          });

          return _this;
        }

        createClass_default()(Code128Reader, [{
          key: "_decodeCode",
          value: function _decodeCode(start, correction) {
            var bestMatch = {
              error: Number.MAX_VALUE,
              code: -1,
              start: start,
              end: start,
              correction: {
                bar: 1,
                space: 1
              }
            };
            var counter = [0, 0, 0, 0, 0, 0];
            var offset = start;
            var isWhite = !this._row[offset];
            var counterPos = 0;

            for (var i = offset; i < this._row.length; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos]++;
              } else {
                if (counterPos === counter.length - 1) {
                  if (correction) {
                    this._correct(counter, correction);
                  }

                  for (var code = 0; code < this.CODE_PATTERN.length; code++) {
                    var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

                    if (error < bestMatch.error) {
                      bestMatch.code = code;
                      bestMatch.error = error;
                    }
                  }

                  bestMatch.end = i;

                  if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
                    return null;
                  }

                  if (this.CODE_PATTERN[bestMatch.code]) {
                    bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                  }

                  return bestMatch;
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return null;
          }
        }, {
          key: "_correct",
          value: function _correct(counter, correction) {
            this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

            this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
          }
        }, {
          key: "_findStart",
          // TODO: _findStart and decodeCode share similar code, can we re-use some?
          value: function _findStart() {
            var counter = [0, 0, 0, 0, 0, 0];

            var offset = this._nextSet(this._row);

            var bestMatch = {
              error: Number.MAX_VALUE,
              code: -1,
              start: 0,
              end: 0,
              correction: {
                bar: 1,
                space: 1
              }
            };
            var isWhite = false;
            var counterPos = 0;

            for (var i = offset; i < this._row.length; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos]++;
              } else {
                if (counterPos === counter.length - 1) {
                  var sum = counter.reduce(function (prev, next) {
                    return prev + next;
                  }, 0);

                  for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
                    var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

                    if (error < bestMatch.error) {
                      bestMatch.code = code;
                      bestMatch.error = error;
                    }
                  }

                  if (bestMatch.error < this.AVG_CODE_ERROR) {
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                    return bestMatch;
                  }

                  for (var j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                  }

                  counter[4] = 0;
                  counter[5] = 0;
                  counterPos--;
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return null;
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            var _this2 = this;

            var startInfo = this._findStart();

            if (startInfo === null) {
              return null;
            } // var self = this,
            //     done = false,
            //     result = [],
            //     multiplier = 0,
            //     checksum = 0,
            //     codeset,
            //     rawResult = [],
            //     decodedCodes = [],
            //     shiftNext = false,
            //     unshift,
            //     removeLastCharacter = true;


            var code = {
              code: startInfo.code,
              start: startInfo.start,
              end: startInfo.end,
              correction: {
                bar: startInfo.correction.bar,
                space: startInfo.correction.space
              }
            };
            var decodedCodes = [];
            decodedCodes.push(code);
            var checksum = code.code;

            var codeset = function (c) {
              switch (c) {
                case _this2.START_CODE_A:
                  return _this2.CODE_A;

                case _this2.START_CODE_B:
                  return _this2.CODE_B;

                case _this2.START_CODE_C:
                  return _this2.CODE_C;

                default:
                  return null;
              }
            }(code.code);

            var done = false;
            var shiftNext = false;
            var unshift = shiftNext;
            var removeLastCharacter = true;
            var multiplier = 0;
            var rawResult = [];
            var result = []; // TODO: i think this should be string only, but it creates problems if it is

            while (!done) {
              unshift = shiftNext;
              shiftNext = false;
              code = this._decodeCode(code.end, code.correction);

              if (code !== null) {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = true;
                }

                if (code.code !== this.STOP_CODE) {
                  rawResult.push(code.code);
                  multiplier++;
                  checksum += multiplier * code.code;
                }

                decodedCodes.push(code);

                switch (codeset) {
                  case this.CODE_A:
                    if (code.code < 64) {
                      result.push(String.fromCharCode(32 + code.code));
                    } else if (code.code < 96) {
                      result.push(String.fromCharCode(code.code - 64));
                    } else {
                      if (code.code !== this.STOP_CODE) {
                        removeLastCharacter = false;
                      }

                      switch (code.code) {
                        case this.CODE_SHIFT:
                          shiftNext = true;
                          codeset = this.CODE_B;
                          break;

                        case this.CODE_B:
                          codeset = this.CODE_B;
                          break;

                        case this.CODE_C:
                          codeset = this.CODE_C;
                          break;

                        case this.STOP_CODE:
                          done = true;
                          break;
                      }
                    }

                    break;

                  case this.CODE_B:
                    if (code.code < 96) {
                      result.push(String.fromCharCode(32 + code.code));
                    } else {
                      if (code.code !== this.STOP_CODE) {
                        removeLastCharacter = false;
                      }

                      switch (code.code) {
                        case this.CODE_SHIFT:
                          shiftNext = true;
                          codeset = this.CODE_A;
                          break;

                        case this.CODE_A:
                          codeset = this.CODE_A;
                          break;

                        case this.CODE_C:
                          codeset = this.CODE_C;
                          break;

                        case this.STOP_CODE:
                          done = true;
                          break;
                      }
                    }

                    break;

                  case this.CODE_C:
                    if (code.code < 100) {
                      result.push(code.code < 10 ? '0' + code.code : code.code);
                    } else {
                      if (code.code !== this.STOP_CODE) {
                        removeLastCharacter = false;
                      }

                      switch (code.code) {
                        case this.CODE_A:
                          codeset = this.CODE_A;
                          break;

                        case this.CODE_B:
                          codeset = this.CODE_B;
                          break;

                        case this.STOP_CODE:
                          done = true;
                          break;
                      }
                    }

                    break;
                }
              } else {
                done = true;
              }

              if (unshift) {
                codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
              }
            }

            if (code === null) {
              return null;
            }

            code.end = this._nextUnset(this._row, code.end);

            if (!this._verifyTrailingWhitespace(code)) {
              return null;
            }

            checksum -= multiplier * rawResult[rawResult.length - 1];

            if (checksum % 103 !== rawResult[rawResult.length - 1]) {
              return null;
            }

            if (!result.length) {
              return null;
            } // remove last code from result (checksum)


            if (removeLastCharacter) {
              result.splice(result.length - 1, 1);
            }

            return {
              code: result.join(''),
              start: startInfo.start,
              end: code.end,
              codeset: codeset,
              startInfo: startInfo,
              decodedCodes: decodedCodes,
              endInfo: code,
              format: this.FORMAT
            };
          }
        }, {
          key: "_verifyTrailingWhitespace",
          value: function _verifyTrailingWhitespace(endInfo) {
            var self = this,
              trailingWhitespaceEnd;
            trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

            if (trailingWhitespaceEnd < self._row.length) {
              if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                return endInfo;
              }
            }

            return null;
          }
        }, {
          key: "calculateCorrection",
          value: function calculateCorrection(expected, normalized, indices) {
            var length = indices.length,
              sumNormalized = 0,
              sumExpected = 0;

            while (length--) {
              sumExpected += expected[indices[length]];
              sumNormalized += normalized[indices[length]];
            }

            return sumExpected / sumNormalized;
          }
        }]);

        return Code128Reader;
      }(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
      // EXTERNAL MODULE: ./node_modules/lodash/merge.js
      var merge = __webpack_require__(17);
      var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

      // CONCATENATED MODULE: ./src/reader/ean_reader.ts








      function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

      function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }


      // const CODE_L_START = 0;

      var CODE_G_START = 10;

      var START_PATTERN = [1, 1, 1];
      var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

      var EXTENSION_START_PATTERN = [1, 1, 2];
      var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
      var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

      var AVG_CODE_ERROR = 0.48;

      var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
        inherits_default()(EANReader, _BarcodeReader);

        var _super = ean_reader_createSuper(EANReader);

        // TODO: does this need to be in the class?
        function EANReader(config, supplements) {
          var _this;

          classCallCheck_default()(this, EANReader);

          _this = _super.call(this, merge_default()({
            supplements: []
          }, config), supplements);

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

          defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

          defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

          return _this;
        }

        createClass_default()(EANReader, [{
          key: "_findPattern",
          value: function _findPattern(pattern, offset, isWhite, tryHarder) {
            var counter = new Array(pattern.length).fill(0);
            var bestMatch = {
              error: Number.MAX_VALUE,
              start: 0,
              end: 0
            };
            var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

            var counterPos = 0;

            if (!offset) {
              offset = this._nextSet(this._row);
            }

            var found = false;

            for (var i = offset; i < this._row.length; i++) {
              // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos] += 1;
              } else {
                if (counterPos === counter.length - 1) {
                  var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


                  if (error < epsilon && bestMatch.error && error < bestMatch.error) {
                    found = true;
                    bestMatch.error = error;
                    bestMatch.start = i - counter.reduce(function (sum, value) {
                      return sum + value;
                    }, 0);
                    bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

                    return bestMatch;
                  }

                  if (tryHarder) {
                    for (var j = 0; j < counter.length - 2; j++) {
                      counter[j] = counter[j + 2];
                    }

                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                  }
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
            } else {// console.warn('* return null');
            }

            return found ? bestMatch : null;
          } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

        }, {
          key: "_decodeCode",
          value: function _decodeCode(start, coderange) {
            // console.warn('* decodeCode', start, coderange);
            var counter = [0, 0, 0, 0];
            var offset = start;
            var bestMatch = {
              error: Number.MAX_VALUE,
              code: -1,
              start: start,
              end: start
            };
            var epsilon = AVG_CODE_ERROR;
            var isWhite = !this._row[offset];
            var counterPos = 0;

            if (!coderange) {
              // console.warn('* decodeCode before length');
              coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
            }

            var found = false;

            for (var i = offset; i < this._row.length; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos]++;
              } else {
                if (counterPos === counter.length - 1) {
                  for (var code = 0; code < coderange; code++) {
                    var error = this._matchPattern(counter, CODE_PATTERN[code]);

                    bestMatch.end = i;

                    if (error < bestMatch.error) {
                      bestMatch.code = code;
                      bestMatch.error = error;
                    }
                  }

                  if (bestMatch.error > epsilon) {
                    // console.warn('* return null');
                    return null;
                  } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


                  return bestMatch;
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return found ? bestMatch : null;
          }
        }, {
          key: "_findStart",
          value: function _findStart() {
            // console.warn('* findStart');
            var offset = this._nextSet(this._row);

            var startInfo = null;

            while (!startInfo) {
              startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

              if (!startInfo) {
                return null;
              }

              var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

              if (leadingWhitespaceStart >= 0) {
                if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                  // console.warn('* returning startInfo');
                  return startInfo;
                }
              }

              offset = startInfo.end;
              startInfo = null;
            } // console.warn('* returning null');


            return null;
          }
        }, {
          key: "_calculateFirstDigit",
          value: function _calculateFirstDigit(codeFrequency) {
            // console.warn('* calculateFirstDigit', codeFrequency);
            for (var i = 0; i < CODE_FREQUENCY.length; i++) {
              if (codeFrequency === CODE_FREQUENCY[i]) {
                // console.warn('* returning', i);
                return i;
              }
            } // console.warn('* return null');


            return null;
          }
        }, {
          key: "_decodePayload",
          value: function _decodePayload(inCode, result, decodedCodes) {
            // console.warn('* decodePayload', inCode, result, decodedCodes);
            var outCode = _objectSpread({}, inCode);

            var codeFrequency = 0x0;

            for (var i = 0; i < 6; i++) {
              outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

              if (!outCode) {
                // console.warn('* return null');
                return null;
              }

              if (outCode.code >= CODE_G_START) {
                outCode.code -= CODE_G_START;
                codeFrequency |= 1 << 5 - i;
              } else {
                codeFrequency |= 0 << 5 - i;
              }

              result.push(outCode.code);
              decodedCodes.push(outCode);
            }

            var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


            if (firstDigit === null) {
              // console.warn('* return null');
              return null;
            }

            result.unshift(firstDigit);

            var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


            if (middlePattern === null || !middlePattern.end) {
              // console.warn('* return null');
              return null;
            }

            decodedCodes.push(middlePattern);

            for (var _i = 0; _i < 6; _i++) {
              middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

              if (!middlePattern) {
                // console.warn('* return null');
                return null;
              }

              decodedCodes.push(middlePattern);
              result.push(middlePattern.code);
            } // console.warn('* end code=', JSON.stringify(middlePattern));
            // console.warn('* end result=', JSON.stringify(result));
            // console.warn('* end decodedCodes=', decodedCodes);


            return middlePattern;
          }
        }, {
          key: "_verifyTrailingWhitespace",
          value: function _verifyTrailingWhitespace(endInfo) {
            // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
            var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

            if (trailingWhitespaceEnd < this._row.length) {
              if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                // console.warn('* returning', JSON.stringify(endInfo));
                return endInfo;
              }
            } // console.warn('* return null');


            return null;
          }
        }, {
          key: "_findEnd",
          value: function _findEnd(offset, isWhite) {
            // console.warn('* findEnd', offset, isWhite);
            var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

            return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
          }
        }, {
          key: "_checksum",
          value: function _checksum(result) {
            // console.warn('* _checksum', result);
            var sum = 0;

            for (var i = result.length - 2; i >= 0; i -= 2) {
              sum += result[i];
            }

            sum *= 3;

            for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
              sum += result[_i2];
            } // console.warn('* end checksum', sum % 10 === 0);


            return sum % 10 === 0;
          }
        }, {
          key: "_decodeExtensions",
          value: function _decodeExtensions(offset) {
            var start = this._nextSet(this._row, offset);

            var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

            if (startInfo === null) {
              return null;
            } // console.warn('* decodeExtensions', this.supplements);
            // console.warn('* there are ', this.supplements.length, ' supplements');


            for (var i = 0; i < this.supplements.length; i++) {
              // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
              try {
                var result = this.supplements[i]._decode(this._row, startInfo.end); // console.warn('* decode result=', result);


                if (result !== null) {
                  return {
                    code: result.code,
                    start: start,
                    startInfo: startInfo,
                    end: result.end,
                    decodedCodes: result.decodedCodes,
                    format: this.supplements[i].FORMAT
                  };
                }
              } catch (err) {
                console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
              }
            } // console.warn('* end decodeExtensions');


            return null;
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            // console.warn('* decode', row);
            // console.warn('* decode', start);
            var result = new Array();
            var decodedCodes = new Array();
            var resultInfo = {};

            var startInfo = this._findStart();

            if (!startInfo) {
              return null;
            }

            var code = {
              start: startInfo.start,
              end: startInfo.end
            };
            decodedCodes.push(code);
            code = this._decodePayload(code, result, decodedCodes);

            if (!code) {
              return null;
            }

            code = this._findEnd(code.end, false);

            if (!code) {
              return null;
            }

            decodedCodes.push(code); // Checksum

            if (!this._checksum(result)) {
              return null;
            } // console.warn('* this.supplements=', this.supplements);


            if (this.supplements.length > 0) {
              var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


              if (!supplement) {
                return null;
              }

              if (!supplement.decodedCodes) {
                return null;
              }

              var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
              var endInfo = {
                start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
                end: lastCode.end
              };

              if (!this._verifyTrailingWhitespace(endInfo)) {
                return null;
              }

              resultInfo = {
                supplement: supplement,
                code: result.join('') + supplement.code
              };
            }

            return _objectSpread(_objectSpread({
              code: result.join(''),
              start: startInfo.start,
              end: code.end,
              startInfo: startInfo,
              decodedCodes: decodedCodes
            }, resultInfo), {}, {
              format: this.FORMAT
            });
          }
        }]);

        return EANReader;
      }(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
      var toConsumableArray = __webpack_require__(40);
      var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

      // CONCATENATED MODULE: ./src/reader/code_39_reader.ts









      function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }



      var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
      var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
        return _char.charCodeAt(0);
      }));
      var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
      var ASTERISK = 0x094;

      var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
        inherits_default()(Code39Reader, _BarcodeReader);

        var _super = code_39_reader_createSuper(Code39Reader);

        function Code39Reader() {
          var _this;

          classCallCheck_default()(this, Code39Reader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

          return _this;
        }

        createClass_default()(Code39Reader, [{
          key: "_findStart",
          value: function _findStart() {
            var offset = this._nextSet(this._row);

            var patternStart = offset;
            var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
            var counterPos = 0;
            var isWhite = false;

            for (var i = offset; i < this._row.length; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos]++;
              } else {
                if (counterPos === counter.length - 1) {
                  // find start pattern
                  if (this._toPattern(counter) === ASTERISK) {
                    var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

                    if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                      return {
                        start: patternStart,
                        end: i
                      };
                    }
                  }

                  patternStart += counter[0] + counter[1];

                  for (var j = 0; j < 7; j++) {
                    counter[j] = counter[j + 2];
                  }

                  counter[7] = 0;
                  counter[8] = 0;
                  counterPos--;
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return null;
          }
        }, {
          key: "_toPattern",
          value: function _toPattern(counters) {
            var numCounters = counters.length;
            var maxNarrowWidth = 0;
            var numWideBars = numCounters;
            var wideBarWidth = 0;

            while (numWideBars > 3) {
              maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
              numWideBars = 0;
              var pattern = 0;

              for (var i = 0; i < numCounters; i++) {
                if (counters[i] > maxNarrowWidth) {
                  pattern |= 1 << numCounters - 1 - i;
                  numWideBars++;
                  wideBarWidth += counters[i];
                }
              }

              if (numWideBars === 3) {
                for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
                  if (counters[_i] > maxNarrowWidth) {
                    numWideBars--;

                    if (counters[_i] * 2 >= wideBarWidth) {
                      return -1;
                    }
                  }
                }

                return pattern;
              }
            }

            return -1;
          }
        }, {
          key: "_findNextWidth",
          value: function _findNextWidth(counters, current) {
            var minWidth = Number.MAX_VALUE;

            for (var i = 0; i < counters.length; i++) {
              if (counters[i] < minWidth && counters[i] > current) {
                minWidth = counters[i];
              }
            }

            return minWidth;
          }
        }, {
          key: "_patternToChar",
          value: function _patternToChar(pattern) {
            for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
              if (CHARACTER_ENCODINGS[i] === pattern) {
                return String.fromCharCode(ALPHABET[i]);
              }
            }

            return null;
          }
        }, {
          key: "_verifyTrailingWhitespace",
          value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
            var patternSize = array_helper["a" /* default */].sum(counters);
            var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

            if (trailingWhitespaceEnd * 3 >= patternSize) {
              return true;
            }

            return false;
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
            var result = [];
            start = this._findStart();

            if (!start) {
              return null;
            }

            var nextStart = this._nextSet(this._row, start.end);

            var decodedChar;
            var lastStart;

            do {
              counters = this._toCounters(nextStart, counters);

              var pattern = this._toPattern(counters);

              if (pattern < 0) {
                return null;
              }

              decodedChar = this._patternToChar(pattern);

              if (decodedChar === null) {
                return null;
              }

              result.push(decodedChar);
              lastStart = nextStart;
              nextStart += array_helper["a" /* default */].sum(counters);
              nextStart = this._nextSet(this._row, nextStart);
            } while (decodedChar !== '*');

            result.pop();

            if (!result.length) {
              return null;
            }

            if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
              return null;
            }

            return {
              code: result.join(''),
              start: start.start,
              end: nextStart,
              startInfo: start,
              decodedCodes: result,
              format: this.FORMAT
            };
          }
        }]);

        return Code39Reader;
      }(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
      var get = __webpack_require__(18);
      var get_default = /*#__PURE__*/__webpack_require__.n(get);

      // CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









      function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }


      var patterns = {
        IOQ: /[IOQ]/g,
        AZ09: /[A-Z0-9]{17}/
      };

      var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
        inherits_default()(Code39VINReader, _Code39Reader);

        var _super = code_39_vin_reader_createSuper(Code39VINReader);

        function Code39VINReader() {
          var _this;

          classCallCheck_default()(this, Code39VINReader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

          return _this;
        }

        createClass_default()(Code39VINReader, [{
          key: "_checkChecksum",
          // TODO (this was todo in original repo, no text was there. sorry.)
          value: function _checkChecksum(code) {
            return !!code;
          } // Cribbed from:
          // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

        }, {
          key: "_decode",
          value: function _decode(row, start) {
            var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "_decode", this).call(this, row, start);

            if (!result) {
              return null;
            }

            var code = result.code;

            if (!code) {
              return null;
            }

            code = code.replace(patterns.IOQ, '');

            if (!code.match(patterns.AZ09)) {
              if (true) {
                console.log('Failed AZ09 pattern code:', code);
              }

              return null;
            }

            if (!this._checkChecksum(code)) {
              return null;
            }

            result.code = code;
            return result;
          }
        }]);

        return Code39VINReader;
      }(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
      // CONCATENATED MODULE: ./src/reader/codabar_reader.ts








      function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

      // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

      var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
      var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
      var START_END = [0x01A, 0x029, 0x00B, 0x00E];
      var MIN_ENCODED_CHARS = 4;
      var MAX_ACCEPTABLE = 2.0;
      var PADDING = 1.5;
      ;
      ;

      var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
        inherits_default()(NewCodabarReader, _BarcodeReader);

        var _super = codabar_reader_createSuper(NewCodabarReader);

        function NewCodabarReader() {
          var _this;

          classCallCheck_default()(this, NewCodabarReader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

          return _this;
        }

        createClass_default()(NewCodabarReader, [{
          key: "_computeAlternatingThreshold",
          value: function _computeAlternatingThreshold(offset, end) {
            var min = Number.MAX_VALUE;
            var max = 0;
            var counter = 0;

            for (var i = offset; i < end; i += 2) {
              counter = this._counters[i];

              if (counter > max) {
                max = counter;
              }

              if (counter < min) {
                min = counter;
              }
            }

            return (min + max) / 2.0 | 0;
          }
        }, {
          key: "_toPattern",
          value: function _toPattern(offset) {
            var numCounters = 7;
            var end = offset + numCounters;

            if (end > this._counters.length) {
              return -1;
            }

            var barThreshold = this._computeAlternatingThreshold(offset, end);

            var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

            var bitmask = 1 << numCounters - 1;
            var threshold = 0;
            var pattern = 0;

            for (var i = 0; i < numCounters; i++) {
              threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

              if (this._counters[offset + i] > threshold) {
                pattern |= bitmask;
              }

              bitmask >>= 1;
            }

            return pattern;
          }
        }, {
          key: "_isStartEnd",
          value: function _isStartEnd(pattern) {
            for (var i = 0; i < START_END.length; i++) {
              if (START_END[i] === pattern) {
                return true;
              }
            }

            return false;
          }
        }, {
          key: "_sumCounters",
          value: function _sumCounters(start, end) {
            var sum = 0;

            for (var i = start; i < end; i++) {
              sum += this._counters[i];
            }

            return sum;
          }
        }, {
          key: "_findStart",
          value: function _findStart() {
            var start = this._nextUnset(this._row);

            var end = start;

            for (var i = 1; i < this._counters.length; i++) {
              var pattern = this._toPattern(i);

              if (pattern !== -1 && this._isStartEnd(pattern)) {
                // TODO: Look for whitespace ahead
                start += this._sumCounters(0, i);
                end = start + this._sumCounters(i, i + 8);
                return {
                  start: start,
                  end: end,
                  startCounter: i,
                  endCounter: i + 8
                };
              }
            }

            return null;
          }
        }, {
          key: "_patternToChar",
          value: function _patternToChar(pattern) {
            for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
              if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
                return String.fromCharCode(codabar_reader_ALPHABET[i]);
              }
            }

            return null;
          }
        }, {
          key: "_calculatePatternLength",
          value: function _calculatePatternLength(offset) {
            var sum = 0;

            for (var i = offset; i < offset + 7; i++) {
              sum += this._counters[i];
            }

            return sum;
          }
        }, {
          key: "_verifyWhitespace",
          value: function _verifyWhitespace(startCounter, endCounter) {
            if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
              if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
                return true;
              }
            }

            return false;
          }
        }, {
          key: "_charToPattern",
          value: function _charToPattern(_char) {
            var charCode = _char.charCodeAt(0);

            for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
              if (codabar_reader_ALPHABET[i] === charCode) {
                return codabar_reader_CHARACTER_ENCODINGS[i];
              }
            }

            return 0x0;
          }
        }, {
          key: "_thresholdResultPattern",
          value: function _thresholdResultPattern(result, startCounter) {
            var categorization = {
              space: {
                narrow: {
                  size: 0,
                  counts: 0,
                  min: 0,
                  max: Number.MAX_VALUE
                },
                wide: {
                  size: 0,
                  counts: 0,
                  min: 0,
                  max: Number.MAX_VALUE
                }
              },
              bar: {
                narrow: {
                  size: 0,
                  counts: 0,
                  min: 0,
                  max: Number.MAX_VALUE
                },
                wide: {
                  size: 0,
                  counts: 0,
                  min: 0,
                  max: Number.MAX_VALUE
                }
              }
            };
            var pos = startCounter;
            var pattern;

            for (var i = 0; i < result.length; i++) {
              pattern = this._charToPattern(result[i]);

              for (var j = 6; j >= 0; j--) {
                var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
                var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
                cat.size += this._counters[pos + j];
                cat.counts++;
                pattern >>= 1;
              }

              pos += 8;
            }

            ['space', 'bar'].forEach(function (key) {
              var newkind = categorization[key];
              newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
              newkind.narrow.max = Math.ceil(newkind.wide.min);
              newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
            });
            return categorization;
          }
        }, {
          key: "_validateResult",
          value: function _validateResult(result, startCounter) {
            var thresholds = this._thresholdResultPattern(result, startCounter);

            var pos = startCounter;
            var pattern;

            for (var i = 0; i < result.length; i++) {
              pattern = this._charToPattern(result[i]);

              for (var j = 6; j >= 0; j--) {
                var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
                var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
                var size = this._counters[pos + j];

                if (size < cat.min || size > cat.max) {
                  return false;
                }

                pattern >>= 1;
              }

              pos += 8;
            }

            return true;
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            this._counters = this._fillCounters();
            start = this._findStart();

            if (!start) {
              return null;
            }

            var nextStart = start.startCounter;
            var result = [];
            var pattern;

            do {
              pattern = this._toPattern(nextStart);

              if (pattern < 0) {
                return null;
              }

              var decodedChar = this._patternToChar(pattern);

              if (decodedChar === null) {
                return null;
              }

              result.push(decodedChar);
              nextStart += 8;

              if (result.length > 1 && this._isStartEnd(pattern)) {
                break;
              }
            } while (nextStart < this._counters.length); // verify end


            if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
              return null;
            } // verify end white space


            if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
              return null;
            }

            if (!this._validateResult(result, start.startCounter)) {
              return null;
            }

            nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

            var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

            return {
              code: result.join(''),
              start: start.start,
              end: end,
              startInfo: start,
              decodedCodes: result,
              format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

            };
          }
        }]);

        return NewCodabarReader;
      }(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
      // CONCATENATED MODULE: ./src/reader/upc_reader.ts








      function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }



      var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
        inherits_default()(UPCReader, _EANReader);

        var _super = upc_reader_createSuper(UPCReader);

        function UPCReader() {
          var _this;

          classCallCheck_default()(this, UPCReader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

          return _this;
        }

        createClass_default()(UPCReader, [{
          key: "_decode",
          value: function _decode(row, start) {
            var result = ean_reader.prototype._decode.call(this);

            if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
              result.code = result.code.substring(1);
              return result;
            }

            return null;
          }
        }]);

        return UPCReader;
      }(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
      // CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








      function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }



      var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
        inherits_default()(EAN8Reader, _EANReader);

        var _super = ean_8_reader_createSuper(EAN8Reader);

        function EAN8Reader() {
          var _this;

          classCallCheck_default()(this, EAN8Reader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

          return _this;
        }

        createClass_default()(EAN8Reader, [{
          key: "_decodePayload",
          value: function _decodePayload(inCode, result, decodedCodes) {
            var code = inCode;

            for (var i = 0; i < 4; i++) {
              code = this._decodeCode(code.end, CODE_G_START);

              if (!code) {
                return null;
              }

              result.push(code.code);
              decodedCodes.push(code);
            }

            code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

            if (code === null) {
              return null;
            }

            decodedCodes.push(code);

            for (var _i = 0; _i < 4; _i++) {
              code = this._decodeCode(code.end, CODE_G_START);

              if (!code) {
                return null;
              }

              decodedCodes.push(code);
              result.push(code.code);
            }

            return code;
          }
        }]);

        return EAN8Reader;
      }(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
      // CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








      function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }



      var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
        inherits_default()(EAN2Reader, _EANReader);

        var _super = ean_2_reader_createSuper(EAN2Reader);

        function EAN2Reader() {
          var _this;

          classCallCheck_default()(this, EAN2Reader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

          return _this;
        }

        createClass_default()(EAN2Reader, [{
          key: "_decode",
          value: function _decode(row, start) {
            if (row) {
              this._row = row;
            }

            var codeFrequency = 0;
            var offset = start;
            var end = this._row.length;
            var result = [];
            var decodedCodes = [];
            var code = null;

            if (offset === undefined) {
              return null;
            }

            for (var i = 0; i < 2 && offset < end; i++) {
              code = this._decodeCode(offset);

              if (!code) {
                return null;
              }

              decodedCodes.push(code);
              result.push(code.code % 10);

              if (code.code >= CODE_G_START) {
                codeFrequency |= 1 << 1 - i;
              }

              if (i !== 1) {
                offset = this._nextSet(this._row, code.end);
                offset = this._nextUnset(this._row, offset);
              }
            }

            if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
              return null;
            }

            var startInfo = this._findStart();

            return {
              code: result.join(''),
              decodedCodes: decodedCodes,
              end: code.end,
              format: this.FORMAT,
              startInfo: startInfo,
              start: startInfo.start
            };
          }
        }]);

        return EAN2Reader;
      }(ean_reader);

      ;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
      // CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








      function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }


      var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

      function determineCheckDigit(codeFrequency) {
        for (var i = 0; i < 10; i++) {
          if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
            return i;
          }
        }

        return null;
      }

      function extensionChecksum(result) {
        var length = result.length;
        var sum = 0;

        for (var i = length - 2; i >= 0; i -= 2) {
          sum += result[i];
        }

        sum *= 3;

        for (var _i = length - 1; _i >= 0; _i -= 2) {
          sum += result[_i];
        }

        sum *= 3;
        return sum % 10;
      }

      var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
        inherits_default()(EAN5Reader, _EANReader);

        var _super = ean_5_reader_createSuper(EAN5Reader);

        function EAN5Reader() {
          var _this;

          classCallCheck_default()(this, EAN5Reader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

          return _this;
        }

        createClass_default()(EAN5Reader, [{
          key: "_decode",
          value: function _decode(row, start) {
            if (start === undefined) {
              return null;
            }

            if (row) {
              this._row = row;
            }

            var codeFrequency = 0;
            var offset = start;
            var end = this._row.length;
            var code = null;
            var result = [];
            var decodedCodes = [];

            for (var i = 0; i < 5 && offset < end; i++) {
              code = this._decodeCode(offset);

              if (!code) {
                return null;
              }

              decodedCodes.push(code);
              result.push(code.code % 10);

              if (code.code >= CODE_G_START) {
                codeFrequency |= 1 << 4 - i;
              }

              if (i !== 4) {
                offset = this._nextSet(this._row, code.end);
                offset = this._nextUnset(this._row, offset);
              }
            }

            if (result.length !== 5) {
              return null;
            }

            if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
              return null;
            }

            var startInfo = this._findStart();

            return {
              code: result.join(''),
              decodedCodes: decodedCodes,
              end: code.end,
              format: this.FORMAT,
              startInfo: startInfo,
              start: startInfo.start
            };
          }
        }]);

        return EAN5Reader;
      }(ean_reader);

      ;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
      // CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









      function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

      function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }



      var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
        inherits_default()(UPCEReader, _EANReader);

        var _super = upc_e_reader_createSuper(UPCEReader);

        function UPCEReader() {
          var _this;

          classCallCheck_default()(this, UPCEReader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

          defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

          return _this;
        }

        createClass_default()(UPCEReader, [{
          key: "_decodePayload",
          value: function _decodePayload(inCode, result, decodedCodes) {
            var outCode = upc_e_reader_objectSpread({}, inCode);

            var codeFrequency = 0x0;

            for (var i = 0; i < 6; i++) {
              outCode = this._decodeCode(outCode.end);

              if (!outCode) {
                return null;
              }

              if (outCode.code >= CODE_G_START) {
                outCode.code = outCode.code - CODE_G_START;
                codeFrequency |= 1 << 5 - i;
              }

              result.push(outCode.code);
              decodedCodes.push(outCode);
            }

            if (!this._determineParity(codeFrequency, result)) {
              return null;
            }

            return outCode;
          }
        }, {
          key: "_determineParity",
          value: function _determineParity(codeFrequency, result) {
            for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
              for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
                if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
                  result.unshift(nrSystem);
                  result.push(i);
                  return true;
                }
              }
            }

            return false;
          }
        }, {
          key: "_convertToUPCA",
          value: function _convertToUPCA(result) {
            var upca = [result[0]];
            var lastDigit = result[result.length - 2];

            if (lastDigit <= 2) {
              upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
            } else if (lastDigit === 3) {
              upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
            } else if (lastDigit === 4) {
              upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
            } else {
              upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
            }

            upca.push(result[result.length - 1]);
            return upca;
          }
        }, {
          key: "_checksum",
          value: function _checksum(result) {
            return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
          }
        }, {
          key: "_findEnd",
          value: function _findEnd(offset, isWhite) {
            return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
          }
        }, {
          key: "_verifyTrailingWhitespace",
          value: function _verifyTrailingWhitespace(endInfo) {
            var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

            if (trailingWhitespaceEnd < this._row.length) {
              if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                return endInfo;
              }
            }

            return null;
          }
        }]);

        return UPCEReader;
      }(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
      // CONCATENATED MODULE: ./src/reader/i2of5_reader.ts








      function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

      // TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


      var N = 1;
      var W = 3;

      var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
        inherits_default()(I2of5Reader, _BarcodeReader);

        var _super = i2of5_reader_createSuper(I2of5Reader);

        function I2of5Reader(opts) {
          var _this;

          classCallCheck_default()(this, I2of5Reader);

          _this = _super.call(this, merge_default()({
            normalizeBarSpaceWidth: false
          }, opts));

          defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

          defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

          defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

          defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

          defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

          defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

          defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

          if (opts.normalizeBarSpaceWidth) {
            _this.SINGLE_CODE_ERROR = 0.38;
            _this.AVG_CODE_ERROR = 0.09;
          }

          _this.config = opts;
          return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
        }

        createClass_default()(I2of5Reader, [{
          key: "_matchPattern",
          value: function _matchPattern(counter, code) {
            if (this.config.normalizeBarSpaceWidth) {
              var counterSum = [0, 0];
              var codeSum = [0, 0];
              var correction = [0, 0];
              var correctionRatio = this.MAX_CORRECTION_FACTOR;
              var correctionRatioInverse = 1 / correctionRatio;

              for (var i = 0; i < counter.length; i++) {
                counterSum[i % 2] += counter[i];
                codeSum[i % 2] += code[i];
              }

              correction[0] = codeSum[0] / counterSum[0];
              correction[1] = codeSum[1] / counterSum[1];
              correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
              correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
              this.barSpaceRatio = correction;

              for (var _i = 0; _i < counter.length; _i++) {
                counter[_i] *= this.barSpaceRatio[_i % 2];
              }
            }

            return barcode_reader.prototype._matchPattern.call(this, counter, code);
          }
        }, {
          key: "_findPattern",
          value: function _findPattern(pattern, offset) {
            var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var counter = new Array(pattern.length).fill(0);
            var counterPos = 0;
            var bestMatch = {
              error: Number.MAX_VALUE,
              code: -1,
              start: 0,
              end: 0
            };
            var epsilon = this.AVG_CODE_ERROR;
            isWhite = isWhite || false;
            tryHarder = tryHarder || false;

            if (!offset) {
              offset = this._nextSet(this._row);
            }

            for (var i = offset; i < this._row.length; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos]++;
              } else {
                if (counterPos === counter.length - 1) {
                  var sum = counter.reduce(function (prev, next) {
                    return prev + next;
                  }, 0);

                  var error = this._matchPattern(counter, pattern);

                  if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                  }

                  if (tryHarder) {
                    for (var j = 0; j < counter.length - 2; j++) {
                      counter[j] = counter[j + 2];
                    }

                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                  } else {
                    return null;
                  }
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return null;
          }
        }, {
          key: "_findStart",
          value: function _findStart() {
            var leadingWhitespaceStart = 0;

            var offset = this._nextSet(this._row);

            var startInfo = null;
            var narrowBarWidth = 1;

            while (!startInfo) {
              startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

              if (!startInfo) {
                return null;
              }

              narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
              leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

              if (leadingWhitespaceStart >= 0) {
                if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                  return startInfo;
                }
              }

              offset = startInfo.end;
              startInfo = null;
            }

            return null;
          }
        }, {
          key: "_verifyTrailingWhitespace",
          value: function _verifyTrailingWhitespace(endInfo) {
            var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

            if (trailingWhitespaceEnd < this._row.length) {
              if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                return endInfo;
              }
            }

            return null;
          }
        }, {
          key: "_findEnd",
          value: function _findEnd() {
            this._row.reverse();

            var endInfo = this._findPattern(this.STOP_PATTERN);

            this._row.reverse();

            if (endInfo === null) {
              return null;
            } // reverse numbers


            var tmp = endInfo.start;
            endInfo.start = this._row.length - endInfo.end;
            endInfo.end = this._row.length - tmp;
            return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
          }
        }, {
          key: "_decodePair",
          value: function _decodePair(counterPair) {
            var codes = [];

            for (var i = 0; i < counterPair.length; i++) {
              var code = this._decodeCode(counterPair[i]);

              if (!code) {
                return null;
              }

              codes.push(code);
            }

            return codes;
          }
        }, {
          key: "_decodeCode",
          value: function _decodeCode(counter) {
            var epsilon = this.AVG_CODE_ERROR;
            var bestMatch = {
              error: Number.MAX_VALUE,
              code: -1,
              start: 0,
              end: 0
            };

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < epsilon) {
              return bestMatch;
            }

            return null;
          }
        }, {
          key: "_decodePayload",
          value: function _decodePayload(counters, result, decodedCodes) {
            var pos = 0;
            var counterLength = counters.length;
            var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
            var codes = null;

            while (pos < counterLength) {
              for (var i = 0; i < 5; i++) {
                counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
                counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
                pos += 2;
              }

              codes = this._decodePair(counterPair);

              if (!codes) {
                return null;
              }

              for (var _i2 = 0; _i2 < codes.length; _i2++) {
                result.push(codes[_i2].code + '');
                decodedCodes.push(codes[_i2]);
              }
            }

            return codes;
          }
        }, {
          key: "_verifyCounterLength",
          value: function _verifyCounterLength(counters) {
            return counters.length % 10 === 0;
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            var result = new Array();
            var decodedCodes = new Array();

            var startInfo = this._findStart();

            if (!startInfo) {
              return null;
            }

            decodedCodes.push(startInfo);

            var endInfo = this._findEnd();

            if (!endInfo) {
              return null;
            }

            var counters = this._fillCounters(startInfo.end, endInfo.start, false);

            if (!this._verifyCounterLength(counters)) {
              return null;
            }

            var code = this._decodePayload(counters, result, decodedCodes);

            if (!code) {
              return null;
            }

            if (result.length % 2 !== 0 || result.length < 6) {
              return null;
            }

            decodedCodes.push(endInfo);
            return {
              code: result.join(''),
              start: startInfo.start,
              end: endInfo.end,
              startInfo: startInfo,
              decodedCodes: decodedCodes,
              format: this.FORMAT
            };
          }
        }]);

        return I2of5Reader;
      }(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
      // CONCATENATED MODULE: ./src/reader/2of5_reader.ts








      function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }


      var _2of5_reader_N = 1;
      var _2of5_reader_W = 3;
      var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
      var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
      var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
      var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
        return sum + val;
      }, 0);

      var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
        inherits_default()(TwoOfFiveReader, _BarcodeReader);

        var _super = _2of5_reader_createSuper(TwoOfFiveReader);

        function TwoOfFiveReader() {
          var _this;

          classCallCheck_default()(this, TwoOfFiveReader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

          defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

          defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

          return _this;
        }

        createClass_default()(TwoOfFiveReader, [{
          key: "_findPattern",
          value: function _findPattern(pattern, offset) {
            var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var counter = [];
            var counterPos = 0;
            var bestMatch = {
              error: Number.MAX_VALUE,
              code: -1,
              start: 0,
              end: 0
            };
            var sum = 0;
            var error = 0;
            var epsilon = this.AVG_CODE_ERROR;

            if (!offset) {
              offset = this._nextSet(this._row);
            }

            for (var i = 0; i < pattern.length; i++) {
              counter[i] = 0;
            }

            for (var _i = offset; _i < this._row.length; _i++) {
              if (this._row[_i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos]++;
              } else {
                if (counterPos === counter.length - 1) {
                  sum = 0;

                  for (var j = 0; j < counter.length; j++) {
                    sum += counter[j];
                  }

                  error = this._matchPattern(counter, pattern);

                  if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = _i - sum;
                    bestMatch.end = _i;
                    return bestMatch;
                  }

                  if (tryHarder) {
                    for (var _j = 0; _j < counter.length - 2; _j++) {
                      counter[_j] = counter[_j + 2];
                    }

                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                  } else {
                    return null;
                  }
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return null;
          }
        }, {
          key: "_findStart",
          value: function _findStart() {
            var startInfo = null;

            var offset = this._nextSet(this._row);

            var narrowBarWidth = 1;
            var leadingWhitespaceStart = 0;

            while (!startInfo) {
              startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

              if (!startInfo) {
                return null;
              }

              narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
              leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

              if (leadingWhitespaceStart >= 0) {
                if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                  return startInfo;
                }
              }

              offset = startInfo.end;
              startInfo = null;
            }

            return startInfo;
          }
        }, {
          key: "_verifyTrailingWhitespace",
          value: function _verifyTrailingWhitespace(endInfo) {
            var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

            if (trailingWhitespaceEnd < this._row.length) {
              if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                return endInfo;
              }
            }

            return null;
          }
        }, {
          key: "_findEnd",
          value: function _findEnd() {
            // TODO: reverse, followed by some calcs, followed by another reverse? really?
            this._row.reverse();

            var offset = this._nextSet(this._row);

            var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

            this._row.reverse();

            if (endInfo === null) {
              return null;
            } // reverse numbers


            var tmp = endInfo.start;
            endInfo.start = this._row.length - endInfo.end;
            endInfo.end = this._row.length - tmp;
            return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
          }
        }, {
          key: "_verifyCounterLength",
          value: function _verifyCounterLength(counters) {
            return counters.length % 10 === 0;
          }
        }, {
          key: "_decodeCode",
          value: function _decodeCode(counter) {
            var epsilon = this.AVG_CODE_ERROR;
            var bestMatch = {
              error: Number.MAX_VALUE,
              code: -1,
              start: 0,
              end: 0
            };

            for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < epsilon) {
              return bestMatch;
            }

            return null;
          }
        }, {
          key: "_decodePayload",
          value: function _decodePayload(counters, result, decodedCodes) {
            var pos = 0;
            var counterLength = counters.length;
            var counter = [0, 0, 0, 0, 0];
            var code = null;

            while (pos < counterLength) {
              for (var i = 0; i < 5; i++) {
                counter[i] = counters[pos] * this.barSpaceRatio[0];
                pos += 2;
              }

              code = this._decodeCode(counter);

              if (!code) {
                return null;
              }

              result.push("".concat(code.code));
              decodedCodes.push(code);
            }

            return code;
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            var startInfo = this._findStart();

            if (!startInfo) {
              return null;
            }

            var endInfo = this._findEnd();

            if (!endInfo) {
              return null;
            }

            var counters = this._fillCounters(startInfo.end, endInfo.start, false);

            if (!this._verifyCounterLength(counters)) {
              return null;
            }

            var decodedCodes = [];
            decodedCodes.push(startInfo);
            var result = [];

            var code = this._decodePayload(counters, result, decodedCodes);

            if (!code) {
              return null;
            }

            if (result.length < 5) {
              return null;
            }

            decodedCodes.push(endInfo);
            return {
              code: result.join(''),
              start: startInfo.start,
              end: endInfo.end,
              startInfo: startInfo,
              decodedCodes: decodedCodes,
              format: this.FORMAT
            };
          }
        }]);

        return TwoOfFiveReader;
      }(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
      // CONCATENATED MODULE: ./src/reader/code_93_reader.ts









      function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }



      var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
      var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
        return _char.charCodeAt(0);
      }));
      var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
      var code_93_reader_ASTERISK = 0x15E;

      var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
        inherits_default()(Code93Reader, _BarcodeReader);

        var _super = code_93_reader_createSuper(Code93Reader);

        function Code93Reader() {
          var _this;

          classCallCheck_default()(this, Code93Reader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

          return _this;
        }

        createClass_default()(Code93Reader, [{
          key: "_patternToChar",
          value: function _patternToChar(pattern) {
            for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
              if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
                return String.fromCharCode(code_93_reader_ALPHABET[i]);
              }
            }

            return null;
          }
        }, {
          key: "_toPattern",
          value: function _toPattern(counters) {
            var numCounters = counters.length;
            var sum = counters.reduce(function (prev, next) {
              return prev + next;
            }, 0);
            var pattern = 0;

            for (var i = 0; i < numCounters; i++) {
              var normalized = Math.round(counters[i] * 9 / sum);

              if (normalized < 1 || normalized > 4) {
                return -1;
              }

              if ((i & 1) === 0) {
                for (var j = 0; j < normalized; j++) {
                  pattern = pattern << 1 | 1;
                }
              } else {
                pattern <<= normalized;
              }
            }

            return pattern;
          }
        }, {
          key: "_findStart",
          value: function _findStart() {
            var offset = this._nextSet(this._row);

            var patternStart = offset;
            var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
            var counterPos = 0;
            var isWhite = false;

            for (var i = offset; i < this._row.length; i++) {
              if (this._row[i] ^ (isWhite ? 1 : 0)) {
                counter[counterPos]++;
              } else {
                if (counterPos === counter.length - 1) {
                  // find start pattern
                  if (this._toPattern(counter) === code_93_reader_ASTERISK) {
                    var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

                    if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                      return {
                        start: patternStart,
                        end: i
                      };
                    }
                  }

                  patternStart += counter[0] + counter[1];

                  for (var j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                  }

                  counter[4] = 0;
                  counter[5] = 0;
                  counterPos--;
                } else {
                  counterPos++;
                }

                counter[counterPos] = 1;
                isWhite = !isWhite;
              }
            }

            return null;
          }
        }, {
          key: "_verifyEnd",
          value: function _verifyEnd(lastStart, nextStart) {
            if (lastStart === nextStart || !this._row[nextStart]) {
              return false;
            }

            return true;
          }
        }, {
          key: "_decodeExtended",
          value: function _decodeExtended(charArray) {
            var length = charArray.length;
            var result = [];

            for (var i = 0; i < length; i++) {
              var _char2 = charArray[i];

              if (_char2 >= 'a' && _char2 <= 'd') {
                if (i > length - 2) {
                  return null;
                }

                var nextChar = charArray[++i];
                var nextCharCode = nextChar.charCodeAt(0);
                var decodedChar = void 0;

                switch (_char2) {
                  case 'a':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                      decodedChar = String.fromCharCode(nextCharCode - 64);
                    } else {
                      return null;
                    }

                    break;

                  case 'b':
                    if (nextChar >= 'A' && nextChar <= 'E') {
                      decodedChar = String.fromCharCode(nextCharCode - 38);
                    } else if (nextChar >= 'F' && nextChar <= 'J') {
                      decodedChar = String.fromCharCode(nextCharCode - 11);
                    } else if (nextChar >= 'K' && nextChar <= 'O') {
                      decodedChar = String.fromCharCode(nextCharCode + 16);
                    } else if (nextChar >= 'P' && nextChar <= 'S') {
                      decodedChar = String.fromCharCode(nextCharCode + 43);
                    } else if (nextChar >= 'T' && nextChar <= 'Z') {
                      decodedChar = String.fromCharCode(127);
                    } else {
                      return null;
                    }

                    break;

                  case 'c':
                    if (nextChar >= 'A' && nextChar <= 'O') {
                      decodedChar = String.fromCharCode(nextCharCode - 32);
                    } else if (nextChar === 'Z') {
                      decodedChar = ':';
                    } else {
                      return null;
                    }

                    break;

                  case 'd':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                      decodedChar = String.fromCharCode(nextCharCode + 32);
                    } else {
                      return null;
                    }

                    break;

                  default:
                    console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
                    return null;
                }

                result.push(decodedChar);
              } else {
                result.push(_char2);
              }
            }

            return result;
          }
        }, {
          key: "_matchCheckChar",
          value: function _matchCheckChar(charArray, index, maxWeight) {
            var arrayToCheck = charArray.slice(0, index);
            var length = arrayToCheck.length;
            var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
              var weight = (i * -1 + (length - 1)) % maxWeight + 1;
              var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
              return sum + weight * value;
            }, 0);
            var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
            return checkChar === charArray[index].charCodeAt(0);
          }
        }, {
          key: "_verifyChecksums",
          value: function _verifyChecksums(charArray) {
            return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            start = this._findStart();

            if (!start) {
              return null;
            }

            var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
            var result = [];

            var nextStart = this._nextSet(this._row, start.end);

            var lastStart;
            var decodedChar;

            do {
              counters = this._toCounters(nextStart, counters);

              var pattern = this._toPattern(counters);

              if (pattern < 0) {
                return null;
              }

              decodedChar = this._patternToChar(pattern);

              if (decodedChar === null) {
                return null;
              }

              result.push(decodedChar);
              lastStart = nextStart;
              nextStart += array_helper["a" /* default */].sum(counters);
              nextStart = this._nextSet(this._row, nextStart);
            } while (decodedChar !== '*');

            result.pop();

            if (!result.length) {
              return null;
            }

            if (!this._verifyEnd(lastStart, nextStart)) {
              return null;
            }

            if (!this._verifyChecksums(result)) {
              return null;
            }

            result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

            if ((result = this._decodeExtended(result)) === null) {
              return null;
            }

            return {
              code: result.join(''),
              start: start.start,
              end: nextStart,
              startInfo: start,
              decodedCodes: result,
              format: this.FORMAT
            };
          }
        }]);

        return Code93Reader;
      }(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
      // CONCATENATED MODULE: ./src/reader/code_32_reader.ts









      function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

      function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }


      var code_32_reader_patterns = {
        AEIO: /[AEIO]/g,
        AZ09: /[A-Z0-9]/
      };
      var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';

      var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
        inherits_default()(Code32Reader, _Code39Reader);

        var _super = code_32_reader_createSuper(Code32Reader);

        function Code32Reader() {
          var _this;

          classCallCheck_default()(this, Code32Reader);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

          return _this;
        }

        createClass_default()(Code32Reader, [{
          key: "_decodeCode32",
          value: function _decodeCode32(code) {
            if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
              return null;
            }

            var res = 0;

            for (var i = 0; i < code.length; i++) {
              res = res * 32 + code32set.indexOf(code[i]);
            }

            var code32 = '' + res;

            if (code32.length < 9) {
              code32 = ('000000000' + code32).slice(-9);
            }

            return 'A' + code32;
          } // TODO (this was todo in original repo, no text was there. sorry.)

        }, {
          key: "_checkChecksum",
          value: function _checkChecksum(code) {
            return !!code;
          }
        }, {
          key: "_decode",
          value: function _decode(row, start) {
            var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "_decode", this).call(this, row, start);

            if (!result) {
              return null;
            }

            var code = result.code;

            if (!code) {
              return null;
            }

            code = code.replace(code_32_reader_patterns.AEIO, '');

            if (!this._checkChecksum(code)) {
              return null;
            }

            var code32 = this._decodeCode32(code);

            if (!code32) {
              return null;
            }

            result.code = code32;
            return result;
          }
        }]);

        return Code32Reader;
      }(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
      // CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















      var READERS = {
        code_128_reader: code_128_reader,
        ean_reader: ean_reader,
        ean_5_reader: ean_5_reader,
        ean_2_reader: ean_2_reader,
        ean_8_reader: ean_8_reader,
        code_39_reader: code_39_reader,
        code_39_vin_reader: code_39_vin_reader,
        codabar_reader: codabar_reader,
        upc_reader: upc_reader,
        upc_e_reader: upc_e_reader,
        i2of5_reader: i2of5_reader,
        '2of5_reader': _2of5_reader,
        code_93_reader: code_93_reader,
        code_32_reader: code_32_reader
      };
/* harmony default export */ var barcode_decoder = ({
        registerReader: function registerReader(name, reader) {
          READERS[name] = reader;
        },
        create: function create(config, inputImageWrapper) {
          var _canvas = {
            ctx: {
              frequency: null,
              pattern: null,
              overlay: null
            },
            dom: {
              frequency: null,
              pattern: null,
              overlay: null
            }
          };
          var _barcodeReaders = [];
          initCanvas();
          initReaders();
          initConfig();

          function initCanvas() {
            if (true && typeof document !== 'undefined') {
              var $debug = document.querySelector('#debug.detection');
              _canvas.dom.frequency = document.querySelector('canvas.frequency');

              if (!_canvas.dom.frequency) {
                _canvas.dom.frequency = document.createElement('canvas');
                _canvas.dom.frequency.className = 'frequency';

                if ($debug) {
                  $debug.appendChild(_canvas.dom.frequency);
                }
              }

              _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
              _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');

              if (!_canvas.dom.pattern) {
                _canvas.dom.pattern = document.createElement('canvas');
                _canvas.dom.pattern.className = 'patternBuffer';

                if ($debug) {
                  $debug.appendChild(_canvas.dom.pattern);
                }
              }

              _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
              _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');

              if (_canvas.dom.overlay) {
                _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
              }
            }
          }

          function initReaders() {
            config.readers.forEach(function (readerConfig) {
              var reader;
              var configuration = {};
              var supplements = [];

              if (typeof_default()(readerConfig) === 'object') {
                reader = readerConfig.format;
                configuration = readerConfig.config;
              } else if (typeof readerConfig === 'string') {
                reader = readerConfig;
              }

              if (true) {
                console.log('Before registering reader: ', reader);
              }

              if (configuration.supplements) {
                supplements = configuration.supplements.map(function (supplement) {
                  return new READERS[supplement]();
                });
              }

              try {
                var readerObj = new READERS[reader](configuration, supplements);

                _barcodeReaders.push(readerObj);
              } catch (err) {
                console.error('* Error constructing reader ', reader, err);
                throw err;
              }
            });

            if (true) {
              console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
                return JSON.stringify({
                  format: reader.FORMAT,
                  config: reader.config
                });
              }).join(', ')));
            }
          }

          function initConfig() {
            if (true && typeof document !== 'undefined') {
              var i;
              var vis = [{
                node: _canvas.dom.frequency,
                prop: config.debug.showFrequency
              }, {
                node: _canvas.dom.pattern,
                prop: config.debug.showPattern
              }];

              for (i = 0; i < vis.length; i++) {
                if (vis[i].prop === true) {
                  vis[i].node.style.display = 'block';
                } else {
                  vis[i].node.style.display = 'none';
                }
              }
            }
          }
          /**
           * extend the line on both ends
           * @param {Array} line
           * @param {Number} angle
           */


          function getExtendedLine(line, angle, ext) {
            function extendLine(amount) {
              var extension = {
                y: amount * Math.sin(angle),
                x: amount * Math.cos(angle)
              };
              /* eslint-disable no-param-reassign */

              line[0].y -= extension.y;
              line[0].x -= extension.x;
              line[1].y += extension.y;
              line[1].x += extension.x;
              /* eslint-enable no-param-reassign */
            } // check if inside image


            extendLine(ext);

            while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
              // eslint-disable-next-line no-param-reassign
              ext -= Math.ceil(ext / 2);
              extendLine(-ext);
            }

            return line;
          }

          function getLine(box) {
            return [{
              x: (box[1][0] - box[0][0]) / 2 + box[0][0],
              y: (box[1][1] - box[0][1]) / 2 + box[0][1]
            }, {
              x: (box[3][0] - box[2][0]) / 2 + box[2][0],
              y: (box[3][1] - box[2][1]) / 2 + box[2][1]
            }];
          }

          function tryDecode(line) {
            var result = null;
            var i;
            var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

            if (true && config.debug.showFrequency) {
              image_debug["a" /* default */].drawPath(line, {
                x: 'x',
                y: 'y'
              }, _canvas.ctx.overlay, {
                color: 'red',
                lineWidth: 3
              });
              bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
            }

            bresenham.toBinaryLine(barcodeLine);

            if (true && config.debug.showPattern) {
              bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
            }

            for (i = 0; i < _barcodeReaders.length && result === null; i++) {
              result = _barcodeReaders[i].decodePattern(barcodeLine.line);
            }

            if (result === null) {
              return null;
            }

            return {
              codeResult: result,
              barcodeLine: barcodeLine
            };
          }
          /**
           * This method slices the given area apart and tries to detect a barcode-pattern
           * for each slice. It returns the decoded barcode, or null if nothing was found
           * @param {Array} box
           * @param {Array} line
           * @param {Number} lineAngle
           */


          function tryDecodeBruteForce(box, line, lineAngle) {
            var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
            var i;
            var slices = 16;
            var result = null;
            var dir;
            var extension;
            var xdir = Math.sin(lineAngle);
            var ydir = Math.cos(lineAngle);

            for (i = 1; i < slices && result === null; i++) {
              // move line perpendicular to angle
              // eslint-disable-next-line no-mixed-operators
              dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
              extension = {
                y: dir * xdir,
                x: dir * ydir
              };
              /* eslint-disable no-param-reassign */

              line[0].y += extension.x;
              line[0].x -= extension.y;
              line[1].y += extension.x;
              line[1].x -= extension.y;
              /* eslint-enable no-param-reassign */

              result = tryDecode(line);
            }

            return result;
          }

          function getLineLength(line) {
            return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
          }

          function _decodeFromImage(imageWrapper) {
            var result = null;

            for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
              result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
            }

            return result;
          }
          /**
           * With the help of the configured readers (Code128 or EAN) this function tries to detect a
           * valid barcode pattern within the given area.
           * @param {Object} box The area to search in
           * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
           */


          function _decodeFromBoundingBox(box) {
            var line;
            var ctx = _canvas.ctx.overlay;
            var result;

            if (true) {
              if (config.debug.drawBoundingBox && ctx) {
                image_debug["a" /* default */].drawPath(box, {
                  x: 0,
                  y: 1
                }, ctx, {
                  color: 'blue',
                  lineWidth: 2
                });
              }
            }

            line = getLine(box);
            var lineLength = getLineLength(line);
            var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
            line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

            if (line === null) {
              return null;
            }

            result = tryDecode(line);

            if (result === null) {
              result = tryDecodeBruteForce(box, line, lineAngle);
            }

            if (result === null) {
              return null;
            }

            if (true && result && config.debug.drawScanline && ctx) {
              image_debug["a" /* default */].drawPath(line, {
                x: 'x',
                y: 'y'
              }, ctx, {
                color: 'red',
                lineWidth: 3
              });
            }

            return {
              codeResult: result.codeResult,
              line: line,
              angle: lineAngle,
              pattern: result.barcodeLine.line,
              threshold: result.barcodeLine.threshold
            };
          }

          return {
            decodeFromBoundingBox: function decodeFromBoundingBox(box) {
              return _decodeFromBoundingBox(box);
            },
            decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
              var i;
              var result;
              var barcodes = [];
              var multiple = config.multiple;

              for (i = 0; i < boxes.length; i++) {
                var box = boxes[i];
                result = _decodeFromBoundingBox(box) || {};
                result.box = box;

                if (multiple) {
                  barcodes.push(result);
                } else if (result.codeResult) {
                  return result;
                }
              }

              if (multiple) {
                return {
                  barcodes: barcodes
                };
              }
            },
            decodeFromImage: function decodeFromImage(inputImageWrapper) {
              var result = _decodeFromImage(inputImageWrapper);

              return result;
            },
            registerReader: function registerReader(name, reader) {
              if (READERS[name]) {
                throw new Error('cannot register existing reader', name);
              }

              READERS[name] = reader;
            },
            setReaders: function setReaders(readers) {
              // eslint-disable-next-line no-param-reassign
              config.readers = readers;
              _barcodeReaders.length = 0;
              initReaders();
            }
          };
        }
      });
// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
        var events = {};

        function getEvent(eventName) {
          if (!events[eventName]) {
            events[eventName] = {
              subscribers: []
            };
          }

          return events[eventName];
        }

        function clearEvents() {
          events = {};
        }

        function publishSubscription(subscription, data) {
          if (subscription.async) {
            setTimeout(function () {
              subscription.callback(data);
            }, 4);
          } else {
            subscription.callback(data);
          }
        }

        function _subscribe(event, callback, async) {
          var subscription;

          if (typeof callback === 'function') {
            subscription = {
              callback: callback,
              async: async
            };
          } else {
            subscription = callback;

            if (!subscription.callback) {
              throw new Error('Callback was not specified on options');
            }
          }

          getEvent(event).subscribers.push(subscription);
        }

        return {
          subscribe: function subscribe(event, callback, async) {
            return _subscribe(event, callback, async);
          },
          publish: function publish(eventName, data) {
            var event = getEvent(eventName);
            var subscribers = event.subscribers; // Publish one-time subscriptions

            subscribers.filter(function (subscriber) {
              return !!subscriber.once;
            }).forEach(function (subscriber) {
              publishSubscription(subscriber, data);
            }); // remove them from the subscriber

            event.subscribers = subscribers.filter(function (subscriber) {
              return !subscriber.once;
            }); // publish the rest

            event.subscribers.forEach(function (subscriber) {
              publishSubscription(subscriber, data);
            });
          },
          once: function once(event, callback) {
            var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            _subscribe(event, {
              callback: callback,
              async: async,
              once: true
            });
          },
          unsubscribe: function unsubscribe(eventName, callback) {
            if (eventName) {
              var _event = getEvent(eventName);

              if (_event && callback) {
                _event.subscribers = _event.subscribers.filter(function (subscriber) {
                  return subscriber.callback !== callback;
                });
              } else {
                _event.subscribers = [];
              }
            } else {
              clearEvents();
            }
          }
        };
      })());
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
      var regenerator = __webpack_require__(19);
      var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
      var asyncToGenerator = __webpack_require__(41);
      var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

      // EXTERNAL MODULE: ./node_modules/lodash/pick.js
      var pick = __webpack_require__(101);
      var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

      // CONCATENATED MODULE: ./src/common/mediaDevices.ts
      var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
      function enumerateDevices() {
        try {
          return navigator.mediaDevices.enumerateDevices();
        } catch (err) {
          var error = new Error("enumerateDevices is not defined. ".concat(ERROR_DESC));
          error.code = -1;
          return Promise.reject(error);
        }
      }
      function getUserMedia(constraints) {
        try {
          return navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          var error = new Error("getUserMedia is not defined. ".concat(ERROR_DESC));
          error.code = -1;
          return Promise.reject(error);
        }
      }
      // CONCATENATED MODULE: ./src/input/camera_access.ts




      var streamRef;

      function waitForVideo(video) {
        return new Promise(function (resolve, reject) {
          var attempts = 10;

          function checkVideo() {
            if (attempts > 0) {
              if (video.videoWidth > 10 && video.videoHeight > 10) {
                if (true) {
                  console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
                }

                resolve();
              } else {
                window.setTimeout(checkVideo, 500);
              }
            } else {
              reject(new Error('Unable to play video stream. Is webcam working?'));
            }

            attempts--;
          }

          checkVideo();
        });
      }
      /**
       * Tries to attach the camera-stream to a given video-element
       * and calls the callback function when the content is ready
       * @param {Object} constraints
       * @param {Object} video
       */


      function initCamera(_x, _x2) {
        return _initCamera.apply(this, arguments);
      }

      function _initCamera() {
        _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
          var stream;
          return regenerator_default.a.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return getUserMedia(constraints);

                case 2:
                  stream = _context2.sent;
                  streamRef = stream;
                  video.setAttribute('autoplay', 'true');
                  video.setAttribute('muted', 'true');
                  video.setAttribute('playsinline', 'true'); // not listed on MDN...
                  // eslint-disable-next-line no-param-reassign

                  video.srcObject = stream;
                  video.addEventListener('loadedmetadata', function () {
                    video.play();
                  });
                  return _context2.abrupt("return", waitForVideo(video));

                case 10:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
        return _initCamera.apply(this, arguments);
      }

      function deprecatedConstraints(videoConstraints) {
        var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

        if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
          normalized.aspectRatio = videoConstraints.minAspectRatio;
          console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
        }

        if (typeof videoConstraints.facing !== 'undefined') {
          normalized.facingMode = videoConstraints.facing;
          console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
        }

        return normalized;
      } // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
      // I think it was just that way so it could be chained to other functions that did return a Promise.
      // That's not necessary with async functions being a thing, so that should be fixed.


      function pickConstraints() {
        var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var video = deprecatedConstraints(videoConstraints);

        if (video && video.deviceId && video.facingMode) {
          delete video.facingMode;
        }

        return Promise.resolve({
          audio: false,
          video: video
        });
      }

      function enumerateVideoDevices() {
        return _enumerateVideoDevices.apply(this, arguments);
      }

      function _enumerateVideoDevices() {
        _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
          var devices;
          return regenerator_default.a.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return enumerateDevices();

                case 2:
                  devices = _context3.sent;
                  return _context3.abrupt("return", devices.filter(function (device) {
                    return device.kind === 'videoinput';
                  }));

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));
        return _enumerateVideoDevices.apply(this, arguments);
      }

      function getActiveTrack() {
        if (!streamRef) {
          return null;
        }

        var tracks = streamRef.getVideoTracks();
        return tracks && (tracks === null || tracks === void 0 ? void 0 : tracks.length) ? tracks[0] : null;
      }
      /**
       * Used for accessing information about the active stream track and available video devices.
       */


      var QuaggaJSCameraAccess = {
        request: function request(video, videoConstraints) {
          return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
            var newConstraints;
            return regenerator_default.a.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return pickConstraints(videoConstraints);

                  case 2:
                    newConstraints = _context.sent;
                    return _context.abrupt("return", initCamera(video, newConstraints));

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }))();
        },
        release: function release() {
          // TODO: i wonder if telling the Video element to pause() before calling MediaStreamTrack.stop() would alleviate some of the issues with the camera appearing to stay open on Android even after stopping.
          var tracks = streamRef && streamRef.getVideoTracks();

          if (tracks && tracks.length) {
            tracks[0].stop();
          }

          streamRef = null;
        },
        enumerateVideoDevices: enumerateVideoDevices,
        getActiveStreamLabel: function getActiveStreamLabel() {
          var track = getActiveTrack();
          return track ? track.label : '';
        },
        getActiveTrack: getActiveTrack
      };
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
      // CONCATENATED MODULE: ./src/analytics/result_collector.ts


      function contains(codeResult, list) {
        return list && list.some(function (item) {
          var keys = Object.keys(item);
          return keys.every(function (key) {
            return item[key] === codeResult[key];
          });
        });
      }

      function passesFilter(codeResult, filter) {
        return typeof filter === 'function' ? filter(codeResult) : true;
      }

/* harmony default export */ var result_collector = ({
        create: function create(config) {
          var _config$capacity;

          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          var results = [];
          var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
          var capture = config.capture === true;

          function matchesConstraints(codeResult) {
            return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
          }

          return {
            addResult: function addResult(data, imageSize, codeResult) {
              var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

              if (matchesConstraints(codeResult)) {
                capacity--;
                result.codeResult = codeResult;

                if (capture) {
                  canvas.width = imageSize.x;
                  canvas.height = imageSize.y;
                  image_debug["a" /* default */].drawImage(data, imageSize, ctx);
                  result.frame = canvas.toDataURL();
                }

                results.push(result);
              }
            },
            deleteResult: function deleteResult() {
              results = [1];
            },
            getResults: function getResults() {
              return results;
            }
          };
        }
      });
      // CONCATENATED MODULE: ./src/config/config.dev.ts
      var DevConfig = {
        inputStream: {
          name: 'Live',
          type: 'LiveStream',
          constraints: {
            width: 640,
            height: 480,
            // aspectRatio: 640/480, // optional
            facingMode: 'environment' // or user
            // deviceId: "38745983457387598375983759834"

          },
          area: {
            top: '0%',
            right: '0%',
            left: '0%',
            bottom: '0%'
          },
          singleChannel: false // true: only the red color-channel is read

        },
        locate: true,
        numOfWorkers: 0,
        decoder: {
          readers: ['code_128_reader'],
          debug: {
            drawBoundingBox: false,
            showFrequency: false,
            drawScanline: false,
            showPattern: false
          }
        },
        locator: {
          halfSample: true,
          patchSize: 'medium',
          // x-small, small, medium, large, x-large
          debug: {
            showCanvas: false,
            showPatches: false,
            showFoundPatches: false,
            showSkeleton: false,
            showLabels: false,
            showPatchLabels: false,
            showRemainingPatchLabels: false,
            boxFromPatches: {
              showTransformed: false,
              showTransformedBox: false,
              showBB: false
            }
          }
        }
      };
/* harmony default export */ var config_dev = (DevConfig);
      // CONCATENATED MODULE: ./src/config/config.node.ts
      var NodeConfig = {
        inputStream: {
          type: 'ImageStream',
          sequence: false,
          size: 800,
          area: {
            top: '0%',
            right: '0%',
            left: '0%',
            bottom: '0%'
          },
          singleChannel: false // true: only the red color-channel is read

        },
        locate: true,
        numOfWorkers: 0,
        decoder: {
          readers: ['code_128_reader']
        },
        locator: {
          halfSample: true,
          patchSize: 'medium' // x-small, small, medium, large, x-large

        }
      };
/* harmony default export */ var config_node = (NodeConfig);
      // CONCATENATED MODULE: ./src/config/config.prod.ts
      var ProdConfig = {
        inputStream: {
          name: 'Live',
          type: 'LiveStream',
          constraints: {
            width: 640,
            height: 480,
            // aspectRatio: 640/480, // optional
            facingMode: 'environment' // or user
            // deviceId: "38745983457387598375983759834"

          },
          area: {
            top: '0%',
            right: '0%',
            left: '0%',
            bottom: '0%'
          },
          singleChannel: false // true: only the red color-channel is read

        },
        locate: true,
        numOfWorkers: 4,
        decoder: {
          readers: ['code_128_reader']
        },
        locator: {
          halfSample: true,
          patchSize: 'medium' // x-small, small, medium, large, x-large

        }
      };
/* harmony default export */ var config_prod = (ProdConfig);
      // CONCATENATED MODULE: ./src/config/config.ts


      // @ts-ignore // TODO: this produces a bizarre typescript error
      // eslint-disable-next-line no-nested-ternary

      var QuaggaConfig = true ? config_dev : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
      // EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
      var gl_vec2 = __webpack_require__(7);

      // CONCATENATED MODULE: ./src/QuaggaContext.ts


      var QuaggaContext_QuaggaContext = function QuaggaContext() {
        classCallCheck_default()(this, QuaggaContext);

        defineProperty_default()(this, "config", void 0);

        defineProperty_default()(this, "inputStream", void 0);

        defineProperty_default()(this, "framegrabber", void 0);

        defineProperty_default()(this, "inputImageWrapper", void 0);

        defineProperty_default()(this, "stopped", false);

        defineProperty_default()(this, "boxSize", void 0);

        defineProperty_default()(this, "resultCollector", void 0);

        defineProperty_default()(this, "decoder", void 0);

        defineProperty_default()(this, "workerPool", []);

        defineProperty_default()(this, "onUIThread", true);

        defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
      };
      var QuaggaContext_CanvasInfo = function CanvasInfo() {
        classCallCheck_default()(this, CanvasInfo);

        defineProperty_default()(this, "image", void 0);

        defineProperty_default()(this, "overlay", void 0);
      };
      var QuaggaContext_CanvasContainer = function CanvasContainer() {
        classCallCheck_default()(this, CanvasContainer);

        defineProperty_default()(this, "ctx", void 0);

        defineProperty_default()(this, "dom", void 0);

        this.ctx = new QuaggaContext_CanvasInfo();
        this.dom = new QuaggaContext_CanvasInfo();
      };
      // EXTERNAL MODULE: ./src/locator/barcode_locator.js
      var barcode_locator = __webpack_require__(28);

      // CONCATENATED MODULE: ./src/quagga/initBuffers.ts



      // TODO: need typescript def for BarcodeLocator
      function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
        var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
          x: inputStream.getWidth(),
          y: inputStream.getHeight(),
          type: 'XYSize'
        });

        if (true) {
          console.log("image wrapper size ".concat(inputImageWrapper.size));
        }

        var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
        barcode_locator["a" /* default */].init(inputImageWrapper, locator);
        return {
          inputImageWrapper: inputImageWrapper,
          boxSize: boxSize
        };
      }
      // CONCATENATED MODULE: ./src/quagga/getViewPort.ts
      function getViewPort_getViewPort(target) {
        if (typeof document === 'undefined') {
          return null;
        } // Check if target is already a DOM element


        if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
          return target;
        } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


        var selector = typeof target === 'string' ? target : '#interactive.viewport';
        return document.querySelector(selector);
      }
      // CONCATENATED MODULE: ./src/quagga/initCanvas.ts


      function findOrCreateCanvas(selector, className) {
        var canvas = document.querySelector(selector);

        if (!canvas) {
          canvas = document.createElement('canvas');
          canvas.className = className;
        }

        return canvas;
      }

      function getCanvasAndContext(selector, className) {
        var canvas = findOrCreateCanvas(selector, className);
        var context = canvas.getContext('2d');
        return {
          canvas: canvas,
          context: context
        };
      }

      function initCanvases(canvasSize) {
        if (typeof document !== 'undefined') {
          var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
          var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
          image.canvas.width = overlay.canvas.width = canvasSize.x;
          image.canvas.height = overlay.canvas.height = canvasSize.y;
          return {
            dom: {
              image: image.canvas,
              overlay: overlay.canvas
            },
            ctx: {
              image: image.context,
              overlay: overlay.context
            }
          };
        }

        return null;
      }

      function initCanvas_initCanvas(context) {
        var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

        var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
        var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
        if (!type) return null;
        var container = initCanvases(context.inputStream.getCanvasSize());
        if (!container) return {
          dom: {
            image: null,
            overlay: null
          },
          ctx: {
            image: null,
            overlay: null
          }
        };
        var dom = container.dom;

        if (typeof document !== 'undefined') {
          if (viewport) {
            if (type === 'ImageStream' && !viewport.contains(dom.image)) {
              viewport.appendChild(dom.image);
            }

            if (!viewport.contains(dom.overlay)) {
              viewport.appendChild(dom.overlay);
            }
          }
        }

        return container;
      }
      // CONCATENATED MODULE: ./src/input/exif_helper.js
      // NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
      // How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
      // need to port any part of this that doesn't work in Node to node?
      // Tags scraped from https://github.com/exif-js/exif-js
      var ExifTags = {
        0x0112: 'orientation'
      };
      var AvailableTags = Object.keys(ExifTags).map(function (key) {
        return ExifTags[key];
      });
      function findTagsInObjectURL(src) {
        var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

        if (/^blob:/i.test(src)) {
          return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
            return findTagsInBuffer(buffer, tags);
          });
        }

        return Promise.resolve(null);
      }
      function base64ToArrayBuffer(dataUrl) {
        var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
        var binary = atob(base64);
        var len = binary.length;
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);

        for (var i = 0; i < len; i++) {
          view[i] = binary.charCodeAt(i);
        }

        return buffer;
      }

      function readToBuffer(blob) {
        return new Promise(function (resolve) {
          var fileReader = new FileReader();

          fileReader.onload = function (e) {
            return resolve(e.target.result);
          };

          fileReader.readAsArrayBuffer(blob);
        });
      }

      function objectURLToBlob(url) {
        return new Promise(function (resolve, reject) {
          var http = new XMLHttpRequest();
          http.open('GET', url, true);
          http.responseType = 'blob';

          http.onreadystatechange = function () {
            if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
              resolve(this.response);
            }
          };

          http.onerror = reject;
          http.send();
        });
      }

      function findTagsInBuffer(file) {
        var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
        var dataView = new DataView(file);
        var length = file.byteLength;
        var exifTags = selectedTags.reduce(function (result, selectedTag) {
          var exifTag = Object.keys(ExifTags).filter(function (tag) {
            return ExifTags[tag] === selectedTag;
          })[0];

          if (exifTag) {
            result[exifTag] = selectedTag;
          }

          return result;
        }, {});
        var offset = 2;
        var marker;

        if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
          return false;
        }

        while (offset < length) {
          if (dataView.getUint8(offset) !== 0xFF) {
            return false;
          }

          marker = dataView.getUint8(offset + 1);

          if (marker === 0xE1) {
            return readEXIFData(dataView, offset + 4, exifTags);
          }

          offset += 2 + dataView.getUint16(offset + 2);
        }

        return false;
      }

      function readEXIFData(file, start, exifTags) {
        if (getStringFromBuffer(file, start, 4) !== 'Exif') {
          return false;
        }

        var tiffOffset = start + 6;
        var bigEnd;

        if (file.getUint16(tiffOffset) === 0x4949) {
          bigEnd = false;
        } else if (file.getUint16(tiffOffset) === 0x4D4D) {
          bigEnd = true;
        } else {
          return false;
        }

        if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
          return false;
        }

        var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

        if (firstIFDOffset < 0x00000008) {
          return false;
        }

        var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
        return tags;
      }

      function readTags(file, tiffStart, dirStart, strings, bigEnd) {
        var entries = file.getUint16(dirStart, !bigEnd);
        var tags = {};

        for (var i = 0; i < entries; i++) {
          var entryOffset = dirStart + i * 12 + 2;
          var tag = strings[file.getUint16(entryOffset, !bigEnd)];

          if (tag) {
            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
          }
        }

        return tags;
      }

      function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
        var type = file.getUint16(entryOffset + 2, !bigEnd);
        var numValues = file.getUint32(entryOffset + 4, !bigEnd);

        switch (type) {
          case 3:
            if (numValues === 1) {
              return file.getUint16(entryOffset + 8, !bigEnd);
            }

        }

        return null;
      }

      function getStringFromBuffer(buffer, start, length) {
        var outstr = '';

        for (var n = start; n < start + length; n++) {
          outstr += String.fromCharCode(buffer.getUint8(n));
        }

        return outstr;
      }
      // CONCATENATED MODULE: ./src/input/image_loader.js

      var ImageLoader = {};

      ImageLoader.load = function (directory, callback, offset, size, sequence) {
        var htmlImagesSrcArray = new Array(size);
        var htmlImagesArray = new Array(htmlImagesSrcArray.length);
        var i;
        var img;
        var num;

        if (sequence === false) {
          htmlImagesSrcArray[0] = directory;
        } else {
          for (i = 0; i < htmlImagesSrcArray.length; i++) {
            num = offset + i;
            htmlImagesSrcArray[i] = "".concat(directory, "image-").concat("00".concat(num).slice(-3), ".jpg");
          }
        }

        htmlImagesArray.notLoaded = [];

        htmlImagesArray.addImage = function (image) {
          htmlImagesArray.notLoaded.push(image);
        };

        htmlImagesArray.loaded = function (loadedImg) {
          var notloadedImgs = htmlImagesArray.notLoaded;

          for (var x = 0; x < notloadedImgs.length; x++) {
            if (notloadedImgs[x] === loadedImg) {
              notloadedImgs.splice(x, 1);

              for (var y = 0; y < htmlImagesSrcArray.length; y++) {
                var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/'));

                if (loadedImg.src.lastIndexOf(imgName) !== -1) {
                  htmlImagesArray[y] = {
                    img: loadedImg
                  };
                  break;
                }
              }

              break;
            }
          }

          if (notloadedImgs.length === 0) {
            if (true) {
              console.log('Images loaded');
            }

            if (sequence === false) {
              findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
                htmlImagesArray[0].tags = tags;
                callback(htmlImagesArray);
              })["catch"](function (e) {
                console.log(e);
                callback(htmlImagesArray);
              });
            } else {
              callback(htmlImagesArray);
            }
          }
        };

        for (i = 0; i < htmlImagesSrcArray.length; i++) {
          img = new Image();
          htmlImagesArray.addImage(img);
          addOnloadHandler(img, htmlImagesArray);
          img.src = htmlImagesSrcArray[i];
        }
      };

      function addOnloadHandler(img, htmlImagesArray) {
        img.onload = function () {
          htmlImagesArray.loaded(this);
        };
      }

/* harmony default export */ var image_loader = (ImageLoader);
      // CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
      /* eslint-disable @typescript-eslint/no-explicit-any */

      var inputStreamFactory = {
        createVideoStream: function createVideoStream(video) {
          var _config = null;
          var _eventNames = ['canrecord', 'ended'];
          var _eventHandlers = {};

          var _calculatedWidth;

          var _calculatedHeight;

          var _topRight = {
            x: 0,
            y: 0,
            type: 'Point'
          };
          var _canvasSize = {
            x: 0,
            y: 0,
            type: 'XYSize'
          };

          function initSize() {
            var _config2, _config3;

            var width = video.videoWidth;
            var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary

            _calculatedWidth = ((_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

            _calculatedHeight = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
            _canvasSize.x = _calculatedWidth;
            _canvasSize.y = _calculatedHeight;
          }

          var inputStream = {
            getRealWidth: function getRealWidth() {
              return video.videoWidth;
            },
            getRealHeight: function getRealHeight() {
              return video.videoHeight;
            },
            getWidth: function getWidth() {
              return _calculatedWidth;
            },
            getHeight: function getHeight() {
              return _calculatedHeight;
            },
            setWidth: function setWidth(width) {
              _calculatedWidth = width;
            },
            setHeight: function setHeight(height) {
              _calculatedHeight = height;
            },
            setInputStream: function setInputStream(config) {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
              _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

              this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
            },
            ended: function ended() {
              return video.ended;
            },
            getConfig: function getConfig() {
              return _config;
            },
            setAttribute: function setAttribute(name, value) {
              if (video) {
                video.setAttribute(name, value);
              }
            },
            pause: function pause() {
              video.pause();
            },
            play: function play() {
              // eslint-disable-next-line @typescript-eslint/no-floating-promises
              video.play();
            },
            setCurrentTime: function setCurrentTime(time) {
              var _config4;

              if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
                this.setAttribute('currentTime', time.toString());
              }
            },
            addEventListener: function addEventListener(event, f, bool) {
              if (_eventNames.indexOf(event) !== -1) {
                if (!_eventHandlers[event]) {
                  _eventHandlers[event] = [];
                }

                _eventHandlers[event].push(f);
              } else {
                video.addEventListener(event, f, bool);
              }
            },
            clearEventHandlers: function clearEventHandlers() {
              _eventNames.forEach(function (eventName) {
                var handlers = _eventHandlers[eventName];

                if (handlers && handlers.length > 0) {
                  handlers.forEach(function (handler) {
                    video.removeEventListener(eventName, handler);
                  });
                }
              });
            },
            trigger: function trigger(eventName, args) {
              var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

              var handlers = _eventHandlers[eventName];

              if (eventName === 'canrecord') {
                initSize();
              }

              if (handlers && handlers.length > 0) {
                for (j = 0; j < handlers.length; j++) {
                  handlers[j].apply(inputStream, args);
                }
              }
            },
            setTopRight: function setTopRight(topRight) {
              _topRight.x = topRight.x;
              _topRight.y = topRight.y;
            },
            getTopRight: function getTopRight() {
              return _topRight;
            },
            setCanvasSize: function setCanvasSize(size) {
              _canvasSize.x = size.x;
              _canvasSize.y = size.y;
            },
            getCanvasSize: function getCanvasSize() {
              return _canvasSize;
            },
            getFrame: function getFrame() {
              return video;
            }
          };
          return inputStream;
        },
        createLiveStream: function createLiveStream(video) {
          if (video) {
            video.setAttribute('autoplay', 'true');
          }

          var that = inputStreamFactory.createVideoStream(video);

          that.ended = function ended() {
            return false;
          };

          return that;
        },
        createImageStream: function createImageStream() {
          var _config = null;
          var width = 0;
          var height = 0;
          var frameIdx = 0;
          var paused = true;
          var loaded = false;
          var imgArray = null;
          var size = 0;
          var offset = 1;
          var baseUrl = null;
          var _ended = false;
          var calculatedWidth;
          var calculatedHeight;
          var _eventNames = ['canrecord', 'ended'];
          var _eventHandlers = {};
          var _topRight = {
            x: 0,
            y: 0,
            type: 'Point'
          };
          var _canvasSize = {
            x: 0,
            y: 0,
            type: 'XYSize'
          };

          function loadImages() {
            var _config7;

            loaded = false;
            image_loader.load(baseUrl, function (imgs) {
              var _config5, _config6;

              imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

              if (imgs[0].tags && imgs[0].tags.orientation) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                switch (imgs[0].tags.orientation) {
                  case 6:
                  case 8:
                    width = imgs[0].img.height;
                    height = imgs[0].img.width;
                    break;

                  default:
                    width = imgs[0].img.width;
                    height = imgs[0].img.height;
                }
              } else {
                width = imgs[0].img.width;
                height = imgs[0].img.height;
              } // eslint-disable-next-line no-nested-ternary


              calculatedWidth = ((_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

              calculatedHeight = ((_config6 = _config) === null || _config6 === void 0 ? void 0 : _config6.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
              _canvasSize.x = calculatedWidth;
              _canvasSize.y = calculatedHeight;
              loaded = true;
              frameIdx = 0;
              setTimeout(function () {
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                publishEvent('canrecord', []);
              }, 0);
            }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence);
          }

          function publishEvent(eventName, args) {
            var j;
            var handlers = _eventHandlers[eventName];

            if (handlers && handlers.length > 0) {
              for (j = 0; j < handlers.length; j++) {
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
              }
            }
          } // TODO: any code shared with the first InputStream above should be shared not copied
          // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
          // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
          // eslint-disable-next-line no-var,vars-on-top


          var inputStream = {
            trigger: publishEvent,
            getWidth: function getWidth() {
              return calculatedWidth;
            },
            getHeight: function getHeight() {
              return calculatedHeight;
            },
            setWidth: function setWidth(newWidth) {
              calculatedWidth = newWidth;
            },
            setHeight: function setHeight(newHeight) {
              calculatedHeight = newHeight;
            },
            getRealWidth: function getRealWidth() {
              return width;
            },
            getRealHeight: function getRealHeight() {
              return height;
            },
            setInputStream: function setInputStream(stream) {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
              _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

              if (stream.sequence === false) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
                baseUrl = stream.src;
                size = 1;
              } else {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
                baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

                size = stream.length;
              }

              loadImages();
            },
            ended: function ended() {
              return _ended;
            },
            setAttribute: function setAttribute() { },
            getConfig: function getConfig() {
              return _config;
            },
            pause: function pause() {
              paused = true;
            },
            play: function play() {
              paused = false;
            },
            setCurrentTime: function setCurrentTime(time) {
              frameIdx = time;
            },
            addEventListener: function addEventListener(event, f) {
              if (_eventNames.indexOf(event) !== -1) {
                if (!_eventHandlers[event]) {
                  _eventHandlers[event] = [];
                }

                _eventHandlers[event].push(f);
              }
            },
            clearEventHandlers: function clearEventHandlers() {
              Object.keys(_eventHandlers).forEach(function (ind) {
                return delete _eventHandlers[ind];
              });
            },
            setTopRight: function setTopRight(topRight) {
              _topRight.x = topRight.x;
              _topRight.y = topRight.y;
            },
            getTopRight: function getTopRight() {
              return _topRight;
            },
            setCanvasSize: function setCanvasSize(canvasSize) {
              _canvasSize.x = canvasSize.x;
              _canvasSize.y = canvasSize.y;
            },
            getCanvasSize: function getCanvasSize() {
              return _canvasSize;
            },
            getFrame: function getFrame() {
              var frame;

              if (!loaded) {
                return null;
              }

              if (!paused) {
                var _imgArray;

                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];

                if (frameIdx < size - 1) {
                  frameIdx++;
                } else {
                  setTimeout(function () {
                    _ended = true;
                    publishEvent('ended', []);
                  }, 0);
                }
              } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


              return frame;
            }
          };
          return inputStream;
        }
      };
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
      var slicedToArray = __webpack_require__(39);
      var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

      // EXTERNAL MODULE: ./node_modules/get-pixels/dom-pixels.js
      var dom_pixels = __webpack_require__(104);
      var dom_pixels_default = /*#__PURE__*/__webpack_require__.n(dom_pixels);

      // CONCATENATED MODULE: ./src/input/input_stream/input_stream_node.ts

      // TODO: It's pretty likely that this shares code with the browser version, investigate that

      var input_stream_node_inputStreamFactory = {
        createVideoStream: function createVideoStream() {
          throw new Error('createVideoStream not available');
        },
        createLiveStream: function createLiveStream() {
          throw new Error('createLiveStream not available');
        },
        createImageStream: function createImageStream() {
          var _config = null;
          var width = 0;
          var height = 0;
          var loaded = false; // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions
          // TODO: there is a ts-ndarray that might work, though

          var frame = null;
          var baseUrl;
          var _ended = false;
          var calculatedWidth;
          var calculatedHeight;
          var _eventNames = ['canrecord', 'ended'];
          var _eventHandlers = {};
          var _topRight = {
            x: 0,
            y: 0,
            type: 'Point'
          };
          var _canvasSize = {
            x: 0,
            y: 0,
            type: 'XYSize'
          };
          /* eslint-disable no-unused-vars */
          // false eslint errors? weird.
          // @ts-ignore

          var size = 0; // @ts-ignore

          var frameIdx = 0; // @ts-ignore

          var paused = false;
          /* eslint-enable no-unused-vars */

          function loadImages() {
            var _config2;

            loaded = false;
            /* eslint-disable new-cap */

            dom_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function (err, pixels) {
              var _config3, _config4;

              if (err) {
                console.error('**** quagga loadImages error:', err);
                throw new Error('error decoding pixels in loadImages');
              }

              loaded = true;

              if (true) {
                console.log('* InputStreamNode pixels.shape', pixels.shape);
              } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


              frame = pixels; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

              var _pixels$shape = slicedToArray_default()(pixels.shape, 2);

              width = _pixels$shape[0];
              height = _pixels$shape[1];
              // eslint-disable-next-line no-nested-ternary
              calculatedWidth = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

              calculatedHeight = ((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
              _canvasSize.x = calculatedWidth;
              _canvasSize.y = calculatedHeight;
              setTimeout(function () {
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                publishEvent('canrecord', []);
              }, 0);
            });
          }

          function publishEvent(eventName, args) {
            var handlers = _eventHandlers[eventName];

            if (handlers && handlers.length > 0) {
              for (var j = 0; j < handlers.length; j++) {
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                handlers[j].apply(inputStream, args);
              }
            }
          } // eslint-disable-next-line no-var,vars-on-top


          var inputStream = {
            trigger: publishEvent,
            getWidth: function getWidth() {
              return calculatedWidth;
            },
            getHeight: function getHeight() {
              return calculatedHeight;
            },
            setWidth: function setWidth(w) {
              calculatedWidth = w;
            },
            setHeight: function setHeight(h) {
              calculatedHeight = h;
            },
            getRealWidth: function getRealWidth() {
              return width;
            },
            getRealHeight: function getRealHeight() {
              return height;
            },
            setInputStream: function setInputStream(stream) {
              var _config5;

              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
              _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

              baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;
              size = 1;
              loadImages();
            },
            ended: function ended() {
              return _ended;
            },
            setAttribute: function setAttribute() { },
            getConfig: function getConfig() {
              return _config;
            },
            pause: function pause() {
              paused = true;
            },
            play: function play() {
              paused = false;
            },
            setCurrentTime: function setCurrentTime(time) {
              frameIdx = time;
            },
            addEventListener: function addEventListener(event, f) {
              if (_eventNames.indexOf(event) !== -1) {
                if (!_eventHandlers[event]) {
                  _eventHandlers[event] = [];
                }

                _eventHandlers[event].push(f);
              }
            },
            clearEventHandlers: function clearEventHandlers() {
              Object.keys(_eventHandlers).forEach(function (ind) {
                return delete _eventHandlers[ind];
              });
            },
            setTopRight: function setTopRight(topRight) {
              _topRight.x = topRight.x;
              _topRight.y = topRight.y;
            },
            getTopRight: function getTopRight() {
              return _topRight;
            },
            setCanvasSize: function setCanvasSize(sz) {
              _canvasSize.x = sz.x;
              _canvasSize.y = sz.y;
            },
            getCanvasSize: function getCanvasSize() {
              return _canvasSize;
            },
            getFrame: function getFrame() {
              if (!loaded) {
                return null;
              } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


              return frame;
            }
          };
          return inputStream;
        }
      };
/* harmony default export */ var input_stream_node = (input_stream_node_inputStreamFactory);
// CONCATENATED MODULE: ./src/input/input_stream_factory.ts


/* harmony default export */ var input_stream_factory = (input_stream_browser);

      // EXTERNAL MODULE: ./src/input/frame_grabber_node.js
      var frame_grabber_node = __webpack_require__(99);
      var frame_grabber_node_default = /*#__PURE__*/__webpack_require__.n(frame_grabber_node);

      // EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules
      var cv_utils = __webpack_require__(8);

      // CONCATENATED MODULE: ./src/input/frame_grabber.js


      var TO_RADIANS = Math.PI / 180;

      function adjustCanvasSize(canvas, targetSize) {
        if (canvas.width !== targetSize.x) {
          if (true) {
            console.log('WARNING: canvas-size needs to be adjusted');
          }

          canvas.width = targetSize.x;
        }

        if (canvas.height !== targetSize.y) {
          if (true) {
            console.log('WARNING: canvas-size needs to be adjusted');
          }

          canvas.height = targetSize.y;
        }
      }

      var FrameGrabber = {};

      FrameGrabber.create = function (inputStream, canvas) {
        var _that = {};

        var _streamConfig = inputStream.getConfig();

        var _videoSize = Object(cv_utils["imageRef"])(inputStream.getRealWidth(), inputStream.getRealHeight());

        var _canvasSize = inputStream.getCanvasSize();

        var _size = Object(cv_utils["imageRef"])(inputStream.getWidth(), inputStream.getHeight());

        var topRight = inputStream.getTopRight();
        var _sx = topRight.x;
        var _sy = topRight.y;

        var _canvas;

        var _ctx = null;
        var _data = null;
        _canvas = canvas || document.createElement('canvas');
        _canvas.width = _canvasSize.x;
        _canvas.height = _canvasSize.y;
        _ctx = _canvas.getContext('2d');
        _data = new Uint8Array(_size.x * _size.y);

        if (true) {
          console.log('FrameGrabber', JSON.stringify({
            size: _size,
            topRight: topRight,
            videoSize: _videoSize,
            canvasSize: _canvasSize
          }));
        }
        /**
         * Uses the given array as frame-buffer
         */


        _that.attachData = function (data) {
          _data = data;
        };
        /**
         * Returns the used frame-buffer
         */


        _that.getData = function () {
          return _data;
        };
        /**
         * Fetches a frame from the input-stream and puts into the frame-buffer.
         * The image-data is converted to gray-scale and then half-sampled if configured.
         */


        _that.grab = function () {
          var doHalfSample = _streamConfig.halfSample;
          var frame = inputStream.getFrame();
          var drawable = frame;
          var drawAngle = 0;
          var ctxData;

          if (drawable) {
            adjustCanvasSize(_canvas, _canvasSize);

            if (_streamConfig.type === 'ImageStream') {
              drawable = frame.img;

              if (frame.tags && frame.tags.orientation) {
                switch (frame.tags.orientation) {
                  case 6:
                    drawAngle = 90 * TO_RADIANS;
                    break;

                  case 8:
                    drawAngle = -90 * TO_RADIANS;
                    break;
                }
              }
            }

            if (drawAngle !== 0) {
              _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);

              _ctx.rotate(drawAngle);

              _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);

              _ctx.rotate(-drawAngle);

              _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
            } else {
              _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
            }

            ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;

            if (doHalfSample) {
              Object(cv_utils["grayAndHalfSampleFromCanvasData"])(ctxData, _size, _data);
            } else {
              Object(cv_utils["computeGray"])(ctxData, _data, _streamConfig);
            }

            return true;
          }

          return false;
        };

        _that.getSize = function () {
          return _size;
        };

        return _that;
      };

/* harmony default export */ var frame_grabber = (FrameGrabber);

      // CONCATENATED MODULE: ./src/quagga/qworker.ts


      function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

      /* Worker functions. These are straight from the original quagga.js file.
       * Not presently used, as worker support is non-functional.  Keeping them around temporarily
       * to refer to until it is re-implemented. We may be able to fix/use some of this.
       */
      // TODO: need a typescript interface for FrameGrabber
      var workerPool = [];
      function updateWorkers(frameGrabber) {
        var availableWorker;

        if (workerPool.length) {
          availableWorker = workerPool.filter(function (workerThread) {
            return !workerThread.busy;
          })[0];

          if (availableWorker) {
            frameGrabber.attachData(availableWorker.imageData);

            if (frameGrabber.grab()) {
              availableWorker.busy = true;
              availableWorker.worker.postMessage({
                cmd: 'process',
                imageData: availableWorker.imageData
              }, [availableWorker.imageData.buffer]);
            }

            return true;
          } else {
            return false;
          }
        }

        return null;
      }

      function configForWorker(config) {
        return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
          inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
            target: null
          })
        });
      } // @ts-ignore


      function workerInterface(factory) {
        if (factory) {
          var Quagga = factory()["default"];

          if (!Quagga) {
            // @ts-ignore
            self.postMessage({
              'event': 'error',
              message: 'Quagga could not be created'
            });
            return;
          }
        } // @ts-ignore


        var imageWrapper; // @ts-ignore

        function onProcessed(result) {
          self.postMessage({
            'event': 'processed',
            // @ts-ignore
            imageData: imageWrapper.data,
            result: result // @ts-ignore

          }, [imageWrapper.data.buffer]);
        }

        function workerInterfaceReady() {
          self.postMessage({
            'event': 'initialized',
            // @ts-ignore
            imageData: imageWrapper.data // @ts-ignore

          }, [imageWrapper.data.buffer]);
        } // @ts-ignore


        self.onmessage = function (e) {
          if (e.data.cmd === 'init') {
            var config = e.data.config;
            config.numOfWorkers = 0;
            imageWrapper = new Quagga.ImageWrapper({
              x: e.data.size.x,
              y: e.data.size.y
            }, new Uint8Array(e.data.imageData));
            Quagga.init(config, workerInterfaceReady, imageWrapper);
            Quagga.onProcessed(onProcessed);
          } else if (e.data.cmd === 'process') {
            // @ts-ignore
            imageWrapper.data = new Uint8Array(e.data.imageData);
            Quagga.start();
          } else if (e.data.cmd === 'setReaders') {
            Quagga.setReaders(e.data.readers);
          } else if (e.data.cmd === 'registerReader') {
            Quagga.registerReader(e.data.name, e.data.reader);
          }
        };
      }

      function generateWorkerBlob() {
        var blob, factorySource;
        /* jshint ignore:start */
        // @ts-ignore

        if (typeof __factorySource__ !== 'undefined') {
          // @ts-ignore
          factorySource = __factorySource__; // eslint-disable-line no-undef
        }
        /* jshint ignore:end */


        blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
          type: 'text/javascript'
        });
        return window.URL.createObjectURL(blob);
      }

      function initWorker(config, inputStream, cb) {
        var blobURL = generateWorkerBlob();
        var worker = new Worker(blobURL);
        var workerThread = {
          worker: worker,
          imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
          busy: true
        };

        workerThread.worker.onmessage = function (e) {
          if (e.data.event === 'initialized') {
            URL.revokeObjectURL(blobURL);
            workerThread.busy = false;
            workerThread.imageData = new Uint8Array(e.data.imageData);

            if (true) {
              console.log('Worker initialized');
            }

            cb(workerThread);
          } else if (e.data.event === 'processed') {
            workerThread.imageData = new Uint8Array(e.data.imageData);
            workerThread.busy = false; // TODO: how to thread publishResult into here?
            // publishResult(e.data.result, workerThread.imageData);
          } else if (e.data.event === 'error') {
            if (true) {
              console.log('Worker error: ' + e.data.message);
            }
          }
        };

        workerThread.worker.postMessage({
          cmd: 'init',
          size: {
            x: inputStream.getWidth(),
            y: inputStream.getHeight()
          },
          imageData: workerThread.imageData,
          config: configForWorker(config)
        }, [workerThread.imageData.buffer]);
      }
      function adjustWorkerPool(capacity, config, inputStream, cb) {
        var increaseBy = capacity - workerPool.length;

        if (increaseBy === 0 && cb) {
          cb();
        } else if (increaseBy < 0) {
          var workersToTerminate = workerPool.slice(increaseBy);
          workersToTerminate.forEach(function (workerThread) {
            workerThread.worker.terminate();

            if (true) {
              console.log('Worker terminated!');
            }
          });
          workerPool = workerPool.slice(0, increaseBy);

          if (cb) {
            cb();
          }
        } else {
          var workerInitialized = function workerInitialized(workerThread) {
            workerPool.push(workerThread);

            if (workerPool.length >= capacity && cb) {
              cb();
            }
          };

          if (config) {
            for (var i = 0; i < increaseBy; i++) {
              initWorker(config, inputStream, workerInitialized);
            }
          }
        }
      }
      function qworker_setReaders(readers) {
        workerPool.forEach(function (workerThread) {
          return workerThread.worker.postMessage({
            cmd: 'setReaders',
            readers: readers
          });
        });
      }
      function qworker_registerReader(name, reader) {
        workerPool.forEach(function (workerThread) {
          return workerThread.worker.postMessage({
            cmd: 'registerReader',
            name: name,
            reader: reader
          });
        });
      }
      // CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
      // TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
      function setupInputStream() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
        var viewport = arguments.length > 1 ? arguments[1] : undefined;
        var InputStream = arguments.length > 2 ? arguments[2] : undefined;

        switch (type) {
          case 'VideoStream':
            {
              var video = document.createElement('video');
              return {
                video: video,
                inputStream: InputStream.createVideoStream(video)
              };
            }

          case 'ImageStream':
            return {
              inputStream: InputStream.createImageStream()
            };

          case 'LiveStream':
            {
              var _video = null;

              if (viewport) {
                _video = viewport.querySelector('video');

                if (!_video) {
                  _video = document.createElement('video');
                  viewport.appendChild(_video);
                }
              }

              return {
                video: _video,
                inputStream: InputStream.createLiveStream(_video)
              };
            }

          default:
            console.error("* setupInputStream invalid type ".concat(type));
            return {
              video: null,
              inputStream: null
            };
        }
      }
      // CONCATENATED MODULE: ./src/quagga/transform.ts
      /* eslint-disable no-param-reassign */
      function moveBox(box, xOffset, yOffset) {
        var corner = box.length;

        while (corner--) {
          box[corner][0] += xOffset;
          box[corner][1] += yOffset;
        }
      }
      function moveLine(line, xOffset, yOffset) {
        line[0].x += xOffset;
        line[0].y += yOffset;
        line[1].x += xOffset;
        line[1].y += yOffset;
      }
      // CONCATENATED MODULE: ./src/quagga/quagga.ts

















      var InputStream = typeof window === 'undefined' ? input_stream_node : input_stream_factory;
      var quagga_FrameGrabber = typeof window === 'undefined' ? frame_grabber_node_default.a : frame_grabber;

      var quagga_Quagga = /*#__PURE__*/function () {
        function Quagga() {
          var _this = this;

          classCallCheck_default()(this, Quagga);

          defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

          defineProperty_default()(this, "canRecord", function (callback) {
            var _this$context$config;

            if (!_this.context.config) {
              return;
            }

            barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

            _this.initCanvas();

            _this.context.framegrabber = quagga_FrameGrabber.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

            if (_this.context.config.numOfWorkers === undefined) {
              _this.context.config.numOfWorkers = 0;
            }

            adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
              var _this$context$config2;

              if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
                _this.initializeData();
              }

              _this.ready(callback);
            });
          });

          defineProperty_default()(this, "update", function () {
            if (_this.context.onUIThread) {
              var workersUpdated = updateWorkers(_this.context.framegrabber);

              if (!workersUpdated) {
                var _this$context$inputIm;

                _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

                if (_this.context.framegrabber.grab()) {
                  if (!workersUpdated) {
                    _this.locateAndDecode();
                  }
                }
              }
            } else {
              var _this$context$inputIm2;

              _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

              _this.context.framegrabber.grab();

              _this.locateAndDecode();
            }
          });
        }

        createClass_default()(Quagga, [{
          key: "initBuffers",
          value: function initBuffers(imageWrapper) {
            if (!this.context.config) {
              return;
            }

            var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
              inputImageWrapper = _initBuffers2.inputImageWrapper,
              boxSize = _initBuffers2.boxSize;

            this.context.inputImageWrapper = inputImageWrapper;
            this.context.boxSize = boxSize;
          }
        }, {
          key: "initializeData",
          value: function initializeData(imageWrapper) {
            if (!this.context.config) {
              return;
            }

            this.initBuffers(imageWrapper);
            this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
          }
        }, {
          key: "getViewPort",
          value: function getViewPort() {
            if (!this.context.config || !this.context.config.inputStream) {
              return null;
            }

            var target = this.context.config.inputStream.target;
            return getViewPort_getViewPort(target);
          }
        }, {
          key: "ready",
          value: function ready(callback) {
            this.context.inputStream.play();
            callback();
          }
        }, {
          key: "initCanvas",
          value: function initCanvas() {
            var container = initCanvas_initCanvas(this.context);

            if (!container) {
              return;
            }

            var ctx = container.ctx,
              dom = container.dom;
            this.context.canvasContainer.dom.image = dom.image;
            this.context.canvasContainer.dom.overlay = dom.overlay;
            this.context.canvasContainer.ctx.image = ctx.image;
            this.context.canvasContainer.ctx.overlay = ctx.overlay;
          }
        }, {
          key: "initInputStream",
          value: function initInputStream(callback) {
            if (!this.context.config || !this.context.config.inputStream) {
              return;
            }

            var _this$context$config$ = this.context.config.inputStream,
              inputType = _this$context$config$.type,
              constraints = _this$context$config$.constraints;

            var _setupInputStream = setupInputStream(inputType, this.getViewPort(), InputStream),
              video = _setupInputStream.video,
              inputStream = _setupInputStream.inputStream;

            if (inputType === 'LiveStream' && video) {
              camera_access.request(video, constraints).then(function () {
                return inputStream.trigger('canrecord');
              })["catch"](function (err) {
                return callback(err);
              });
            }

            inputStream.setAttribute('preload', 'auto');
            inputStream.setInputStream(this.context.config.inputStream);
            inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
            this.context.inputStream = inputStream;
          }
        }, {
          key: "getBoundingBoxes",
          value: function getBoundingBoxes() {
            var _this$context$config3;

            return ((_this$context$config3 = this.context.config) === null || _this$context$config3 === void 0 ? void 0 : _this$context$config3.locate) ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
          } // TODO: need a typescript type for result here.
          // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

        }, {
          key: "transformResult",
          value: function transformResult(result) {
            var _this2 = this;

            var topRight = this.context.inputStream.getTopRight();
            var xOffset = topRight.x;
            var yOffset = topRight.y;

            if (xOffset === 0 && yOffset === 0) {
              return;
            }

            if (result.barcodes) {
              // TODO: BarcodeInfo may not be the right type here.
              result.barcodes.forEach(function (barcode) {
                return _this2.transformResult(barcode);
              });
            }

            if (result.line && result.line.length === 2) {
              moveLine(result.line, xOffset, yOffset);
            }

            if (result.box) {
              moveBox(result.box, xOffset, yOffset);
            }

            if (result.boxes && result.boxes.length > 0) {
              for (var i = 0; i < result.boxes.length; i++) {
                moveBox(result.boxes[i], xOffset, yOffset);
              }
            }
          }
        }, {
          key: "addResult",
          value: function addResult(result, imageData) {
            var _this3 = this;

            if (!imageData || !this.context.resultCollector) {
              return;
            } // TODO: Figure out what data structure holds a "barcodes" result, if any...


            if (result.barcodes) {
              result.barcodes.filter(function (barcode) {
                return barcode.codeResult;
              }).forEach(function (barcode) {
                return _this3.addResult(barcode, imageData);
              });
            } else if (result.codeResult) {
              this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
            }
          } // eslint-disable-next-line class-methods-use-this

        }, {
          key: "hasCodeResult",
          value: function hasCodeResult(result) {
            return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
              return barcode.codeResult;
            }) : result.codeResult));
          } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

        }, {
          key: "publishResult",
          value: function publishResult() {
            var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var imageData = arguments.length > 1 ? arguments[1] : undefined;
            var resultToPublish = result;

            if (result && this.context.onUIThread) {
              this.transformResult(result);
              this.addResult(result, imageData);
              resultToPublish = result.barcodes || result;
            }

            events.publish('processed', resultToPublish);

            if (this.hasCodeResult(result)) {
              events.publish('detected', resultToPublish);
            }
          }
        }, {
          key: "locateAndDecode",
          value: function locateAndDecode() {
            var boxes = this.getBoundingBoxes();

            if (boxes) {
              var _this$context$inputIm3;

              var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
              decodeResult.boxes = boxes;
              this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
            } else {
              var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

              if (imageResult) {
                var _this$context$inputIm4;

                this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
              } else {
                this.publishResult();
              }
            }
          }
        }, {
          key: "startContinuousUpdate",
          value: function startContinuousUpdate() {
            var _this$context$config4,
              _this4 = this;

            var next = null;
            var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
            this.context.stopped = false;
            var context = this.context;

            var newFrame = function newFrame(timestamp) {
              next = next || timestamp;

              if (!context.stopped) {
                if (timestamp >= next) {
                  next += delay;

                  _this4.update();
                }

                window.requestAnimationFrame(newFrame);
              }
            };

            newFrame(performance.now());
          }
        }, {
          key: "start",
          value: function start() {
            var _this$context$config5, _this$context$config6;

            if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
              this.startContinuousUpdate();
            } else {
              this.update();
            }
          }
        }, {
          key: "stop",
          value: function stop() {
            var _this$context$config7;

            this.context.stopped = true;
            adjustWorkerPool(0);

            if (((_this$context$config7 = this.context.config) === null || _this$context$config7 === void 0 ? void 0 : _this$context$config7.inputStream) && this.context.config.inputStream.type === 'LiveStream') {
              camera_access.release();
              this.context.inputStream.clearEventHandlers();
            }
          }
        }, {
          key: "setReaders",
          value: function setReaders(readers) {
            if (this.context.decoder) {
              this.context.decoder.setReaders(readers);
            }

            qworker_setReaders(readers);
          }
        }, {
          key: "registerReader",
          value: function registerReader(name, reader) {
            barcode_decoder.registerReader(name, reader);

            if (this.context.decoder) {
              this.context.decoder.registerReader(name, reader);
            }

            qworker_registerReader(name, reader);
          }
        }]);

        return Quagga;
      }();


      // CONCATENATED MODULE: ./src/quagga.js

      // eslint-disable-line no-unused-vars











      var instance = new quagga_Quagga();
      var _context = instance.context;
      var QuaggaJSStaticInterface = {
        init: function init(config, cb, imageWrapper) {
          var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
          var promise;

          if (!cb) {
            promise = new Promise(function (resolve, reject) {
              cb = function cb(err) {
                err ? reject(err) : resolve();
              };
            });
          }

          quaggaInstance.context.config = merge_default()({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

          if (quaggaInstance.context.config.numOfWorkers > 0) {
            quaggaInstance.context.config.numOfWorkers = 0;
          }

          if (imageWrapper) {
            quaggaInstance.context.onUIThread = false;
            quaggaInstance.initializeData(imageWrapper);

            if (cb) {
              cb();
            }
          } else {
            quaggaInstance.initInputStream(cb);
          }

          return promise;
        },
        start: function start() {
          instance.start();
        },
        stop: function stop() {
          instance.stop();
        },
        pause: function pause() {
          _context.stopped = true;
        },
        onDetected: function onDetected(callback) {
          if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
            console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
            return;
          }

          events.subscribe('detected', callback);
        },
        offDetected: function offDetected(callback) {
          events.unsubscribe('detected', callback);
        },
        onProcessed: function onProcessed(callback) {
          if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
            console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
            return;
          }

          events.subscribe('processed', callback);
        },
        offProcessed: function offProcessed(callback) {
          events.unsubscribe('processed', callback);
        },
        setReaders: function setReaders(readers) {
          if (!readers) {
            console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
            return;
          }

          instance.setReaders(readers);
        },
        registerReader: function registerReader(name, reader) {
          if (!name) {
            console.trace('* warning: Quagga.registerReader called with no name, ignoring');
            return;
          }

          if (!reader) {
            console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
            return;
          }

          instance.registerReader(name, reader);
        },
        registerResultCollector: function registerResultCollector(resultCollector) {
          if (resultCollector && typeof resultCollector.addResult === 'function') {
            _context.resultCollector = resultCollector;
          }
        },

        get canvas() {
          return _context.canvasContainer;
        },

        decodeSingle: function decodeSingle(config, resultCallback) {
          var _this = this;

          var quaggaInstance = new quagga_Quagga();
          config = merge_default()({
            inputStream: {
              type: 'ImageStream',
              sequence: false,
              size: 800,
              src: config.src
            },
            numOfWorkers: true && config.debug ? 0 : 1,
            locator: {
              halfSample: false
            }
          }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
          // https://webpack.js.org/loaders/worker-loader/

          if (config.numOfWorkers > 0) {
            config.numOfWorkers = 0;
          } // workers require Worker and Blob support presently, so if no Blob or Worker then set
          // workers to 0.


          if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
            console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
            config.numOfWorkers = 0;
          }

          return new Promise(function (resolve, reject) {
            try {
              _this.init(config, function () {
                events.once('processed', function (result) {
                  quaggaInstance.stop();

                  if (resultCallback) {
                    resultCallback.call(null, result);
                  }

                  resolve(result);
                }, true);
                quaggaInstance.start();
              }, null, quaggaInstance);
            } catch (err) {
              reject(err);
            }
          });
        },

        // add the usually expected "default" for use with require, build step won't allow us to
        // write to module.exports so do it here.
        get default() {
          return QuaggaJSStaticInterface;
        },

        BarcodeReader: barcode_reader,
        CameraAccess: camera_access,
        ImageDebug: image_debug["a" /* default */],
        ImageWrapper: image_wrapper["a" /* default */],
        ResultCollector: result_collector
      };
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



      /***/
    })
/******/])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jdl91dGlscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vYXJyYXlfaGVscGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3RyYWNlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyX25vZGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nZXQtcGl4ZWxzL2RvbS1waXhlbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jb3B5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvYWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1Yi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tdWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2VpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3VuZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbm9ybWFsaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RvdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcm9zcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZXJwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDJkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0NC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mb3JFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xpbWl0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2FuZ2xlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9leGFjdEVxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3ViLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdW5kLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyTGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nyb3NzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2xlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0My5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1RdWF0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZmxhdFJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2RldGVybWluYW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9tdWx0aXBseS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9hZGpvaW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvZnJvYi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9sZHUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL29tZ2dpZi9vbWdnaWYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9jb252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svZG9Db252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvdW5pcS91bmlxLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy90aHJvdWdoL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS91dGlsIChpZ25vcmVkKSIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhL3V0aWwgKGlnbm9yZWQpPzhkNTciLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZGF0YS11cmktdG8tYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZS9pbnRlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9pMm9mNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vZXZlbnRzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5kZXYudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcubm9kZS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5wcm9kLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9RdWFnZ2FDb250ZXh0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdEJ1ZmZlcnMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9nZXRWaWV3UG9ydC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2V4aWZfaGVscGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbWFnZV9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fYnJvd3Nlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9ub2RlLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F3b3JrZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9zZXR1cElucHV0U3RyZWFtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvdHJhbnNmb3JtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvcXVhZ2dhLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EuanMiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX2dldFByb3RvdHlwZU9mIiwibyIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX3R5cGVvZiIsInJlcXVpcmUiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIkVQU0lMT04iLCJjbG9uZSIsImZyb21WYWx1ZXMiLCJjb3B5Iiwic2V0IiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJhZGQiLCJzdWJ0cmFjdCIsInN1YiIsIm11bHRpcGx5IiwibXVsIiwiZGl2aWRlIiwiZGl2IiwiaW52ZXJzZSIsIm1pbiIsIm1heCIsInJvdGF0ZSIsImZsb29yIiwiY2VpbCIsInJvdW5kIiwic2NhbGUiLCJzY2FsZUFuZEFkZCIsImRpc3RhbmNlIiwiZGlzdCIsInNxdWFyZWREaXN0YW5jZSIsInNxckRpc3QiLCJsZW4iLCJzcXVhcmVkTGVuZ3RoIiwic3FyTGVuIiwibmVnYXRlIiwibm9ybWFsaXplIiwiZG90IiwiY3Jvc3MiLCJsZXJwIiwicmFuZG9tIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwidHJhbnNmb3JtTWF0MyIsInRyYW5zZm9ybU1hdDQiLCJmb3JFYWNoIiwibGltaXQiLCJ2ZWMyIiwicG9pbnQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJjZW50ZXIiLCJyYWQiLCJ2ZWMiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInB1c2giLCJ1cGRhdGVDZW50ZXIiLCJzdW0iLCJNYXRoIiwiY29zIiwic2luIiwiaW5pdCIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwieCIsInkiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwibWF4SW5kZXgiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwia2VybmVsIiwiQSIsIkIiLCJDIiwiRCIsImF2ZyIsImNsdXN0ZXIiLCJ0aGlzQ2x1c3RlciIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwiZm91bmQiLCJDbHVzdGVyMiIsIlRyYWNlciIsInRyYWNlIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsInJlc3VsdCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwidG8iLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwiYUltYWdlV3JhcHBlciIsImJJbWFnZVdyYXBwZXIiLCJyZXN1bHRJbWFnZVdyYXBwZXIiLCJhSW1hZ2VEYXRhIiwiYkltYWdlRGF0YSIsImNJbWFnZURhdGEiLCJiaXR3aXNlT3IiLCJjb3VudE5vblplcm8iLCJ0b3BHZW5lcmljIiwibGlzdCIsInNjb3JlRnVuYyIsIm1pbklkeCIsInF1ZXVlIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiYXBwbHkiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiY3R4IiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJsIiwic2luZ2xlQ2hhbm5lbCIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FsbGJhY2siLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImhzdjJyZ2IiLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJiIiwiX2NvbXB1dGVEaXZpc29ycyIsIm4iLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0IiwidW5zaGlmdCIsImNvbmNhdCIsIl9jb21wdXRlSW50ZXJzZWN0aW9uIiwiYXJyMSIsImFycjIiLCJqIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJyZWR1Y2UiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwicHV0SW1hZ2VEYXRhIiwiYXJyIiwidmFsIiwic2h1ZmZsZSIsInRvUG9pbnRMaXN0Iiwicm93cyIsInAiLCJyb3ciLCJqb2luIiwicHJldiIsIm5leHQiLCJhc3NlcnROdW1iZXJQb3NpdGl2ZSIsIkVycm9yIiwiSW1hZ2VXcmFwcGVyIiwiQXJyYXlUeXBlIiwiaW5pdGlhbGl6ZSIsImltZ1JlZiIsImJvcmRlciIsInNpemVYIiwic2l6ZVkiLCJpbmRleE1hcHBpbmciLCJsYWJlbENvdW50IiwieXNxIiwibGFiZWxTdW0iLCJsYWJlbCIsIm11MTEiLCJtdTAyIiwibXUyMCIsInhfIiwieV8iLCJ0bXAiLCJQSSIsIlBJXzQiLCJtMDAiLCJtMDEiLCJtMTAiLCJtMTEiLCJtMDIiLCJtMjAiLCJ0aGV0YSIsImlzTmFOIiwiYXRhbiIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50IiwiZ2V0IiwiZnJhbWUiLCJnZXRBc1JHQkEiLCJuZXdGcmFtZSIsIkltYWdlRGF0YSIsImluU2NhbGUiLCJhZGp1c3RlZFNjYWxlIiwid2hpdGVSZ2IiLCJibGFja1JnYiIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsImlzT2JqZWN0IiwidHlwZSIsImlzQXJyYXkiLCJBcnJheSIsInByb2Nlc3MiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiYXJndW1lbnRzIiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwicG5hIiwib2JqZWN0S2V5cyIsIkR1cGxleCIsInV0aWwiLCJpbmhlcml0cyIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJtZXRob2QiLCJvcHRpb25zIiwicmVhZGFibGUiLCJhbGxvd0hhbGZPcGVuIiwib25lbmQiLCJfd3JpdGFibGVTdGF0ZSIsImhpZ2hXYXRlck1hcmsiLCJlbmRlZCIsIm9uRW5kTlQiLCJfcmVhZGFibGVTdGF0ZSIsInVuZGVmaW5lZCIsImRlc3Ryb3llZCIsIl9kZXN0cm95IiwiZXJyIiwiY2IiLCJiYXNlTWVyZ2UiLCJjcmVhdGVBc3NpZ25lciIsIm1lcmdlIiwib2JqZWN0Iiwic291cmNlIiwic3JjSW5kZXgiLCJzdXBlclByb3BCYXNlIiwiX2dldCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsImlzT2JqZWN0TGlrZSIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJUZW1wQ3RvciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2VhcmNoRGlyZWN0aW9ucyIsImxhYmVsV3JhcHBlciIsImxhYmVsRGF0YSIsImVkZ2VsYWJlbCIsImN5IiwiY3giLCJ2ZXJ0ZXgyRCIsImNvbnRvdXJUcmFjaW5nIiwiRnYiLCJDdiIsIlAiLCJsZGlyIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJiYXNlNjQiLCJpZWVlNzU0IiwiQnVmZmVyIiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImdsb2JhbCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImZvbyIsInN1YmFycmF5IiwiYnl0ZUxlbmd0aCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsInNwZWNpZXMiLCJhc3NlcnRTaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYnl0ZU9mZnNldCIsImlzQnVmZmVyIiwiYnVmZmVyIiwiaXNuYW4iLCJ0b1N0cmluZyIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsInN0YXJ0IiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJpbnNwZWN0Iiwic3RyIiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwiZnJvbUJ5dGVBcnJheSIsInJlcyIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIm9iamVjdFdyaXRlVUludDE2IiwibGl0dGxlRW5kaWFuIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDE2QkUiLCJvYmplY3RXcml0ZVVJbnQzMiIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY29kZSIsImNoYXJDb2RlQXQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInJlcGxhY2UiLCJ0cmltIiwidW5pdHMiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJoaSIsImxvIiwidG9CeXRlQXJyYXkiLCJkc3QiLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiaXNSZWdFeHAiLCJyZSIsImlzRGF0ZSIsImQiLCJpc0Vycm9yIiwiaXNGdW5jdGlvbiIsImlzUHJpbWl0aXZlIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsInNrZWxldG9uaXplciIsImluaXRDYW52YXMiLCJ1c2VXb3JrZXIiLCJjbGFzc05hbWUiLCJFTlYiLCJkZWJ1ZyIsInNob3dDYW52YXMiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJib3hGcm9tUGF0Y2hlcyIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJib3giLCJzaG93UGF0Y2hlcyIsIkltYWdlRGVidWciLCJtYXQyIiwic2hvd1RyYW5zZm9ybWVkIiwic2hvd1RyYW5zZm9ybWVkQm94Iiwic2hvd0JCIiwiYmluYXJpemVJbWFnZSIsInplcm9Cb3JkZXIiLCJzaG93IiwiZmluZFBhdGNoZXMiLCJtb21lbnRzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsInNob3dMYWJlbHMiLCJvdmVybGF5IiwiY291bnQiLCJkZXNjcmliZVBhdGNoIiwic2hvd0ZvdW5kUGF0Y2hlcyIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsIm1hcCIsInNvcnQiLCJmaWx0ZXIiLCJlbCIsImZpbmRCb3hlcyIsImJveGVzIiwic2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzIiwic2ltaWxhck1vbWVudHMiLCJ0b3BDbHVzdGVyIiwic3ViSW1hZ2VBc0NvcHkiLCJzaG93U2tlbGV0b24iLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsImluZGV4IiwicmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkiLCJjdXJySWR4Iiwibm90WWV0UHJvY2Vzc2VkIiwiY3VycmVudElkeCIsImN1cnJlbnRQYXRjaCIsInNob3dQYXRjaExhYmVscyIsImlucHV0SW1hZ2VXcmFwcGVyIiwibG9jYXRlIiwiY2hlY2tJbWFnZUNvbnN0cmFpbnRzIiwiaW5wdXRTdHJlYW0iLCJnZXRXaWR0aCIsImdldEhlaWdodCIsInRoaXNIYWxmU2FtcGxlIiwiZ2V0Q29uZmlnIiwic2V0VG9wUmlnaHQiLCJzZXRDYW52YXNTaXplIiwiY29uc29sZSIsImxvZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRXaWR0aCIsInNldEhlaWdodCIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJoYXMiLCJlcSIsImFzc29jSW5kZXhPZiIsIm90aGVyIiwiZ2V0TmF0aXZlIiwibmF0aXZlQ3JlYXRlIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIl9fZGF0YV9fIiwiYmFzZUlzQXJndW1lbnRzIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwiY2FzdFBhdGgiLCJmbiIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFmdGVyVGlja09uZSIsImFmdGVyVGlja1R3byIsImFmdGVyVGlja1RocmVlIiwiYWZ0ZXJUaWNrIiwiYXJyYXlXaXRoSG9sZXMiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnJheVdpdGhvdXRIb2xlcyIsIml0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlU3ByZWFkIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93IiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJkZXRlcm1pbmFudCIsInRyYW5zcG9zZSIsImlkZW50aXR5IiwiYWRqb2ludCIsImludmVydCIsImZyb2IiLCJsZHUiLCJiYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwidGFnIiwiYmFzZUFzc2lnblZhbHVlIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJjaGlsZHJlbiIsImlzTGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJzeW1ib2xUYWciLCJJTkZJTklUWSIsInRvS2V5IiwiaW90YSIsImhhc1R5cGVkQXJyYXlzIiwiRmxvYXQ2NEFycmF5IiwiY29tcGFyZTFzdCIsIm9yZGVyIiwic3RyaWRlIiwidGVybXMiLCJjb21waWxlQ29uc3RydWN0b3IiLCJkdHlwZSIsInVzZUdldHRlcnMiLCJwcm9jZWR1cmUiLCJDQUNIRURfQ09OU1RSVUNUT1JTIiwiaW5kaWNlcyIsImluZGV4X3N0ciIsInNoYXBlQXJnIiwic3RyaWRlQXJnIiwiYV92YXJzIiwiY192YXJzIiwidFNoYXBlIiwidFN0cmlkZSIsImFycmF5RFR5cGUiLCJ3cmFwcGVkTkRBcnJheUN0b3IiLCJzaGFwZSIsInN6IiwiY3Rvcl9saXN0IiwiUiIsIlJlZmxlY3RBcHBseSIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJQcm9jZXNzRW1pdFdhcm5pbmciLCJ3YXJuaW5nIiwid2FybiIsIk51bWJlcklzTmFOIiwiRXZlbnRFbWl0dGVyIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsImRvRXJyb3IiLCJldmVudHMiLCJlciIsIm1lc3NhZ2UiLCJoYW5kbGVyIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwid2FybmVkIiwidyIsImVtaXR0ZXIiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwiYmluZCIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNoaWZ0Iiwic3BsaWNlT25lIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsInBvcCIsImV2ZW50TGlzdGVuZXIiLCJlcnJvckxpc3RlbmVyIiwiU3RyZWFtIiwiVHJhbnNmb3JtIiwiUGFzc1Rocm91Z2giLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiV3JpdGVSZXEiLCJjaHVuayIsIkNvcmtlZFJlcXVlc3QiLCJfdGhpcyIsImZpbmlzaCIsIm9uQ29ya2VkRmluaXNoIiwiYXN5bmNXcml0ZSIsInNldEltbWVkaWF0ZSIsIldyaXRhYmxlU3RhdGUiLCJpbnRlcm5hbFV0aWwiLCJPdXJVaW50OEFycmF5IiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsIl9pc1VpbnQ4QXJyYXkiLCJkZXN0cm95SW1wbCIsIm5vcCIsInN0cmVhbSIsImlzRHVwbGV4Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImh3bSIsIndyaXRhYmxlSHdtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwiZGVmYXVsdEh3bSIsImZpbmFsQ2FsbGVkIiwibmVlZERyYWluIiwiZW5kaW5nIiwiZmluaXNoZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJkZWZhdWx0RW5jb2RpbmciLCJ3cml0aW5nIiwiY29ya2VkIiwic3luYyIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwid3JpdGVjYiIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJnZXRCdWZmZXIiLCJfIiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJfd3JpdGUiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZGVzdHJveSIsImZpbmFsIiwiX2ZpbmFsIiwicGlwZSIsIndyaXRlQWZ0ZXJFbmQiLCJ2YWxpZENodW5rIiwidmFsaWQiLCJpc0J1ZiIsIndyaXRlT3JCdWZmZXIiLCJjb3JrIiwidW5jb3JrIiwiY2xlYXJCdWZmZXIiLCJzZXREZWZhdWx0RW5jb2RpbmciLCJkZWNvZGVDaHVuayIsIm5ld0NodW5rIiwibGFzdCIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwicHJlZmluaXNoIiwibmVlZCIsImNvcmtSZXEiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95IiwiYXJyYXlMaWtlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwiRmxvYXQzMkFycmF5IiwieiIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImZ1bmMiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwicHJvdG8iLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJuYXRpdmVJc0J1ZmZlciIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJub2RlVXRpbCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJzYWZlR2V0IiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImFycmF5TGlrZUtleXMiLCJiYXNlS2V5c0luIiwia2V5c0luIiwibmF0aXZlTWF4Iiwib3ZlclJlc3QiLCJ0cmFuc2Zvcm0iLCJvdGhlckFyZ3MiLCJiYXNlU2V0VG9TdHJpbmciLCJzaG9ydE91dCIsInNldFRvU3RyaW5nIiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiRUVsaXN0ZW5lckNvdW50IiwiZGVidWdVdGlsIiwiZGVidWdsb2ciLCJCdWZmZXJMaXN0IiwiU3RyaW5nRGVjb2RlciIsImtQcm94eUV2ZW50cyIsImV2ZW50IiwicmVhZGFibGVPYmplY3RNb2RlIiwicmVhZGFibGVId20iLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsInJlc3VtZVNjaGVkdWxlZCIsImF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRlY29kZXIiLCJfcmVhZCIsInNraXBDaHVua0NoZWNrIiwicmVhZGFibGVBZGRDaHVuayIsImFkZFRvRnJvbnQiLCJvbkVvZkNodW5rIiwiY2h1bmtJbnZhbGlkIiwiYWRkQ2h1bmsiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwiZW1pdFJlYWRhYmxlIiwiaXNQYXVzZWQiLCJzZXRFbmNvZGluZyIsImVuYyIsIk1BWF9IV00iLCJjb21wdXRlTmV3SGlnaFdhdGVyTWFyayIsImhvd011Y2hUb1JlYWQiLCJoZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsImRlc3QiLCJwaXBlT3B0cyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJ1bnBpcGUiLCJvbnVucGlwZSIsInVucGlwZUluZm8iLCJoYXNVbnBpcGVkIiwiY2xlYW51cCIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsImNsZWFuZWRVcCIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZXJyb3IiLCJvbmRhdGEiLCJpbmNyZWFzZWRBd2FpdERyYWluIiwicGF1c2UiLCJyZXN1bWUiLCJkZXN0cyIsInNwbGljZSIsImV2IiwiblJlYWRpbmdOZXh0VGljayIsInJlc3VtZV8iLCJ3cmFwIiwicGF1c2VkIiwiX2Zyb21MaXN0IiwiZnJvbUxpc3RQYXJ0aWFsIiwiaGFzU3RyaW5ncyIsImNvcHlGcm9tQnVmZmVyU3RyaW5nIiwiY29weUZyb21CdWZmZXIiLCJuYiIsInRhaWwiLCJlbmRSZWFkYWJsZU5UIiwieHMiLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW1pdEVycm9yTlQiLCJfbm9ybWFsaXplRW5jb2RpbmciLCJyZXRyaWVkIiwibm9ybWFsaXplRW5jb2RpbmciLCJuZW5jIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwidXRmOENoZWNrRXh0cmFCeXRlcyIsInRvdGFsIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJ0cyIsIl90cmFuc2Zvcm1TdGF0ZSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2h1bmsiLCJycyIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwiX3RyYW5zZm9ybSIsImZsdXNoIiwiX2ZsdXNoIiwiX3RoaXMyIiwiZXJyMiIsIkNWVXRpbHMiLCJOZGFycmF5IiwiSW50ZXJwMkQiLCJkMiIsIkZyYW1lR3JhYmJlciIsIl90aGF0IiwiX3ZpZGVvU2l6ZSIsImdldFJlYWxXaWR0aCIsImdldFJlYWxIZWlnaHQiLCJfY2FudmFzU2l6ZSIsImdldENhbnZhc1NpemUiLCJfc2l6ZSIsIl90b3BSaWdodCIsImdldFRvcFJpZ2h0IiwiX2RhdGEiLCJfZ3JheURhdGEiLCJfY2FudmFzRGF0YSIsIl9ncmF5SW1hZ2VBcnJheSIsIl9jYW52YXNJbWFnZUFycmF5IiwiX3RhcmdldEltYWdlQXJyYXkiLCJfc3RlcFNpemVYIiwiX3N0ZXBTaXplWSIsInZpZGVvU2l6ZSIsImNhbnZhc1NpemUiLCJzdGVwU2l6ZSIsInRvcFJpZ2h0IiwiYXR0YWNoRGF0YSIsImdldERhdGEiLCJncmFiIiwiZ2V0RnJhbWUiLCJzY2FsZUFuZENyb3AiLCJnZXRTaXplIiwiYW5nbGUiLCJ0cmFuc2Zvcm1RdWF0Iiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwiYmFzZVBpY2siLCJmbGF0UmVzdCIsInBpY2siLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRyYXdDb250b3VyIiwiZmlyc3RDb250b3VyIiwicHEiLCJpcSIsInEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiaW1hZ2VzIiwiaW11bCIsImluSW1hZ2VQdHIiLCJvdXRJbWFnZVB0ciIsImFJbWFnZVB0ciIsImJJbWFnZVB0ciIsImltYWdlUHRyIiwibWVtY3B5Iiwic3JjSW1hZ2VQdHIiLCJkc3RJbWFnZVB0ciIsInN1YkltYWdlUHRyIiwiZXJvZGVkSW1hZ2VQdHIiLCJ0ZW1wSW1hZ2VQdHIiLCJza2VsSW1hZ2VQdHIiLCJuZGFycmF5IiwiR2lmUmVhZGVyIiwicGFjayIsInRocm91Z2giLCJwYXJzZURhdGFVUkkiLCJkZWZhdWx0SW1hZ2UiLCJ1cmwiLCJjcm9zc09yaWdpbiIsInBpeGVscyIsImhhbmRsZUdpZiIsInJlYWRlciIsIm51bUZyYW1lcyIsIm5zaGFwZSIsIm5kYXRhIiwiZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSIsImh0dHBHaWYiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvdmVycmlkZU1pbWVUeXBlIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlIiwic2VuZCIsImNvcHlCdWZmZXIiLCJkYXRhR2lmIiwiZ2V0UGl4ZWxzIiwiZXh0bmFtZSIsInRvVXBwZXJDYXNlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWgiLCJhbCIsImJoIiwiYmwiLCJhc3NpZ24iLCJuZXh0U291cmNlIiwibmV4dEtleSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiX3MiLCJfbm9uSXRlcmFibGVSZXN0IiwiYTAiLCJhMSIsImIwIiwiYjEiLCJ0IiwiYXgiLCJheSIsIm1TcSIsInRlbXBBIiwidGVtcEIiLCJjb3NpbmUiLCJhY29zIiwiYTIiLCJiMiIsImF6IiwiYngiLCJieSIsImJ6IiwielNjYWxlIiwicXgiLCJxeSIsInF6IiwicXciLCJpeCIsIml5IiwiaXoiLCJpdyIsInB5IiwicHoiLCJfc2V0UHJvdG90eXBlT2YiLCJTdGFjayIsImJhc2VGb3IiLCJiYXNlTWVyZ2VEZWVwIiwiY3VzdG9taXplciIsInN0YWNrIiwic3JjVmFsdWUiLCJuZXdWYWx1ZSIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsImFycmF5UHJvdG8iLCJsYXN0SW5kZXgiLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJpc01hc2tlZCIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInBhdHRlcm4iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidW5tYXNrZWQiLCJjb3JlSnNEYXRhIiwibWFza1NyY0tleSIsInVpZCIsImV4ZWMiLCJJRV9QUk9UTyIsIkhhc2giLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSEFTSF9VTkRFRklORUQiLCJjcmVhdGVCYXNlRm9yIiwiZnJvbVJpZ2h0IiwiaXRlcmF0ZWUiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwiY2xvbmVCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkiLCJjb3B5QXJyYXkiLCJpbml0Q2xvbmVPYmplY3QiLCJpc0FycmF5TGlrZU9iamVjdCIsImlzUGxhaW5PYmplY3QiLCJ0b1BsYWluT2JqZWN0IiwibWVyZ2VGdW5jIiwic3RhY2tlZCIsImlzQ29tbW9uIiwiaXNBcnIiLCJpc0J1ZmYiLCJpc1R5cGVkIiwiaXNEZWVwIiwiY2xvbmVBcnJheUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJhcnJheUJ1ZmZlciIsImJhc2VDcmVhdGUiLCJvYmplY3RDcmVhdGUiLCJhcmdzVGFnIiwib2JqZWN0VGFnIiwib2JqZWN0Q3RvclN0cmluZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJmcmVlUHJvY2VzcyIsInR5cGVzIiwiY29weU9iamVjdCIsImlzTmV3IiwiYmFzZVRpbWVzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlUmVzdCIsImlzSXRlcmF0ZWVDYWxsIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJ0aGlzQXJnIiwiY29uc3RhbnQiLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIkRhdGUiLCJub3ciLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiaXRlciIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIl9zdXBlclByb3BCYXNlIiwicnVudGltZSIsIk9wIiwiaGFzT3duIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsIm1hcmsiLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsInJldmVyc2UiLCJpdGVyYXRvck1ldGhvZCIsInNraXBUZW1wUmVzZXQiLCJjaGFyQXQiLCJzdG9wIiwicm9vdEVudHJ5Iiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJhY2NpZGVudGFsU3RyaWN0TW9kZSIsImJhc2VQaWNrQnkiLCJoYXNJbiIsImJhc2VHZXQiLCJiYXNlU2V0IiwicHJlZGljYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsIm1lbW9pemVDYXBwZWQiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsImNhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwiYmFzZVRvU3RyaW5nIiwiYXJyYXlNYXAiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwibmVzdGVkIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJmbGF0dGVuIiwiYmFzZUZsYXR0ZW4iLCJhcnJheVB1c2giLCJpc0ZsYXR0ZW5hYmxlIiwiZGVwdGgiLCJpc1N0cmljdCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJhMyIsImIzIiwiZGV0IiwidjAiLCJ2MSIsIkwiLCJVIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiZ2V0TGVucyIsImI2NCIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwiTE4yIiwibm9ybWFsaXplQXJyYXkiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwicmVzb2x2ZWRQYXRoIiwicmVzb2x2ZWRBYnNvbHV0ZSIsInNwbGl0IiwiaXNBYnNvbHV0ZSIsInRyYWlsaW5nU2xhc2giLCJyZWxhdGl2ZSIsImZyb21QYXJ0cyIsInRvUGFydHMiLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInNlcCIsImRlbGltaXRlciIsImRpcm5hbWUiLCJoYXNSb290IiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJmIiwic3RhcnREb3QiLCJzdGFydFBhcnQiLCJwcmVEb3RTdGF0ZSIsImlzU2xvd0J1ZmZlciIsIkdpZldyaXRlciIsImdvcHRzIiwibG9vcF9jb3VudCIsImxvb3AiLCJnbG9iYWxfcGFsZXR0ZSIsInBhbGV0dGUiLCJjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzIiwibnVtX2NvbG9ycyIsImdwX251bV9jb2xvcnNfcG93MiIsImJhY2tncm91bmQiLCJncF9udW1fY29sb3JzIiwiaWwiLCJhZGRGcmFtZSIsImluZGV4ZWRfcGl4ZWxzIiwib3B0cyIsInVzaW5nX2xvY2FsX3BhbGV0dGUiLCJtaW5fY29kZV9zaXplIiwiZGVsYXkiLCJkaXNwb3NhbCIsInVzZV90cmFuc3BhcmVuY3kiLCJ0cmFuc3BhcmVudF9pbmRleCIsInRyYW5zcGFyZW50IiwiR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbSIsImdldE91dHB1dEJ1ZmZlciIsInNldE91dHB1dEJ1ZmZlciIsImdldE91dHB1dEJ1ZmZlclBvc2l0aW9uIiwic2V0T3V0cHV0QnVmZmVyUG9zaXRpb24iLCJpbmRleF9zdHJlYW0iLCJjdXJfc3ViYmxvY2siLCJjbGVhcl9jb2RlIiwiY29kZV9tYXNrIiwiZW9pX2NvZGUiLCJuZXh0X2NvZGUiLCJjdXJfY29kZV9zaXplIiwiY3VyX3NoaWZ0IiwiY3VyIiwiZW1pdF9ieXRlc190b19idWZmZXIiLCJiaXRfYmxvY2tfc2l6ZSIsImVtaXRfY29kZSIsImliX2NvZGUiLCJjb2RlX3RhYmxlIiwiY3VyX2tleSIsImN1cl9jb2RlIiwicGYwIiwiZ2xvYmFsX3BhbGV0dGVfZmxhZyIsIm51bV9nbG9iYWxfY29sb3JzX3BvdzIiLCJudW1fZ2xvYmFsX2NvbG9ycyIsImdsb2JhbF9wYWxldHRlX29mZnNldCIsImdsb2JhbF9wYWxldHRlX3NpemUiLCJub19lb2YiLCJmcmFtZXMiLCJibG9ja19zaXplIiwicGYxIiwicGYyIiwibG9jYWxfcGFsZXR0ZV9mbGFnIiwiaW50ZXJsYWNlX2ZsYWciLCJudW1fbG9jYWxfY29sb3JzX3BvdzIiLCJudW1fbG9jYWxfY29sb3JzIiwicGFsZXR0ZV9vZmZzZXQiLCJwYWxldHRlX3NpemUiLCJoYXNfbG9jYWxfcGFsZXR0ZSIsImRhdGFfb2Zmc2V0IiwiZGF0YV9sZW5ndGgiLCJpbnRlcmxhY2VkIiwibG9vcENvdW50IiwiZnJhbWVJbmZvIiwiZnJhbWVfbnVtIiwiZGVjb2RlQW5kQmxpdEZyYW1lQkdSQSIsIm51bV9waXhlbHMiLCJHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbSIsInRyYW5zIiwiZnJhbWV3aWR0aCIsImZyYW1lc3RyaWRlIiwieGxlZnQiLCJvcGJlZyIsIm9wZW5kIiwib3AiLCJzY2Fuc3RyaWRlIiwiaW50ZXJsYWNlc2tpcCIsImNvZGVfc3RyZWFtIiwib3V0cHV0X2xlbmd0aCIsInN1YmJsb2NrX3NpemUiLCJwcmV2X2NvZGUiLCJjaGFzZV9jb2RlIiwiY2hhc2VfbGVuZ3RoIiwiY2hhc2UiLCJvcF9lbmQiLCJkb19jb252ZXJ0IiwiY29udmVydCIsImNyZWF0ZVRodW5rIiwiUHJvY2VkdXJlIiwiYXJnVHlwZXMiLCJzaGltQXJncyIsImFycmF5QXJncyIsImFycmF5QmxvY2tJbmRpY2VzIiwic2NhbGFyQXJncyIsIm9mZnNldEFyZ3MiLCJvZmZzZXRBcmdJbmRleCIsImluZGV4QXJncyIsInNoYXBlQXJncyIsImZ1bmNOYW1lIiwicHJlIiwiYm9keSIsInBvc3QiLCJjb21waWxlQ3dpc2UiLCJ1c2VyX2FyZ3MiLCJwcm9jIiwicHJvY19hcmdzIiwiYXJnX3R5cGUiLCJibG9ja0luZGljZXMiLCJsdmFsdWUiLCJwcmludENvZGUiLCJibG9ja1NpemUiLCJjb21waWxlIiwidmFycyIsInRodW5rTmFtZSIsInR5cGVzaWciLCJzdHJpbmdfdHlwZXNpZyIsInNoYXBlTGVuZ3RoQ29uZGl0aW9ucyIsInNoYXBlQ29uZGl0aW9ucyIsInRodW5rIiwidW5pcSIsImlubmVyRmlsbCIsIm5hcmdzIiwiaGFzX2luZGV4IiwicGlkeCIsIm91dGVyRmlsbCIsIm1hdGNoZWQiLCJpbmRleFN0ciIsImNvdW50TWF0Y2hlcyIsIm9yZGVycyIsInByb2Nlc3NCbG9jayIsImJsb2NrIiwiZHR5cGVzIiwiY2FyZyIsInB0clN0ciIsImFyck51bSIsIm9mZkFyZ0luZGV4Iiwib2ZmQXJnIiwibG9jYWxTdHIiLCJhcnJTdHIiLCJyZVN0ckFyciIsInB0clN0ckFyciIsInR5cGVTdW1tYXJ5Iiwic3VtbWFyeSIsImFsbEVxdWFsIiwiZGlnaXRzIiwiZ2VuZXJhdGVDV2lzZU9wIiwiYmxvY2tCZWdpbiIsImJsb2NrRW5kIiwibG9vcEJlZ2luIiwibG9vcEVuZCIsImxvb3BPcmRlcnMiLCJuZXdPcmRlciIsImFyZ2xpc3QiLCJ6ZXJvcyIsIm9mZl9hcmciLCJpbml0X3N0cmluZyIsInRoaXNWYXJzIiwibG9vcE5hbWUiLCJ1bmlxdWVfcHJlZCIsInB0ciIsInVuaXF1ZV9lcSIsInVuaXF1ZSIsInNvcnRlZCIsIl9lbmRlZCIsImF1dG9EZXN0cm95IiwiZHJhaW4iLCJfZW5kIiwiX2lzU3RkaW8iLCJkaWRPbkVuZCIsImN1c3RvbSIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiY2xlYXJJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZW1vdmVDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIm1zZyIsImRlcHJlY2F0ZWQiLCJsb2NhbFN0b3JhZ2UiLCJkYXRhVXJpVG9CdWZmZXIiLCJ1cmkiLCJmaXJzdENvbW1hIiwibWV0YSIsInN1YnN0cmluZyIsImNoYXJzZXQiLCJ1bmVzY2FwZSIsImludGVycDFkIiwiZngiLCJzMCIsInMxIiwidzAiLCJ3MSIsImludGVycDJkIiwiZnkiLCJ0MCIsInQxIiwidzAwIiwidzAxIiwidzEwIiwidzExIiwiaW50ZXJwM2QiLCJmeiIsInUwIiwidTEiLCJ3MDAwIiwidzAxMCIsIncxMDAiLCJ3MTEwIiwidzAwMSIsIncwMTEiLCJ3MTAxIiwidzExMSIsImludGVycE5kIiwiaV9sb29wIiwiaW50ZXJwb2xhdGUiLCJkMSIsImQzIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJkZWx0YVgiLCJkZWx0YVkiLCJ5U3RlcCIsInRvQmluYXJ5TGluZSIsInNsb3BlIiwic2xvcGUyIiwiZXh0cmVtYSIsImN1cnJlbnREaXIiLCJyVGhyZXNob2xkIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIkJhcmNvZGVEaXJlY3Rpb24iLCJCYXJjb2RlUmVhZGVyIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsInN1cHBsZW1lbnRzIiwiX3JvdyIsImNvdW50ZXIiLCJtYXhTaW5nbGVFcnJvciIsInNpbmdsZUVycm9yIiwibW9kdWxvIiwiYmFyV2lkdGgiLCJzY2FsZWQiLCJTSU5HTEVfQ09ERV9FUlJPUiIsImNvcnJlY3Rpb24iLCJfZGVjb2RlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbmV4dFVuc2V0IiwiaXNXaGl0ZSIsImNvdW50ZXJzIiwiY291bnRlclBvcyIsIm51bUNvdW50ZXJzIiwiQ29kZTEyOFJlYWRlciIsImJhciIsInNwYWNlIiwiYmVzdE1hdGNoIiwiX2NvcnJlY3QiLCJDT0RFX1BBVFRFUk4iLCJfbWF0Y2hQYXR0ZXJuIiwiQVZHX0NPREVfRVJST1IiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwiTU9EVUxFX0lORElDRVMiLCJfY29ycmVjdEJhcnMiLCJfbmV4dFNldCIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQyIsInN0YXJ0SW5mbyIsIl9maW5kU3RhcnQiLCJkZWNvZGVkQ29kZXMiLCJjaGVja3N1bSIsImNvZGVzZXQiLCJDT0RFX0EiLCJTVEFSVF9DT0RFX0IiLCJDT0RFX0IiLCJDT0RFX0MiLCJzaGlmdE5leHQiLCJyZW1vdmVMYXN0Q2hhcmFjdGVyIiwibXVsdGlwbGllciIsInJhd1Jlc3VsdCIsIl9kZWNvZGVDb2RlIiwiU1RPUF9DT0RFIiwiQ09ERV9TSElGVCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX21hdGNoUmFuZ2UiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJDT0RFX0dfU1RBUlQiLCJTVEFSVF9QQVRURVJOIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwidHJ5SGFyZGVyIiwiZXBzaWxvbiIsImNvZGVyYW5nZSIsIl9maW5kUGF0dGVybiIsImxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQiLCJjb2RlRnJlcXVlbmN5IiwiaW5Db2RlIiwib3V0Q29kZSIsImZpcnN0RGlnaXQiLCJfY2FsY3VsYXRlRmlyc3REaWdpdCIsIm1pZGRsZVBhdHRlcm4iLCJTVE9QX1BBVFRFUk4iLCJyZXN1bHRJbmZvIiwiX2RlY29kZVBheWxvYWQiLCJfZmluZEVuZCIsIl9jaGVja3N1bSIsInN1cHBsZW1lbnQiLCJfZGVjb2RlRXh0ZW5zaW9ucyIsImxhc3RDb2RlIiwiQUxQSEFCRVRIX1NUUklORyIsIkFMUEhBQkVUIiwiVWludDE2QXJyYXkiLCJjaGFyIiwiQ0hBUkFDVEVSX0VOQ09ESU5HUyIsIkFTVEVSSVNLIiwiQ29kZTM5UmVhZGVyIiwicGF0dGVyblN0YXJ0IiwiX3RvUGF0dGVybiIsIndoaXRlU3BhY2VNdXN0U3RhcnQiLCJtYXhOYXJyb3dXaWR0aCIsIm51bVdpZGVCYXJzIiwid2lkZUJhcldpZHRoIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsImxhc3RTdGFydCIsIm5leHRTdGFydCIsInBhdHRlcm5TaXplIiwiZGVjb2RlZENoYXIiLCJfdG9Db3VudGVycyIsIl9wYXR0ZXJuVG9DaGFyIiwicGF0dGVybnMiLCJJT1EiLCJBWjA5IiwiQ29kZTM5VklOUmVhZGVyIiwiX2NoZWNrQ2hlY2tzdW0iLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsIk5ld0NvZGFiYXJSZWFkZXIiLCJfY291bnRlcnMiLCJiYXJUaHJlc2hvbGQiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJiaXRtYXNrIiwiX2lzU3RhcnRFbmQiLCJfc3VtQ291bnRlcnMiLCJzdGFydENvdW50ZXIiLCJlbmRDb3VudGVyIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJjaGFyQ29kZSIsImNhdGVnb3JpemF0aW9uIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsIl9jaGFyVG9QYXR0ZXJuIiwia2luZCIsImNhdCIsIm5ld2tpbmQiLCJ0aHJlc2hvbGRzIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJfZmlsbENvdW50ZXJzIiwiX3ZlcmlmeVdoaXRlc3BhY2UiLCJfdmFsaWRhdGVSZXN1bHQiLCJVUENSZWFkZXIiLCJFQU44UmVhZGVyIiwiRUFOMlJlYWRlciIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsIkVBTjVSZWFkZXIiLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwidXBjYSIsImxhc3REaWdpdCIsIl9jb252ZXJ0VG9VUENBIiwiTiIsIlciLCJJMm9mNVJlYWRlciIsIm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgiLCJjb3VudGVyU3VtIiwiY29kZVN1bSIsImNvcnJlY3Rpb25SYXRpbyIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvcnJlY3Rpb25SYXRpb0ludmVyc2UiLCJiYXJTcGFjZVJhdGlvIiwibmFycm93QmFyV2lkdGgiLCJjb3VudGVyUGFpciIsImNvZGVzIiwiY291bnRlckxlbmd0aCIsIl9kZWNvZGVQYWlyIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJTVEFSVF9QQVRURVJOX0xFTkdUSCIsIlR3b09mRml2ZVJlYWRlciIsIkNvZGU5M1JlYWRlciIsImNoYXJBcnJheSIsIm5leHRDaGFyIiwibmV4dENoYXJDb2RlIiwibWF4V2VpZ2h0IiwiYXJyYXlUb0NoZWNrIiwid2VpZ2h0ZWRTdW1zIiwid2VpZ2h0IiwiY2hlY2tDaGFyIiwiX21hdGNoQ2hlY2tDaGFyIiwiX3ZlcmlmeUVuZCIsIl92ZXJpZnlDaGVja3N1bXMiLCJfZGVjb2RlRXh0ZW5kZWQiLCJBRUlPIiwiY29kZTMyc2V0IiwiQ29kZTMyUmVhZGVyIiwiY29kZTMyIiwiX2RlY29kZUNvZGUzMiIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIiRkZWJ1ZyIsInJlYWRlcnMiLCJyZWFkZXJDb25maWciLCJjb25maWd1cmF0aW9uIiwicmVhZGVyT2JqIiwidmlzIiwibm9kZSIsInByb3AiLCJzaG93RnJlcXVlbmN5Iiwic2hvd1BhdHRlcm4iLCJkaXNwbGF5IiwiZ2V0RXh0ZW5kZWRMaW5lIiwiZXh0ZW5kTGluZSIsImFtb3VudCIsImV4dGVuc2lvbiIsImluSW1hZ2VXaXRoQm9yZGVyIiwiZ2V0TGluZSIsInRyeURlY29kZSIsImJhcmNvZGVMaW5lIiwiZGVjb2RlUGF0dGVybiIsImNvZGVSZXN1bHQiLCJ0cnlEZWNvZGVCcnV0ZUZvcmNlIiwibGluZUFuZ2xlIiwic2lkZUxlbmd0aCIsInNsaWNlcyIsInhkaXIiLCJ5ZGlyIiwiZ2V0TGluZUxlbmd0aCIsImRlY29kZUZyb21JbWFnZSIsImRlY29kZUltYWdlIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94IiwiZHJhd0JvdW5kaW5nQm94IiwibGluZUxlbmd0aCIsImF0YW4yIiwiZHJhd1NjYW5saW5lIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMiLCJiYXJjb2RlcyIsIm11bHRpcGxlIiwic2V0UmVhZGVycyIsIkV2ZW50SW50ZXJmYWNlIiwiZ2V0RXZlbnQiLCJldmVudE5hbWUiLCJzdWJzY3JpYmVycyIsImNsZWFyRXZlbnRzIiwicHVibGlzaFN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbiIsIl9zdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwic3Vic2NyaWJlciIsInVuc3Vic2NyaWJlIiwiRVJST1JfREVTQyIsImVudW1lcmF0ZURldmljZXMiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJjb25zdHJhaW50cyIsInN0cmVhbVJlZiIsIndhaXRGb3JWaWRlbyIsInZpZGVvIiwiYXR0ZW1wdHMiLCJjaGVja1ZpZGVvIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiaW5pdENhbWVyYSIsInNldEF0dHJpYnV0ZSIsInNyY09iamVjdCIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJRdWFnZ2FKU0NhbWVyYUFjY2VzcyIsInJlcXVlc3QiLCJuZXdDb25zdHJhaW50cyIsInJlbGVhc2UiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsInRyYWNrIiwiY29udGFpbnMiLCJzb21lIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwYWNpdHkiLCJjYXB0dXJlIiwibWF0Y2hlc0NvbnN0cmFpbnRzIiwiYmxhY2tsaXN0IiwiYWRkUmVzdWx0IiwiaW1hZ2VTaXplIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImxvY2F0b3IiLCJOb2RlQ29uZmlnIiwic2VxdWVuY2UiLCJQcm9kQ29uZmlnIiwiUXVhZ2dhQ29uZmlnIiwiUXVhZ2dhQ29udGV4dCIsIkNhbnZhc0NvbnRhaW5lciIsIkNhbnZhc0luZm8iLCJib3hTaXplIiwiQmFyY29kZUxvY2F0b3IiLCJnZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJzZWxlY3RvciIsImZpbmRPckNyZWF0ZUNhbnZhcyIsImdldENhbnZhc0FuZENvbnRleHQiLCJpbml0Q2FudmFzZXMiLCJpbWFnZSIsInZpZXdwb3J0IiwiY29udGFpbmVyIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsInRhZ3MiLCJvYmplY3RVUkxUb0Jsb2IiLCJyZWFkVG9CdWZmZXIiLCJmaW5kVGFnc0luQnVmZmVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRhdGFVcmwiLCJhdG9iIiwidmlldyIsImJsb2IiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0FycmF5QnVmZmVyIiwiaHR0cCIsIkRPTkUiLCJzdGF0dXMiLCJmaWxlIiwic2VsZWN0ZWRUYWdzIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImV4aWZUYWdzIiwic2VsZWN0ZWRUYWciLCJleGlmVGFnIiwiZ2V0VWludDgiLCJyZWFkRVhJRkRhdGEiLCJnZXRVaW50MTYiLCJnZXRTdHJpbmdGcm9tQnVmZmVyIiwidGlmZk9mZnNldCIsImJpZ0VuZCIsImZpcnN0SUZET2Zmc2V0IiwiZ2V0VWludDMyIiwicmVhZFRhZ3MiLCJ0aWZmU3RhcnQiLCJkaXJTdGFydCIsInN0cmluZ3MiLCJlbnRyeU9mZnNldCIsInJlYWRUYWdWYWx1ZSIsIm51bVZhbHVlcyIsIm91dHN0ciIsIkltYWdlTG9hZGVyIiwibG9hZCIsImRpcmVjdG9yeSIsImh0bWxJbWFnZXNTcmNBcnJheSIsImh0bWxJbWFnZXNBcnJheSIsIm5vdExvYWRlZCIsImFkZEltYWdlIiwibG9hZGVkIiwibG9hZGVkSW1nIiwibm90bG9hZGVkSW1ncyIsImltZ05hbWUiLCJhZGRPbmxvYWRIYW5kbGVyIiwiaW5wdXRTdHJlYW1GYWN0b3J5IiwiY3JlYXRlVmlkZW9TdHJlYW0iLCJfZXZlbnROYW1lcyIsIl9ldmVudEhhbmRsZXJzIiwiX2NhbGN1bGF0ZWRXaWR0aCIsIl9jYWxjdWxhdGVkSGVpZ2h0IiwiaW5pdFNpemUiLCJzZXRJbnB1dFN0cmVhbSIsInNldEN1cnJlbnRUaW1lIiwidGltZSIsImJvb2wiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJoYW5kbGVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmlnZ2VyIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiZnJhbWVJZHgiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsImltZ3MiLCJvcmllbnRhdGlvbiIsInB1Ymxpc2hFdmVudCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiaW5kIiwiR2V0UGl4ZWxzIiwibWltZSIsIkJyb3dzZXJJbnB1dFN0cmVhbSIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIl9zdHJlYW1Db25maWciLCJfc3giLCJfc3kiLCJfY3R4IiwiZG9IYWxmU2FtcGxlIiwiZHJhd2FibGUiLCJkcmF3QW5nbGUiLCJ0cmFuc2xhdGUiLCJ3b3JrZXJQb29sIiwidXBkYXRlV29ya2VycyIsImZyYW1lR3JhYmJlciIsImF2YWlsYWJsZVdvcmtlciIsIndvcmtlclRocmVhZCIsImJ1c3kiLCJ3b3JrZXIiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwib25Qcm9jZXNzZWQiLCJ3b3JrZXJJbnRlcmZhY2VSZWFkeSIsImdlbmVyYXRlV29ya2VyQmxvYiIsImZhY3RvcnlTb3VyY2UiLCJfX2ZhY3RvcnlTb3VyY2VfXyIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJpbml0V29ya2VyIiwiYmxvYlVSTCIsIldvcmtlciIsInJldm9rZU9iamVjdFVSTCIsImFkanVzdFdvcmtlclBvb2wiLCJpbmNyZWFzZUJ5Iiwid29ya2Vyc1RvVGVybWluYXRlIiwidGVybWluYXRlIiwid29ya2VySW5pdGlhbGl6ZWQiLCJzZXR1cElucHV0U3RyZWFtIiwiSW5wdXRTdHJlYW0iLCJtb3ZlQm94IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXIiLCJtb3ZlTGluZSIsIk5vZGVJbnB1dFN0cmVhbSIsIk5vZGVGcmFtZUdyYWJiZXIiLCJCcm93c2VyRnJhbWVHcmFiYmVyIiwiZnJhbWVncmFiYmVyIiwiY2FudmFzQ29udGFpbmVyIiwiUVdvcmtlcnMiLCJpbml0aWFsaXplRGF0YSIsInJlYWR5Iiwib25VSVRocmVhZCIsIndvcmtlcnNVcGRhdGVkIiwibG9jYXRlQW5kRGVjb2RlIiwiX2luaXRCdWZmZXJzIiwiQmFyY29kZURlY29kZXIiLCJfZ2V0Vmlld1BvcnQiLCJfaW5pdENhbnZhcyIsImlucHV0VHlwZSIsIkNhbWVyYUFjY2VzcyIsImNhblJlY29yZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsInN0b3BwZWQiLCJ0aW1lc3RhbXAiLCJ1cGRhdGUiLCJwZXJmb3JtYW5jZSIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsIl9jb250ZXh0IiwiUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UiLCJxdWFnZ2FJbnN0YW5jZSIsInByb21pc2UiLCJDb25maWciLCJpbml0SW5wdXRTdHJlYW0iLCJvbkRldGVjdGVkIiwib2ZmRGV0ZWN0ZWQiLCJvZmZQcm9jZXNzZWQiLCJyZWdpc3RlclJlc3VsdENvbGxlY3RvciIsImRlY29kZVNpbmdsZSIsInJlc3VsdENhbGxiYWNrIiwiZGVmYXVsdCIsIlJlc3VsdENvbGxlY3RvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDSDs7QUFDRCtwQixtQkFBTyxDQUFDL3BCLE1BQUQsQ0FBUDtBQUNILFdBTkQsRUFNRyxJQU5IO0FBT0F5dkUsd0JBQWMsQ0FBQzEzRCxLQUFmO0FBQ0gsU0FURCxFQVNHLElBVEgsRUFTUzAzRCxjQVRUO0FBVUgsT0FYRCxDQVdFLE9BQU8xOUQsR0FBUCxFQUFZO0FBQ1ZpWSxjQUFNLENBQUNqWSxHQUFELENBQU47QUFDSDtBQUNKLEtBZk0sQ0FBUDtBQWdCSCxHQXhIMkI7O0FBeUg1QjtBQUNBO0FBQ0EsTUFBSW8rRCxPQUFKLEdBQWM7QUFDVixXQUFPWCx1QkFBUDtBQUNILEdBN0gyQjs7QUE4SDVCdmYsZUFBYSxFQUFiQSxjQTlINEI7QUErSDVCcWUsY0FBWSxFQUFaQSxhQS9INEI7QUFnSTVCdnJELFlBQVUsRUFBVkEsOEJBaEk0QjtBQWlJNUJsWSxjQUFZLEVBQVpBLGdDQWpJNEI7QUFrSTVCdWxFLGlCQUFlLEVBQWZBLGdCQUFlQTtBQWxJYSxDQUFoQztBQXFJZVosbUdBQWYsRSxDQUNBIiwiZmlsZSI6InF1YWdnYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlF1YWdnYVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTA1KTtcbiIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQyOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDInKVxuICAsIHRyYW5zZm9ybU1hdDJkOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDJkJylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbiAgLCBsaW1pdDogcmVxdWlyZSgnLi9saW1pdCcpXG59XG4iLCIvLyBUT0RPOiBjbHVzdGVyLmpzIGFuZCBjdl91dGlscy5qcyBhcmUgcHJldHR5IHRpZ2h0bHkgaW50ZXJ0d2luZWQsIG1ha2luZyBmb3IgYSBjb21wbGV4IGNvbnZlcnNpb25cbi8vIGludG8gdHlwZXNjcmlwdC4gYmUgd2FybmVkLiA6LSlcblxuaW1wb3J0IHsgY2xvbmUsIGRvdCB9IGZyb20gJ2dsLXZlYzInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSwgZG90IH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB7XG4gICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcG9pbnRNYXAgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBhZGQocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0gPSBwb2ludFRvQWRkO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXIoKSB7XG4gICAgICAgICAgICBsZXQgaTsgbGV0XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcG9pbnRzW2ldLnJhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRlci5yYWQgPSBzdW0gLyBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY2VudGVyLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKGNlbnRlci5yYWQpLCBNYXRoLnNpbihjZW50ZXIucmFkKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGFkZChwb2ludCk7XG4gICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50TWFwW3BvaW50VG9BZGQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdHMob3RoZXJQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvc2luZSBzaW1pbGFyaXR5IHRvIGNlbnRlci1hbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChvdGhlclBvaW50LnBvaW50LnZlYywgY2VudGVyLnZlYykpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2VudGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlUG9pbnQobmV3UG9pbnQsIGlkLCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFkOiBuZXdQb2ludFtwcm9wZXJ0eV0sXG4gICAgICAgICAgICBwb2ludDogbmV3UG9pbnQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuaW1wb3J0IHsgY2xvbmUgYXMgdjJjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHsgY2xvbmUgYXMgdjNjbG9uZSB9IGZyb20gJ2dsLXZlYzMnO1xuaW1wb3J0IENsdXN0ZXIyIGZyb20gJy4vY2x1c3Rlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZTogdjJjbG9uZSB9O1xuY29uc3QgdmVjMyA9IHsgY2xvbmU6IHYzY2xvbmUgfTtcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgY29uc3QgdGhhdCA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9WZWMyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMygpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgcG9zQSA9IDA7IGxldCBwb3NCID0gMDsgbGV0IHBvc0MgPSAwOyBsZXQgcG9zRCA9IDA7IGxldCB4OyBsZXRcbiAgICAgICAgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cbiAgICAgICAgICAgICAgICArPSBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7IGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhOyBjb25zdFxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGxpbmU7XG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xuICAgIGxldCByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XG4gICAgbGV0IGhpc3Q7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICBjb25zdCB2ZXQgPSBbMF07XG4gICAgICAgIGxldCBwMTtcbiAgICAgICAgbGV0IHAyO1xuICAgICAgICBsZXQgcDEyO1xuICAgICAgICBsZXQgbTE7XG4gICAgICAgIGxldCBtMjtcbiAgICAgICAgbGV0IG0xMjtcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XG4gICAgICAgIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0aGlzQ2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICBsZXQgdG9wID0gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGxldCB0b0lkeDtcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxuICAgICAgICBwb3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICBjb25zdCBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIGxldCBvdXRJbWdJZHggPSAwO1xuICAgIGNvbnN0IGluV2lkdGggPSBzaXplLng7XG4gICAgbGV0IGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xuICAgIGNvbnN0IHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSkge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICBjb25zdCBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcbiAgICBjb25zdCBoID0gaHN2WzBdO1xuICAgIGNvbnN0IHMgPSBoc3ZbMV07XG4gICAgY29uc3QgdiA9IGhzdlsyXTtcbiAgICBjb25zdCBjID0gdiAqIHM7XG4gICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIGNvbnN0IGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KTtcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gICAgY29uc3QgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpO1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgJ3gtc21hbGwnOiA1LFxuICAgICAgICBzbWFsbDogNCxcbiAgICAgICAgbWVkaXVtOiAzLFxuICAgICAgICBsYXJnZTogMixcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxuICAgIH07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XG4gICAgbGV0IG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZvdW5kLCB5OiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XG4gICAgfSxcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XG5cbiAgICBjb25zdCBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IFhZUG9zaXRpb24gc2hvdWxkIGJlIGFuIFhZT2JqZWN0LCBidXQgdGhhdCBicmVha3MgWFlEZWZpbml0aW9uLCB3aGljaCBicmVha3MgZHJhd1BhdGgoKSBiZWxvdy5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENhbnZhc1N0eWxlIHtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xufVxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xuICAgIHk6IGtleW9mIFhZUG9zaXRpb247XG59XG5cbmRlY2xhcmUgdHlwZSBQYXRoID0gQXJyYXk8WFlQb3NpdGlvbj47XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdChwb3M6IFhZUG9zaXRpb24sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjYW52YXNEYXRhO1xuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFR5cGVkQXJyYXkgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGFycjogVHlwZWRBcnJheSB8IEFycmF5PGFueT4sIHZhbDogYW55KSB7XG4gICAgICAgIC8vIGFyci5maWxsKHZhbCk7XG4gICAgICAgIGxldCBsID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgYXJyW2xdID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gICAgICovXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBpID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoaTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcnJbaV07XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgICAgICBhcnJbal0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0OiBmdW5jdGlvbihhcnI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBgWyR7bi5qb2luKCcsJyl9XWA7XG4gICAgICAgICAgICBwLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LCBbXSBhcyBBcnJheTxzdHJpbmc+KTtcbiAgICAgICAgcmV0dXJuIGBbJHtyb3dzLmpvaW4oJyxcXHJcXG4nKX1dYDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICovXG4gICAgdGhyZXNob2xkOiBmdW5jdGlvbihhcnI6IEFycmF5PG51bWJlcj4sIHRocmVzaG9sZDogbnVtYmVyLCBzY29yZUZ1bmM6ICgoc2NvcmU6IG51bWJlcikgPT4gbnVtYmVyKSkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IGFyci5yZWR1Y2UoKHByZXY6IEFycmF5PG51bWJlcj4sIG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHByZXYucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9LFxuXG4gICAgbWF4SW5kZXg6IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55Pikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIHN1bTogZnVuY3Rpb24oYXJyOiBBcnJheTxhbnk+IHwgVHlwZWRBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGxldCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQge1xuICAgIFhZU2l6ZSxcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgVHlwZWRBcnJheSxcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxuICAgIE1vbWVudCxcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSB9O1xuXG50eXBlIFBvc2l0aXZlTnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIHJlY2VpdmVkICR7dmFsfWApO1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcblxuICAgIHNpemU6IFhZU2l6ZTtcblxuICAgIGluZGV4TWFwcGluZz86IFdyYXBwZXJJbmRleE1hcHBpbmc7XG5cbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxuICAgIC8vIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbi5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2l6ZTogWFlTaXplLFxuICAgICAgICBkYXRhPzogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlLCBleHRlbmRlZCBvdXQgYnkgYSBib3JkZXIgb24gZWFjaCBzaWRlXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICAgIC8vIFRPRE86IGNvZGVfMTI4IHN0YXJ0cyBmYWlsaW5nIG1pc2VyYWJseSB3aGVuIGkgb25seSBhbGxvdyBpbWdSZWYgdG8gY29udGFpbiBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIG1lLCB3aHkgZG9lcyBpdCBnbyBuZWdhdGl2ZT8gIFRlc3RzIGFyZSBub3QgYWZmZWN0ZWQgYnlcbiAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlLCBidXQgdGhlIHdob2xlIGNvZGVfMTI4IHJlYWRlciBibG93cyB1cCB3aGVuIGkgdGhyb3cgb24gbmVnYXRpdmUgaW1nUmVmLlxuICAgICAgICAvLyBhc3NlcnROdW1iZXJQb3NpdGl2ZShpbWdSZWYueCk7XG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi55KTtcbiAgICAgICAgcmV0dXJuIChpbWdSZWYueCA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggKyAoYm9yZGVyICogMikpKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55IDwgKHRoaXMuc2l6ZS55ICsgKGJvcmRlciAqIDIpKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBmcm9tIFRISVMgSW1hZ2VXcmFwcGVyIHRvIHRoZSBuZXcgaW1hZ2VXcmFwcGVyIHBhcmFtZXRlciwgc3RhcnRpbmcgYXQgZnJvbSwgc3RvcHBpbmcgYXRcbiAgICAvLyBlbmQgb2YgbmV3IGltYWdlV3JhcHBlciBzaXplLlxuICAgIHN1YkltYWdlQXNDb3B5KGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyLCBmcm9tOiBYWVNpemUpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLngpO1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLnkpO1xuICAgICAgICBjb25zdCB7IHg6IHNpemVYLCB5OiBzaXplWSB9ID0gaW1hZ2VXcmFwcGVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZVg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGFbeSAqIHNpemVYICsgeF0gPSB0aGlzLmRhdGFbKGZyb20ueSArIHkpICogdGhpcy5zaXplLnggKyBmcm9tLnggKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VXcmFwcGVyO1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIHJlYWxseSBwcm9iYWJseSBzaG91bGQgY2FsbCBpbnRvIEltYWdlV3JhcHBlciBzb21ld2hlcmUgdG8gbWFrZVxuICAgICAgICAvLyBzdXJlIHRoYXQgYWxsIG9mIGl0J3MgcGFyYW1ldGVycyBhcmUgc2V0IHByb3Blcmx5LCBzb21ldGhpbmcgbGlrZVxuICAgICAgICAvLyBJbWFnZVdyYXBwZXIuVXBkYXRlRnJvbSgpXG4gICAgICAgIC8vIHRoYXQgbWlnaHQgdGFrZSBhIHByb3ZpZGVkIGRhdGEgYW5kIHNpemUsIGFuZCBtYWtlIHN1cmUgdGhlcmUncyBubyBpbnZhbGlkIGluZGV4TWFwcGluZ1xuICAgICAgICAvLyBoYW5naW5nIGFyb3VuZCwgYW5kIHN1Y2guXG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZVxuICAgIGdldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF07XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZSAoc2FmZSwgd2hhdGV2ZXIgdGhhdFxuICAgIC8vIG1lYW5zKVxuICAgIGdldFNhZmUoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBjYWNoZSBpbmRleE1hcHBpbmcgYmVjYXVzZSBpZiB3ZSdyZSB1c2luZyBpdCBvbmNlLCB3ZSdsbCBwcm9iYWJseSBuZWVkIGl0IGEgYnVuY2ggbW9yZVxuICAgICAgICAvLyB0b29cbiAgICAgICAgaWYgKCF0aGlzLmluZGV4TWFwcGluZykge1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpICsgdGhpcy5zaXplLnhdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLnk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBncmF5c2NhbGUgdmFsdWVcbiAgICBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF0gPSB2YWx1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSBib3JkZXIgb2YgdGhlIGltYWdlICgxIHBpeGVsKSB0byB6ZXJvXG4gICAgemVyb0JvcmRlcigpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBjb25zdCB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB0aGlzLmRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogd2lkdGhdID0gdGhpcy5kYXRhW2kgKiB3aWR0aCArICh3aWR0aCAtIDEpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIGVudGlyZWx5IHRvbyBsYXJnZSBmb3IgbWUgdG8gcmVhc29uIG91dCByaWdodCBhdCB0aGlzIG1vbWVudCB0aGF0IGknbSBoYW5kbGluZ1xuICAgIC8vIGFsbCB0aGUgcmVzdCBvZiBpdCwgc28gdGhpcyBpcyBhIHZlcmJhdGltIGNvcHkgb2YgdGhlIGphdmFzY3JpcHQgc291cmNlLCB3aXRoIG9ubHkgdHdlYWtzXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGdldCBpdCB0byBydW4sIG5vIHRob3VnaHQgcHV0IGludG8gaXQgeWV0LlxuICAgIG1vbWVudHMobGFiZWxDb3VudDogbnVtYmVyKTogQXJyYXk8TW9tZW50PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgbGV0IHlzcTtcbiAgICAgICAgY29uc3QgbGFiZWxTdW06IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsYWJlbDtcbiAgICAgICAgbGV0IG11MTE7XG4gICAgICAgIGxldCBtdTAyO1xuICAgICAgICBsZXQgbXUyMDtcbiAgICAgICAgbGV0IHhfO1xuICAgICAgICBsZXQgeV87XG4gICAgICAgIGxldCB0bXA7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBjb25zdCB7IFBJIH0gPSBNYXRoO1xuICAgICAgICBjb25zdCBQSV80ID0gUEkgLyA0O1xuXG4gICAgICAgIGlmIChsYWJlbENvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbFN1bVtpXSA9IHtcbiAgICAgICAgICAgICAgICBtMDA6IDAsXG4gICAgICAgICAgICAgICAgbTAxOiAwLFxuICAgICAgICAgICAgICAgIG0xMDogMCxcbiAgICAgICAgICAgICAgICBtMTE6IDAsXG4gICAgICAgICAgICAgICAgbTAyOiAwLFxuICAgICAgICAgICAgICAgIG0yMDogMCxcbiAgICAgICAgICAgICAgICB0aGV0YTogMCxcbiAgICAgICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB5c3EgPSB5ICogeTtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW3ZhbCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMCArPSB4O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0yMCArPSB4ICogeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHhfID0gbGFiZWwubTEwIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MDIgPSBsYWJlbC5tMDIgLyBsYWJlbC5tMDAgLSB5XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xuICAgICAgICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xuICAgICAgICAgICAgICAgIHRtcCA9IDAuNSAqIE1hdGguYXRhbih0bXApICsgKG11MTEgPj0gMCA/IFBJXzQgOiAtUElfNCkgKyBQSTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwudGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWwucmFkID0gdG1wID4gUEkgPyB0bXAgLSBQSSA6IHRtcDtcbiAgICAgICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgVWludDhDbGFtcGVkQXJyYXkgY29udGFpbmluZyB0aGlzIGdyYXlzY2FsZSBpbWFnZSBjb252ZXJ0ZWQgdG8gUkdCQSBmb3JtXG4gICAgZ2V0QXNSR0JBKHNjYWxlID0gMS4wKTogVWludDhDbGFtcGVkQXJyYXkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMF0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDJdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IHRoaXMgSW1hZ2VXcmFwcGVyIGluIGEgZ2l2ZW4gQ2FudmFzIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBzY2FsZVxuICAgIHNob3coY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGUgPSAxLjApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0QXNSR0JBKHNjYWxlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCBuZXdGcmFtZSA9IG5ldyBJbWFnZURhdGEoZGF0YSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgU3ViSW1hZ2UgYW5kIHVzaW5nIGl0J3Mgc2hvdygpIG1ldGhvZC4gV2h5PyBJIGRvbid0IGhhdmUgdGhlIGFuc3dlciB0byB0aGF0XG4gICAgLy8geWV0LiAgSSBzdXNwZWN0IHRoZSBIU1YvUkdCIG9wZXJhdGlvbnMgaW52b2x2ZWQgaGVyZSBhcmUgbWFraW5nIGl0IHNpZ25pZmljYW50bHkgZGlmZmVyZW50LFxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcbiAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICBvdmVybGF5KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGluU2NhbGU6IG51bWJlciwgZnJvbTogWFlTaXplKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xuICAgICAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIGNvbnN0IGJsYWNrUmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGZyYW1lO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IHRoaXMuZGF0YTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxlbmd0aCAqIDQ7XG4gICAgICAgICAgICBbZGF0YVtwb3NdLCBkYXRhW3BvcyArIDFdLCBkYXRhW3BvcyArIDJdXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGRhdGFbcG9zICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlXCIpO1xuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldDsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIi8qKlxuICogaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vVGlwcy80MDcxNzIvQ29ubmVjdGVkLUNvbXBvbmVudC1MYWJlbGluZy1hbmQtVmVjdG9yaXphdGlvblxuICovXG5jb25zdCBUcmFjZXIgPSB7XG4gICAgc2VhcmNoRGlyZWN0aW9uczogW1swLCAxXSwgWzEsIDFdLCBbMSwgMF0sIFsxLCAtMV0sIFswLCAtMV0sIFstMSwgLTFdLCBbLTEsIDBdLCBbLTEsIDFdXSxcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCB7IHNlYXJjaERpcmVjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICAgICAgbGV0IHBvcztcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGxldCB4O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQuY3kgKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC5jeCArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzFdO1xuICAgICAgICAgICAgICAgIHBvcyA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgICAgICAgaWYgKChpbWFnZURhdGFbcG9zXSA9PT0gY29sb3IpICYmICgobGFiZWxEYXRhW3Bvc10gPT09IDApIHx8IChsYWJlbERhdGFbcG9zXSA9PT0gbGFiZWwpKSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBlZGdlbGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgMSkgJSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmVydGV4MkQoeCwgeSwgZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBGdiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgQ3Y7XG4gICAgICAgICAgICBsZXQgUDtcbiAgICAgICAgICAgIGxldCBsZGlyO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBjeDogc3gsXG4gICAgICAgICAgICAgICAgY3k6IHN5LFxuICAgICAgICAgICAgICAgIGRpcjogMCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICBGdiA9IHZlcnRleDJEKHN4LCBzeSwgY3VycmVudC5kaXIpO1xuICAgICAgICAgICAgICAgIEN2ID0gRnY7XG4gICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICBQLnByZXYgPSBDdjtcbiAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIEN2ID0gUDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgNikgJSA4O1xuICAgICAgICAgICAgICAgICAgICB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZGlyICE9PSBjdXJyZW50LmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLnByZXYgPSBDdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGxkaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi54ID0gY3VycmVudC5jeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnkgPSBjdXJyZW50LmN5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50LmN4ICE9PSBzeCB8fCBjdXJyZW50LmN5ICE9PSBzeSk7XG4gICAgICAgICAgICAgICAgRnYucHJldiA9IEN2LnByZXY7XG4gICAgICAgICAgICAgICAgQ3YucHJldi5uZXh0ID0gRnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRnY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCAoVHJhY2VyKTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC12ZWMyJztcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSAnZ2wtbWF0Mic7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxuICAgIG90c3VUaHJlc2hvbGQsXG4gICAgaHN2MnJnYixcbiAgICBjbHVzdGVyLFxuICAgIHRvcEdlbmVyaWMsXG4gICAgaW1hZ2VSZWYsXG4gICAgaGFsZlNhbXBsZSxcbiAgICBjb21wdXRlSW1hZ2VBcmVhLFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XG5pbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcbmltcG9ydCBza2VsZXRvbml6ZXIgZnJvbSAnLi9za2VsZXRvbml6ZXInO1xuXG5cbmxldCBfY29uZmlnO1xubGV0IF9jdXJyZW50SW1hZ2VXcmFwcGVyO1xubGV0IF9za2VsSW1hZ2VXcmFwcGVyO1xubGV0IF9zdWJJbWFnZVdyYXBwZXI7XG5sZXQgX2xhYmVsSW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaEdyaWQ7XG5sZXQgX3BhdGNoTGFiZWxHcmlkO1xubGV0IF9pbWFnZVRvUGF0Y2hHcmlkO1xubGV0IF9iaW5hcnlJbWFnZVdyYXBwZXI7XG5sZXQgX3BhdGNoU2l6ZTtcbmNvbnN0IF9jYW52YXNDb250YWluZXIgPSB7XG4gICAgY3R4OiB7XG4gICAgICAgIGJpbmFyeTogbnVsbCxcbiAgICB9LFxuICAgIGRvbToge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbn07XG5jb25zdCBfbnVtUGF0Y2hlcyA9IHsgeDogMCwgeTogMCB9O1xubGV0IF9pbnB1dEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbGV0b25pemVyO1xuXG5mdW5jdGlvbiBpbml0QnVmZmVycygpIHtcbiAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHk6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnkgLyAyIHwgMCxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBfaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgfVxuXG4gICAgX3BhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShfY29uZmlnLnBhdGNoU2l6ZSwgX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XG5cbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcblxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBza2VsZXRvbkltYWdlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig2NCAqIDEwMjQpO1xuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcbiAgICBfc2tlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3NrZWxldG9uaXplciA9IHNrZWxldG9uaXplcihcbiAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpID8gc2VsZiA6IGdsb2JhbCxcbiAgICAgICAgeyBzaXplOiBfcGF0Y2hTaXplLnggfSxcbiAgICAgICAgc2tlbGV0b25JbWFnZURhdGEsXG4gICAgKTtcblxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMCxcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcbiAgICBfcGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIEludDMyQXJyYXksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmNsYXNzTmFtZSA9ICdiaW5hcnlCdWZmZXInO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1ZycpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS53aWR0aCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5oZWlnaHQgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IHdoaWNoIGVuY2xvc2VzIGFsbCB0aGUgZ2l2ZW4gcGF0Y2hlc1xuICogQHJldHVybnMge0FycmF5fSBUaGUgbWluaW1hbCBib3VuZGluZyBib3hcbiAqL1xuZnVuY3Rpb24gYm94RnJvbVBhdGNoZXMocGF0Y2hlcykge1xuICAgIGxldCBvdmVyQXZnO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBsZXQgdHJhbnNNYXQ7XG4gICAgbGV0IG1pbnggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWlueSA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBtYXh4ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBtYXh5ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBib3g7XG4gICAgbGV0IHNjYWxlO1xuXG4gICAgLy8gZHJhdyBhbGwgcGF0Y2hlcyB3aGljaCBhcmUgdG8gYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uXG4gICAgb3ZlckF2ZyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBvdmVyQXZnICs9IHBhdGNoLnJhZDtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICdyZWQnIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3ZlckF2ZyAvPSBwYXRjaGVzLmxlbmd0aDtcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgaWYgKG92ZXJBdmcgPCAwKSB7XG4gICAgICAgIG92ZXJBdmcgKz0gMTgwO1xuICAgIH1cblxuICAgIG92ZXJBdmcgPSAoMTgwIC0gb3ZlckF2ZykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXRjaGVzIGFuZCByb3RhdGUgYnkgYW5nbGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZCkge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChwYXRjaC5ib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBib3VuZGluZyBib3hcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XG4gICAgICAgICAgICAgICAgbWlueCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XG4gICAgICAgICAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XG4gICAgICAgICAgICAgICAgbWlueSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XG4gICAgICAgICAgICAgICAgbWF4eSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZEJveCkge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBfY29uZmlnLmhhbGZTYW1wbGUgPyAyIDogMTtcbiAgICAvLyByZXZlcnNlIHJvdGF0aW9uO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5pbnZlcnQodHJhbnNNYXQsIHRyYW5zTWF0KTtcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIudHJhbnNmb3JtTWF0Mihib3hbal0sIGJveFtqXSwgdHJhbnNNYXQpO1xuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93QkIpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJpbmFyeSBpbWFnZSBvZiB0aGUgY3VycmVudCBpbWFnZVxuICovXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xuICAgIG90c3VUaHJlc2hvbGQoX2N1cnJlbnRJbWFnZVdyYXBwZXIsIF9iaW5hcnlJbWFnZVdyYXBwZXIpO1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2hvdyhfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDI1NSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXG4gKiBleHRyYWN0IHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IG1vbWVudHM7XG4gICAgbGV0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGxldCByYXN0ZXJpemVyO1xuICAgIGxldCByYXN0ZXJSZXN1bHQ7XG4gICAgbGV0IHBhdGNoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9udW1QYXRjaGVzLnk7IGorKykge1xuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcbiAgICAgICAgICAgIHkgPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSAqIGo7XG5cbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXG4gICAgICAgICAgICBza2VsZXRvbml6ZSh4LCB5KTtcblxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xuICAgICAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChfbGFiZWxJbWFnZVdyYXBwZXIuZGF0YSwgMCk7XG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICByYXN0ZXJSZXN1bHQgPSByYXN0ZXJpemVyLnJhc3Rlcml6ZSgwKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBfbGFiZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIE1hdGguZmxvb3IoMzYwIC8gcmFzdGVyUmVzdWx0LmNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgbW9tZW50cyBmcm9tIHRoZSBza2VsZXRvbml6ZWQgcGF0Y2hcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGVsaWdpYmxlIHBhdGNoZXNcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2ldO1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aG9zZSBjb25uZWN0ZWQgYXJlYXMgd2hpY2ggY29udGFpbiBhdCBsZWFzdCA2IHBhdGNoZXNcbiAqIGFuZCByZXR1cm5zIHRoZW0gb3JkZXJlZCBERVNDIGJ5IHRoZSBudW1iZXIgb2YgY29udGFpbmVkIHBhdGNoZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYWJlbFxuICovXG5mdW5jdGlvbiBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgbGFiZWxIaXN0ID0gW107XG4gICAgbGV0IHRvcExhYmVscyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1heExhYmVsOyBpKyspIHtcbiAgICAgICAgbGFiZWxIaXN0LnB1c2goMCk7XG4gICAgfVxuICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPiAwKSB7XG4gICAgICAgICAgICBsYWJlbEhpc3RbX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSAtIDFdKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYWJlbEhpc3QgPSBsYWJlbEhpc3QubWFwKCh2YWwsIGlkeCkgPT4gKHtcbiAgICAgICAgdmFsLFxuICAgICAgICBsYWJlbDogaWR4ICsgMSxcbiAgICB9KSk7XG5cbiAgICBsYWJlbEhpc3Quc29ydCgoYSwgYikgPT4gYi52YWwgLSBhLnZhbCk7XG5cbiAgICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDYgcGF0Y2hlcyBwcmVzZW50XG4gICAgdG9wTGFiZWxzID0gbGFiZWxIaXN0LmZpbHRlcigoZWwpID0+IGVsLnZhbCA+PSA1KTtcblxuICAgIHJldHVybiB0b3BMYWJlbHM7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgc3VtO1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IGJveDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcGF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID09PSB0b3BMYWJlbHNbaV0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbc3VtXTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dSZW1haW5pbmdQYXRjaExhYmVscykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaHN2WzBdID0gKHRvcExhYmVsc1tpXS5sYWJlbCAvIChtYXhMYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY29sb3I6IGByZ2IoJHtyZ2Iuam9pbignLCcpfSlgLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcztcbn1cblxuLyoqXG4gKiBGaW5kIHNpbWlsYXIgbW9tZW50cyAodmlhIGNsdXN0ZXIpXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xuICovXG5mdW5jdGlvbiBzaW1pbGFyTW9tZW50cyhtb21lbnRzKSB7XG4gICAgY29uc3QgY2x1c3RlcnMgPSBjbHVzdGVyKG1vbWVudHMsIDAuOTApO1xuICAgIGNvbnN0IHRvcENsdXN0ZXIgPSB0b3BHZW5lcmljKGNsdXN0ZXJzLCAxLCAoZSkgPT4gZS5nZXRQb2ludHMoKS5sZW5ndGgpO1xuICAgIGxldCBwb2ludHMgPSBbXTsgY29uc3RcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvaW50cyA9IHRvcENsdXN0ZXJbMF0uaXRlbS5nZXRQb2ludHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc3ViSW1hZ2VBc0NvcHkoX3N1YkltYWdlV3JhcHBlciwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcblxuICAgIC8vIFNob3cgc2tlbGV0b24gaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICAgIGxldCBrO1xuICAgIGxldCBhdmc7XG4gICAgY29uc3QgZWxpZ2libGVNb21lbnRzID0gW107XG4gICAgbGV0IG1hdGNoaW5nTW9tZW50cztcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gW107XG4gICAgY29uc3QgbWluQ29tcG9uZW50V2VpZ2h0ID0gTWF0aC5jZWlsKF9wYXRjaFNpemUueCAvIDMpO1xuXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gb25seSBjb2xsZWN0IG1vbWVudHMgd2hpY2gncyBhcmVhIGNvdmVycyBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHQgcGl4ZWxzLlxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNba10ubTAwID4gbWluQ29tcG9uZW50V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZWxpZ2libGVNb21lbnRzLnB1c2gobW9tZW50c1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXG4gICAgICAgIGlmIChlbGlnaWJsZU1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTW9tZW50cyA9IHNpbWlsYXJNb21lbnRzKGVsaWdpYmxlTW9tZW50cyk7XG4gICAgICAgICAgICBhdmcgPSAwO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzaW1pbGFyaXR5IG9mIHRoZSBtb21lbnRzXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXS5yYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcGF0Y2ggdG8gdGhlIHNldFxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IG1vbWVudHMubGVuZ3RoIC8gNCkge1xuICAgICAgICAgICAgICAgIGF2ZyAvPSBtYXRjaGluZ01vbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJveDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbTWF0aC5jb3MoYXZnKSwgTWF0aC5zaW4oYXZnKV0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoZXNGb3VuZFxuICovXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcbiAgICBsZXQgbGFiZWwgPSAwO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IDAuOTU7XG4gICAgbGV0IGN1cnJJZHggPSAwO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCBjdXJyZW50UGF0Y2g7XG4gICAgICAgIGxldCBpZHg7XG4gICAgICAgIGxldCBkaXI7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICB4OiBjdXJyZW50SWR4ICUgX3BhdGNoTGFiZWxHcmlkLnNpemUueCxcbiAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2ltaWxhcml0eTtcblxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcbiAgICAgICAgICAgIGZvciAoZGlyID0gMDsgZGlyIDwgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBkaXIrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LnkgKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LnggKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzFdO1xuICAgICAgICAgICAgICAgIGlkeCA9IHkgKiBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54ICsgeDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHBhdGNoIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2pdO1xuICAgICAgICBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IHBhdGNoO1xuICAgICAgICBfcGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gMTtcbiAgICB9XG5cbiAgICAvLyByYXN0ZXJpemUgdGhlIHBhdGNoZXMgZm91bmQgdG8gZGV0ZXJtaW5lIGFyZWFcbiAgICBfcGF0Y2hHcmlkLnplcm9Cb3JkZXIoKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgIHdoaWxlICgoY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICBsYWJlbCsrO1xuICAgICAgICB0cmFjZShjdXJySWR4KTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoTGFiZWxzKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChpbnB1dEltYWdlV3JhcHBlciwgY29uZmlnKSB7XG4gICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgIF9pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuXG4gICAgICAgIGluaXRCdWZmZXJzKCk7XG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgbG9jYXRlKCkge1xuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xuICAgICAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XG4gICAgICAgIGNvbnN0IG1heExhYmVsID0gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKTtcbiAgICAgICAgaWYgKG1heExhYmVsIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggZm9yIGFyZWEgd2l0aCB0aGUgbW9zdCBwYXRjaGVzIChiaWdnZXN0IGNvbm5lY3RlZCBhcmVhKVxuICAgICAgICBjb25zdCB0b3BMYWJlbHMgPSBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKTtcbiAgICAgICAgaWYgKHRvcExhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYm94ZXMgPSBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCk7XG4gICAgICAgIHJldHVybiBib3hlcztcbiAgICB9LFxuXG4gICAgY2hlY2tJbWFnZUNvbnN0cmFpbnRzKGlucHV0U3RyZWFtLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHBhdGNoU2l6ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKTtcbiAgICAgICAgbGV0IGhlaWdodCA9IGlucHV0U3RyZWFtLmdldEhlaWdodCgpO1xuICAgICAgICBjb25zdCB0aGlzSGFsZlNhbXBsZSA9IGNvbmZpZy5oYWxmU2FtcGxlID8gMC41IDogMTtcbiAgICAgICAgbGV0IGFyZWE7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7IHg6IGFyZWEuc3gsIHk6IGFyZWEuc3kgfSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRDYW52YXNTaXplKHsgeDogd2lkdGgsIHk6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIHdpZHRoID0gYXJlYS5zdztcbiAgICAgICAgICAgIGhlaWdodCA9IGFyZWEuc2g7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgeDogTWF0aC5mbG9vcih3aWR0aCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoaGVpZ2h0ICogdGhpc0hhbGZTYW1wbGUpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHBhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShjb25maWcucGF0Y2hTaXplLCBzaXplKTtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueSkpO1xuXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XG4gICAgICAgICAgICB3aWR0aH0gKWFuZCBoZWlnaHQgKCR7aGVpZ2h0XG4gICAgICAgIH0pIG11c3QgYSBtdWx0aXBsZSBvZiAke3BhdGNoU2l6ZS54fWApO1xuICAgIH0sXG59O1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRldGVybWluYW50OiByZXF1aXJlKCcuL2RldGVybWluYW50JylcbiAgLCB0cmFuc3Bvc2U6IHJlcXVpcmUoJy4vdHJhbnNwb3NlJylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgaWRlbnRpdHk6IHJlcXVpcmUoJy4vaWRlbnRpdHknKVxuICAsIGFkam9pbnQ6IHJlcXVpcmUoJy4vYWRqb2ludCcpXG4gICwgcm90YXRlOiByZXF1aXJlKCcuL3JvdGF0ZScpXG4gICwgaW52ZXJ0OiByZXF1aXJlKCcuL2ludmVydCcpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgZnJvYjogcmVxdWlyZSgnLi9mcm9iJylcbiAgLCBsZHU6IHJlcXVpcmUoJy4vbGR1Jylcbn1cbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGlvdGEgPSByZXF1aXJlKFwiaW90YS1hcnJheVwiKVxudmFyIGlzQnVmZmVyID0gcmVxdWlyZShcImlzLWJ1ZmZlclwiKVxuXG52YXIgaGFzVHlwZWRBcnJheXMgID0gKCh0eXBlb2YgRmxvYXQ2NEFycmF5KSAhPT0gXCJ1bmRlZmluZWRcIilcblxuZnVuY3Rpb24gY29tcGFyZTFzdChhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXVxufVxuXG5mdW5jdGlvbiBvcmRlcigpIHtcbiAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlXG4gIHZhciB0ZXJtcyA9IG5ldyBBcnJheShzdHJpZGUubGVuZ3RoKVxuICB2YXIgaVxuICBmb3IoaT0wOyBpPHRlcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdGVybXNbaV0gPSBbTWF0aC5hYnMoc3RyaWRlW2ldKSwgaV1cbiAgfVxuICB0ZXJtcy5zb3J0KGNvbXBhcmUxc3QpXG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodGVybXMubGVuZ3RoKVxuICBmb3IoaT0wOyBpPHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHRlcm1zW2ldWzFdXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGRpbWVuc2lvbikge1xuICB2YXIgY2xhc3NOYW1lID0gW1wiVmlld1wiLCBkaW1lbnNpb24sIFwiZFwiLCBkdHlwZV0uam9pbihcIlwiKVxuICBpZihkaW1lbnNpb24gPCAwKSB7XG4gICAgY2xhc3NOYW1lID0gXCJWaWV3X05pbFwiICsgZHR5cGVcbiAgfVxuICB2YXIgdXNlR2V0dGVycyA9IChkdHlwZSA9PT0gXCJnZW5lcmljXCIpXG5cbiAgaWYoZGltZW5zaW9uID09PSAtMSkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciB0cml2aWFsIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEpe3RoaXMuZGF0YT1hO307XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiAtMX07XFxcbnByb3RvLnNpemU9MDtcXFxucHJvdG8uZGltZW5zaW9uPS0xO1xcXG5wcm90by5zaGFwZT1wcm90by5zdHJpZGU9cHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPVxcXG5mdW5jdGlvbigpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSk7fTtcXFxucHJvdG8uZ2V0PXByb3RvLnNldD1mdW5jdGlvbigpe307XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEpO31cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKClcbiAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciAwZCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLGQpIHtcXFxudGhpcy5kYXRhID0gYTtcXFxudGhpcy5vZmZzZXQgPSBkXFxcbn07XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9mZnNldH07XFxcbnByb3RvLmRpbWVuc2lvbj0wO1xcXG5wcm90by5zaXplPTE7XFxcbnByb3RvLnNoYXBlPVxcXG5wcm90by5zdHJpZGU9XFxcbnByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1cXFxucHJvdG8uaGk9XFxcbnByb3RvLnRyYW5zcG9zZT1cXFxucHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfY29weSgpIHtcXFxucmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KVxcXG59O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKCl7XFxcbnJldHVybiBUcml2aWFsQXJyYXkodGhpcy5kYXRhKTtcXFxufTtcXFxucHJvdG8udmFsdWVPZj1wcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldCgpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5nZXQodGhpcy5vZmZzZXQpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF1cIikrXG5cIn07XFxcbnByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KHYpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5zZXQodGhpcy5vZmZzZXQsdilcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XT12XCIpK1wiXFxcbn07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEsYixjLGQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEsZCl9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiVHJpdmlhbEFycmF5XCIsIGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVswXSlcbiAgfVxuXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG5cbiAgLy9DcmVhdGUgY29uc3RydWN0b3IgZm9yIHZpZXdcbiAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbilcbiAgdmFyIGFyZ3MgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImlcIitpIH0pXG4gIHZhciBpbmRleF9zdHIgPSBcInRoaXMub2Zmc2V0K1wiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIiArIGkgKyBcIl0qaVwiICsgaVxuICAgICAgfSkuam9pbihcIitcIilcbiAgdmFyIHNoYXBlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICB2YXIgc3RyaWRlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICBjb2RlLnB1c2goXG4gICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxcIiArIHNoYXBlQXJnICsgXCIsXCIgKyBzdHJpZGVBcmcgKyBcIixkKXt0aGlzLmRhdGE9YVwiLFxuICAgICAgXCJ0aGlzLnNoYXBlPVtcIiArIHNoYXBlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMuc3RyaWRlPVtcIiArIHN0cmlkZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLm9mZnNldD1kfDB9XCIsXG4gICAgXCJ2YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZVwiLFxuICAgIFwicHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJ1wiLFxuICAgIFwicHJvdG8uZGltZW5zaW9uPVwiK2RpbWVuc2lvbilcblxuICAvL3ZpZXcuc2l6ZTpcbiAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdzaXplJyx7Z2V0OmZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zaXplKCl7XFxcbnJldHVybiBcIitpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcInRoaXMuc2hhcGVbXCIraStcIl1cIiB9KS5qb2luKFwiKlwiKSxcblwifX0pXCIpXG5cbiAgLy92aWV3Lm9yZGVyOlxuICBpZihkaW1lbnNpb24gPT09IDEpIHtcbiAgICBjb2RlLnB1c2goXCJwcm90by5vcmRlcj1bMF1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ29yZGVyJyx7Z2V0OlwiKVxuICAgIGlmKGRpbWVuc2lvbiA8IDQpIHtcbiAgICAgIGNvZGUucHVzaChcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9vcmRlcigpe1wiKVxuICAgICAgaWYoZGltZW5zaW9uID09PSAyKSB7XG4gICAgICAgIGNvZGUucHVzaChcInJldHVybiAoTWF0aC5hYnModGhpcy5zdHJpZGVbMF0pPk1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSk/WzEsMF06WzAsMV19fSlcIilcbiAgICAgIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDMpIHtcbiAgICAgICAgY29kZS5wdXNoKFxuXCJ2YXIgczA9TWF0aC5hYnModGhpcy5zdHJpZGVbMF0pLHMxPU1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSxzMj1NYXRoLmFicyh0aGlzLnN0cmlkZVsyXSk7XFxcbmlmKHMwPnMxKXtcXFxuaWYoczE+czIpe1xcXG5yZXR1cm4gWzIsMSwwXTtcXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzEsMiwwXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMSwwLDJdO1xcXG59XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsyLDAsMV07XFxcbn1lbHNlIGlmKHMyPnMxKXtcXFxucmV0dXJuIFswLDEsMl07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzAsMiwxXTtcXFxufX19KVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLnB1c2goXCJPUkRFUn0pXCIpXG4gICAgfVxuICB9XG5cbiAgLy92aWV3LnNldChpMCwgLi4uLCB2KTpcbiAgY29kZS5wdXNoKFxuXCJwcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldChcIithcmdzLmpvaW4oXCIsXCIpK1wiLHYpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5zZXQoXCIraW5kZXhfc3RyK1wiLHYpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXT12fVwiKVxuICB9XG5cbiAgLy92aWV3LmdldChpMCwgLi4uKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLmdldChcIitpbmRleF9zdHIrXCIpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXX1cIilcbiAgfVxuXG4gIC8vdmlldy5pbmRleDpcbiAgY29kZS5wdXNoKFxuICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2luZGV4KFwiLCBhcmdzLmpvaW4oKSwgXCIpe3JldHVybiBcIitpbmRleF9zdHIrXCJ9XCIpXG5cbiAgLy92aWV3LmhpKCk6XG4gIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9oaShcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFtcIih0eXBlb2YgaVwiLGksXCIhPT0nbnVtYmVyJ3x8aVwiLGksXCI8MCk/dGhpcy5zaGFwZVtcIiwgaSwgXCJdOmlcIiwgaSxcInwwXCJdLmpvaW4oXCJcIilcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIitpICsgXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LmxvKCk6XG4gIHZhciBhX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIiB9KVxuICB2YXIgY192YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJjXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiIH0pXG4gIGNvZGUucHVzaChcInByb3RvLmxvPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9sbyhcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgYj10aGlzLm9mZnNldCxkPTAsXCIrYV92YXJzLmpvaW4oXCIsXCIpK1wiLFwiK2NfdmFycy5qb2luKFwiLFwiKSlcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuYis9Y1wiK2krXCIqZDtcXFxuYVwiK2krXCItPWR9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixiKX1cIilcblxuICAvL3ZpZXcuc3RlcCgpOlxuICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zdGVwKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInKXtcXFxuZD1pXCIraStcInwwO1xcXG5pZihkPDApe1xcXG5jKz1iXCIraStcIiooYVwiK2krXCItMSk7XFxcbmFcIitpK1wiPWNlaWwoLWFcIitpK1wiL2QpXFxcbn1lbHNle1xcXG5hXCIraStcIj1jZWlsKGFcIitpK1wiL2QpXFxcbn1cXFxuYlwiK2krXCIqPWRcXFxufVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGMpfVwiKVxuXG4gIC8vdmlldy50cmFuc3Bvc2UoKTpcbiAgdmFyIHRTaGFwZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB0U2hhcGVbaV0gPSBcImFbaVwiK2krXCJdXCJcbiAgICB0U3RyaWRlW2ldID0gXCJiW2lcIitpK1wiXVwiXG4gIH1cbiAgY29kZS5wdXNoKFwicHJvdG8udHJhbnNwb3NlPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl90cmFuc3Bvc2UoXCIrYXJncytcIil7XCIrXG4gICAgYXJncy5tYXAoZnVuY3Rpb24obixpZHgpIHsgcmV0dXJuIG4gKyBcIj0oXCIgKyBuICsgXCI9PT11bmRlZmluZWQ/XCIgKyBpZHggKyBcIjpcIiArIG4gKyBcInwwKVwifSkuam9pbihcIjtcIiksXG4gICAgXCJ2YXIgYT10aGlzLnNoYXBlLGI9dGhpcy5zdHJpZGU7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK3RTaGFwZS5qb2luKFwiLFwiKStcIixcIit0U3RyaWRlLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcucGljaygpOlxuICBjb2RlLnB1c2goXCJwcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKFwiK2FyZ3MrXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7Yz0oYyt0aGlzLnN0cmlkZVtcIitpK1wiXSppXCIraStcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiK2krXCJdKTtiLnB1c2godGhpcy5zdHJpZGVbXCIraStcIl0pfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInZhciBjdG9yPUNUT1JfTElTVFthLmxlbmd0aCsxXTtyZXR1cm4gY3Rvcih0aGlzLmRhdGEsYSxiLGMpfVwiKVxuXG4gIC8vQWRkIHJldHVybiBzdGF0ZW1lbnRcbiAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoZGF0YSxzaGFwZSxzdHJpZGUsb2Zmc2V0KXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihkYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLG9mZnNldCl9XCIpXG5cbiAgLy9Db21waWxlIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdLCBvcmRlcilcbn1cblxuZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gIGlmKGlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYnVmZmVyXCJcbiAgfVxuICBpZihoYXNUeXBlZEFycmF5cykge1xuICAgIHN3aXRjaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhfY2xhbXBlZFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBCaWdJbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWdpbnQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBCaWdVaW50NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiYmlndWludDY0XCJcbiAgICB9XG4gIH1cbiAgaWYoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBcImFycmF5XCJcbiAgfVxuICByZXR1cm4gXCJnZW5lcmljXCJcbn1cblxudmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gIFwiZmxvYXQzMlwiOltdLFxuICBcImZsb2F0NjRcIjpbXSxcbiAgXCJpbnQ4XCI6W10sXG4gIFwiaW50MTZcIjpbXSxcbiAgXCJpbnQzMlwiOltdLFxuICBcInVpbnQ4XCI6W10sXG4gIFwidWludDE2XCI6W10sXG4gIFwidWludDMyXCI6W10sXG4gIFwiYXJyYXlcIjpbXSxcbiAgXCJ1aW50OF9jbGFtcGVkXCI6W10sXG4gIFwiYmlnaW50NjRcIjogW10sXG4gIFwiYmlndWludDY0XCI6IFtdLFxuICBcImJ1ZmZlclwiOltdLFxuICBcImdlbmVyaWNcIjpbXVxufVxuXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIENBQ0hFRF9DT05TVFJVQ1RPUlMpIHtcbiAgICBDQUNIRURfQ09OU1RSVUNUT1JTW2lkXS5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihpZCwgLTEpKVxuICB9XG59KTtcblxuZnVuY3Rpb24gd3JhcHBlZE5EQXJyYXlDdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldCkge1xuICBpZihkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3RvciA9IENBQ0hFRF9DT05TVFJVQ1RPUlMuYXJyYXlbMF1cbiAgICByZXR1cm4gY3RvcihbXSlcbiAgfSBlbHNlIGlmKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0YSA9IFtkYXRhXVxuICB9XG4gIGlmKHNoYXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaGFwZSA9IFsgZGF0YS5sZW5ndGggXVxuICB9XG4gIHZhciBkID0gc2hhcGUubGVuZ3RoXG4gIGlmKHN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWRlID0gbmV3IEFycmF5KGQpXG4gICAgZm9yKHZhciBpPWQtMSwgc3o9MTsgaT49MDsgLS1pKSB7XG4gICAgICBzdHJpZGVbaV0gPSBzelxuICAgICAgc3ogKj0gc2hhcGVbaV1cbiAgICB9XG4gIH1cbiAgaWYob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXQgPSAwXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBpZihzdHJpZGVbaV0gPCAwKSB7XG4gICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0tMSkqc3RyaWRlW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSlcbiAgdmFyIGN0b3JfbGlzdCA9IENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdXG4gIHdoaWxlKGN0b3JfbGlzdC5sZW5ndGggPD0gZCsxKSB7XG4gICAgY3Rvcl9saXN0LnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBjdG9yX2xpc3QubGVuZ3RoLTEpKVxuICB9XG4gIHZhciBjdG9yID0gY3Rvcl9saXN0W2QrMV1cbiAgcmV0dXJuIGN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChlcnJvckxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIHZhciBlcnJvckxpc3RlbmVyO1xuXG4gICAgLy8gQWRkaW5nIGFuIGVycm9yIGxpc3RlbmVyIGlzIG5vdCBvcHRpb25hbCBiZWNhdXNlXG4gICAgLy8gaWYgYW4gZXJyb3IgaXMgdGhyb3duIG9uIGFuIGV2ZW50IGVtaXR0ZXIgd2UgY2Fubm90XG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGFjdHVhbCBldmVudCB3ZSBhcmUgd2FpdGluZyB3aWxsXG4gICAgLy8gYmUgZmlyZWQuIFRoZSByZXN1bHQgY291bGQgYmUgYSBzaWxlbnQgd2F5IHRvIGNyZWF0ZVxuICAgIC8vIG1lbW9yeSBvciBmaWxlIGRlc2NyaXB0b3IgbGVha3MsIHdoaWNoIGlzIHNvbWV0aGluZ1xuICAgIC8vIHdlIHNob3VsZCBhdm9pZC5cbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcblxuICAgICAgZW1pdHRlci5vbmNlKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgfSk7XG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdFxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGVcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICByZXR1cm4geCp4ICsgeSp5XG59IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnpcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGU7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiY29uc3QgQ1ZVdGlscyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jdl91dGlscycpO1xuY29uc3QgTmRhcnJheSA9IHJlcXVpcmUoJ25kYXJyYXknKTtcbmNvbnN0IEludGVycDJEID0gcmVxdWlyZSgnbmRhcnJheS1saW5lYXItaW50ZXJwb2xhdGUnKS5kMjtcblxuY29uc3QgRnJhbWVHcmFiYmVyID0ge307XG5cbkZyYW1lR3JhYmJlci5jcmVhdGUgPSBmdW5jdGlvbiAoaW5wdXRTdHJlYW0pIHtcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xuICAgIGNvbnN0IF92aWRlb1NpemUgPSBDVlV0aWxzLmltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xuICAgIGNvbnN0IF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpO1xuICAgIGNvbnN0IF9zaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSk7XG4gICAgY29uc3QgX3RvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICBsZXQgX2RhdGEgPSBuZXcgVWludDhBcnJheShfc2l6ZS54ICogX3NpemUueSk7XG4gICAgY29uc3QgX2dyYXlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3ZpZGVvU2l6ZS54ICogX3ZpZGVvU2l6ZS55KTtcbiAgICBjb25zdCBfY2FudmFzRGF0YSA9IG5ldyBVaW50OEFycmF5KF9jYW52YXNTaXplLnggKiBfY2FudmFzU2l6ZS55KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG4gICAgY29uc3QgX2dyYXlJbWFnZUFycmF5ID0gTmRhcnJheShfZ3JheURhdGEsIFtfdmlkZW9TaXplLnksIF92aWRlb1NpemUueF0pLnRyYW5zcG9zZSgxLCAwKTtcbiAgICBjb25zdCBfY2FudmFzSW1hZ2VBcnJheSA9IE5kYXJyYXkoX2NhbnZhc0RhdGEsIFtfY2FudmFzU2l6ZS55LCBfY2FudmFzU2l6ZS54XSkudHJhbnNwb3NlKDEsIDApO1xuICAgIGNvbnN0IF90YXJnZXRJbWFnZUFycmF5ID0gX2NhbnZhc0ltYWdlQXJyYXlcbiAgICAgICAgLmhpKF90b3BSaWdodC54ICsgX3NpemUueCwgX3RvcFJpZ2h0LnkgKyBfc2l6ZS55KVxuICAgICAgICAubG8oX3RvcFJpZ2h0LngsIF90b3BSaWdodC55KTtcbiAgICBjb25zdCBfc3RlcFNpemVYID0gX3ZpZGVvU2l6ZS54IC8gX2NhbnZhc1NpemUueDtcbiAgICBjb25zdCBfc3RlcFNpemVZID0gX3ZpZGVvU2l6ZS55IC8gX2NhbnZhc1NpemUueTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX2dyYXlJbWFnZUFycmF5LnNoYXBlLFxuICAgICAgICAgICAgY2FudmFzU2l6ZTogX2NhbnZhc0ltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgICAgICBzdGVwU2l6ZTogW19zdGVwU2l6ZVgsIF9zdGVwU2l6ZVldLFxuICAgICAgICAgICAgc2l6ZTogX3RhcmdldEltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgICAgICB0b3BSaWdodDogX3RvcFJpZ2h0LFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlZCBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcblxuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVBbmRDcm9wKGZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgX3RoYXQuc2NhbGVBbmRDcm9wID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgLy8gMS4gY29tcHV0ZSBmdWxsLXNpemVkIGdyYXkgaW1hZ2VcbiAgICAgICAgQ1ZVdGlscy5jb21wdXRlR3JheShmcmFtZS5kYXRhLCBfZ3JheURhdGEpO1xuXG4gICAgICAgIC8vIDIuIGludGVycG9sYXRlXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX2NhbnZhc1NpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9jYW52YXNTaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICAgICAgX2NhbnZhc0ltYWdlQXJyYXkuc2V0KHgsIHksIChJbnRlcnAyRChfZ3JheUltYWdlQXJyYXksIHggKiBfc3RlcFNpemVYLCB5ICogX3N0ZXBTaXplWSkpIHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0YXJnZXRJbWFnZUFycmF5IG11c3QgYmUgZXF1YWwgdG8gdGFyZ2V0U2l6ZVxuICAgICAgICBpZiAoX3RhcmdldEltYWdlQXJyYXkuc2hhcGVbMF0gIT09IF9zaXplLnhcbiAgICAgICAgICAgIHx8IF90YXJnZXRJbWFnZUFycmF5LnNoYXBlWzFdICE9PSBfc2l6ZS55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlcyBkbyBub3QgbWF0Y2ghJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBjcm9wXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX3NpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIF9kYXRhW3kgKiBfc2l6ZS54ICsgeF0gPSBfdGFyZ2V0SW1hZ2VBcnJheS5nZXQoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lR3JhYmJlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBFUFNJTE9OOiByZXF1aXJlKCcuL2Vwc2lsb24nKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBhbmdsZTogcmVxdWlyZSgnLi9hbmdsZScpXG4gICwgZnJvbVZhbHVlczogcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIHNldDogcmVxdWlyZSgnLi9zZXQnKVxuICAsIGVxdWFsczogcmVxdWlyZSgnLi9lcXVhbHMnKVxuICAsIGV4YWN0RXF1YWxzOiByZXF1aXJlKCcuL2V4YWN0RXF1YWxzJylcbiAgLCBhZGQ6IHJlcXVpcmUoJy4vYWRkJylcbiAgLCBzdWJ0cmFjdDogcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4gICwgc3ViOiByZXF1aXJlKCcuL3N1YicpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIG11bDogcmVxdWlyZSgnLi9tdWwnKVxuICAsIGRpdmlkZTogcmVxdWlyZSgnLi9kaXZpZGUnKVxuICAsIGRpdjogcmVxdWlyZSgnLi9kaXYnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG5vcm1hbGl6ZTogcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxuICAsIGRvdDogcmVxdWlyZSgnLi9kb3QnKVxuICAsIGNyb3NzOiByZXF1aXJlKCcuL2Nyb3NzJylcbiAgLCBsZXJwOiByZXF1aXJlKCcuL2xlcnAnKVxuICAsIHJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgdHJhbnNmb3JtTWF0MzogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQzJylcbiAgLCB0cmFuc2Zvcm1RdWF0OiByZXF1aXJlKCcuL3RyYW5zZm9ybVF1YXQnKVxuICAsIHJvdGF0ZVg6IHJlcXVpcmUoJy4vcm90YXRlWCcpXG4gICwgcm90YXRlWTogcmVxdWlyZSgnLi9yb3RhdGVZJylcbiAgLCByb3RhdGVaOiByZXF1aXJlKCcuL3JvdGF0ZVonKVxuICAsIGZvckVhY2g6IHJlcXVpcmUoJy4vZm9yRWFjaCcpXG59XG4iLCJ2YXIgYmFzZVBpY2sgPSByZXF1aXJlKCcuL19iYXNlUGljaycpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG4iLCJpbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcblxuLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbmNvbnN0IFJhc3Rlcml6ZXIgPSB7XG4gICAgY3JlYXRlQ29udG91cjJEKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlyOiBudWxsLFxuICAgICAgICAgICAgaW5kZXg6IG51bGwsXG4gICAgICAgICAgICBmaXJzdFZlcnRleDogbnVsbCxcbiAgICAgICAgICAgIGluc2lkZUNvbnRvdXJzOiBudWxsLFxuICAgICAgICAgICAgbmV4dHBlZXI6IG51bGwsXG4gICAgICAgICAgICBwcmV2cGVlcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIENPTlRPVVJfRElSOiB7XG4gICAgICAgIENXX0RJUjogMCxcbiAgICAgICAgQ0NXX0RJUjogMSxcbiAgICAgICAgVU5LTk9XTl9ESVI6IDIsXG4gICAgfSxcbiAgICBESVI6IHtcbiAgICAgICAgT1VUU0lERV9FREdFOiAtMzI3NjcsXG4gICAgICAgIElOU0lERV9FREdFOiAtMzI3NjYsXG4gICAgfSxcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgICAgIGNvbnN0IHRyYWNlciA9IFRyYWNlci5jcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXN0ZXJpemUoZGVwdGhsYWJlbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2xvcjtcbiAgICAgICAgICAgICAgICBsZXQgYmM7XG4gICAgICAgICAgICAgICAgbGV0IGxjO1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgIGxldCBjeDtcbiAgICAgICAgICAgICAgICBsZXQgY3k7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JNYXAgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4O1xuICAgICAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgICAgIGxldCBjYztcbiAgICAgICAgICAgICAgICBsZXQgc2M7XG4gICAgICAgICAgICAgICAgbGV0IHBvcztcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQwMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xvck1hcFswXSA9IGltYWdlRGF0YVswXTtcbiAgICAgICAgICAgICAgICBjYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjeSA9IDE7IGN5IDwgaGVpZ2h0IC0gMTsgY3krKykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjeCA9IDE7IGN4IDwgd2lkdGggLSAxOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeSAqIHdpZHRoICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPT0gYmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY29ubmVjdGVkQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbbGNdID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgbGMsIGNvbG9yLCBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aGxhYmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBzYy5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjLmluc2lkZUNvbnRvdXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYy5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNjLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY29ubmVjdGVkQ291bnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgIGRyYXdDb250b3VyKGNhbnZhcywgZmlyc3RDb250b3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHEgPSBmaXJzdENvbnRvdXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGlxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcSA9IHBxLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocS5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHEuZmlyc3RWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocCAhPT0gcS5maXJzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUmFzdGVyaXplcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblxuLyogQHByZXNlcnZlIEFTTSBCRUdJTiAqL1xuZnVuY3Rpb24gU2tlbGV0b25pemVyKHN0ZGxpYiwgZm9yZWlnbiwgYnVmZmVyKSB7XG4gICAgJ3VzZSBhc20nO1xuXG4gICAgY29uc3QgaW1hZ2VzID0gbmV3IHN0ZGxpYi5VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3Qgc2l6ZSA9IGZvcmVpZ24uc2l6ZSB8IDA7XG4gICAgY29uc3QgeyBpbXVsIH0gPSBzdGRsaWIuTWF0aDtcblxuICAgIGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDIgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSAtIChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciB8PSAwO1xuICAgICAgICBiSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgfCAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgc3VtID0gKChzdW0gfCAwKSArIChpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoc3VtIHwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdChpbWFnZVB0ciwgdmFsdWUpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgdmFsdWUgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHYgPSAwO1xuICAgICAgICBsZXQgdSA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA+ICgwIHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZW1jcHkoc3JjSW1hZ2VQdHIsIGRzdEltYWdlUHRyKSB7XG4gICAgICAgIHNyY0ltYWdlUHRyIHw9IDA7XG4gICAgICAgIGRzdEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGRzdEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKGltYWdlc1soc3JjSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9Cb3JkZXIoaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB5ID0gMDtcblxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeCkgfCAwXSA9IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKCh5ICsgc2l6ZSkgLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh4ID0gMDsgKHggfCAwKSA8IChzaXplIHwgMCk7IHggPSAoeCArIDEpIHwgMCkge1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tlbGV0b25pemUoKSB7XG4gICAgICAgIGNvbnN0IHN1YkltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IGVyb2RlZEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHRlbXBJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBza2VsSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSAwO1xuXG4gICAgICAgIGVyb2RlZEltYWdlUHRyID0gaW11bChzaXplLCBzaXplKSB8IDA7XG4gICAgICAgIHRlbXBJbWFnZVB0ciA9IChlcm9kZWRJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG4gICAgICAgIHNrZWxJbWFnZVB0ciA9ICh0ZW1wSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xuXG4gICAgICAgIC8vIGluaXQgc2tlbC1pbWFnZVxuICAgICAgICBpbml0KHNrZWxJbWFnZVB0ciwgMCk7XG4gICAgICAgIHplcm9Cb3JkZXIoc3ViSW1hZ2VQdHIpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVyb2RlKHN1YkltYWdlUHRyLCBlcm9kZWRJbWFnZVB0cik7XG4gICAgICAgICAgICBkaWxhdGUoZXJvZGVkSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBzdWJ0cmFjdChzdWJJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgICAgICAgYml0d2lzZU9yKHNrZWxJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCBza2VsSW1hZ2VQdHIpO1xuICAgICAgICAgICAgbWVtY3B5KGVyb2RlZEltYWdlUHRyLCBzdWJJbWFnZVB0cik7XG4gICAgICAgICAgICBzdW0gPSBjb3VudE5vblplcm8oc3ViSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgICAgIGRvbmUgPSAoKHN1bSB8IDApID09IDAgfCAwKTtcbiAgICAgICAgfSB3aGlsZSAoIWRvbmUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBza2VsZXRvbml6ZSxcbiAgICB9O1xufVxuLyogQHByZXNlcnZlIEFTTSBFTkQgKi9cbmV4cG9ydCBkZWZhdWx0IFNrZWxldG9uaXplcjtcbi8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHBhdGggICAgICAgICAgPSByZXF1aXJlKCdwYXRoJylcbnZhciBuZGFycmF5ICAgICAgID0gcmVxdWlyZSgnbmRhcnJheScpXG52YXIgR2lmUmVhZGVyICAgICA9IHJlcXVpcmUoJ29tZ2dpZicpLkdpZlJlYWRlclxudmFyIHBhY2sgICAgICAgICAgPSByZXF1aXJlKCduZGFycmF5LXBhY2snKVxudmFyIHRocm91Z2ggICAgICAgPSByZXF1aXJlKCd0aHJvdWdoJylcbnZhciBwYXJzZURhdGFVUkkgID0gcmVxdWlyZSgnZGF0YS11cmktdG8tYnVmZmVyJylcblxuZnVuY3Rpb24gZGVmYXVsdEltYWdlKHVybCwgY2IpIHtcbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpXG4gIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCJcbiAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcbiAgICB2YXIgcGl4ZWxzID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KVxuICAgIGNiKG51bGwsIG5kYXJyYXkobmV3IFVpbnQ4QXJyYXkocGl4ZWxzLmRhdGEpLCBbaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCA0XSwgWzQsIDQqaW1nLndpZHRoLCAxXSwgMCkpXG4gIH1cbiAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBjYihlcnIpXG4gIH1cbiAgaW1nLnNyYyA9IHVybFxufVxuXG4vL0FuaW1hdGVkIGdpZiBsb2FkaW5nXG5mdW5jdGlvbiBoYW5kbGVHaWYoZGF0YSwgY2IpIHtcbiAgdmFyIHJlYWRlclxuICB0cnkge1xuICAgIHJlYWRlciA9IG5ldyBHaWZSZWFkZXIoZGF0YSlcbiAgfSBjYXRjaChlcnIpIHtcbiAgICBjYihlcnIpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYocmVhZGVyLm51bUZyYW1lcygpID4gMCkge1xuICAgIHZhciBuc2hhcGUgPSBbcmVhZGVyLm51bUZyYW1lcygpLCByZWFkZXIuaGVpZ2h0LCByZWFkZXIud2lkdGgsIDRdXG4gICAgdmFyIG5kYXRhID0gbmV3IFVpbnQ4QXJyYXkobnNoYXBlWzBdICogbnNoYXBlWzFdICogbnNoYXBlWzJdICogbnNoYXBlWzNdKVxuICAgIHZhciByZXN1bHQgPSBuZGFycmF5KG5kYXRhLCBuc2hhcGUpXG4gICAgdHJ5IHtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHJlYWRlci5udW1GcmFtZXMoKTsgKytpKSB7XG4gICAgICAgIHJlYWRlci5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKGksIG5kYXRhLnN1YmFycmF5KFxuICAgICAgICAgIHJlc3VsdC5pbmRleChpLCAwLCAwLCAwKSxcbiAgICAgICAgICByZXN1bHQuaW5kZXgoaSsxLCAwLCAwLCAwKSkpXG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYihudWxsLCByZXN1bHQudHJhbnNwb3NlKDAsMiwxKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgbnNoYXBlID0gW3JlYWRlci5oZWlnaHQsIHJlYWRlci53aWR0aCwgNF1cbiAgICB2YXIgbmRhdGEgPSBuZXcgVWludDhBcnJheShuc2hhcGVbMF0gKiBuc2hhcGVbMV0gKiBuc2hhcGVbMl0pXG4gICAgdmFyIHJlc3VsdCA9IG5kYXJyYXkobmRhdGEsIG5zaGFwZSlcbiAgICB0cnkge1xuICAgICAgcmVhZGVyLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoMCwgbmRhdGEpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYihudWxsLCByZXN1bHQudHJhbnNwb3NlKDEsMCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gaHR0cEdpZih1cmwsIGNiKSB7XG4gIHZhciB4aHIgICAgICAgICAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKVxuICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICBpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSl7XG4gICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2JpbmFyeScpXG4gIH1cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBjYihlcnIpXG4gIH1cbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpXG4gICAgaGFuZGxlR2lmKGRhdGEsIGNiKVxuICAgIHJldHVyblxuICB9XG4gIHhoci5zZW5kKClcbn1cblxuZnVuY3Rpb24gY29weUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoYnVmZmVyWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGhcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIHJlc3VsdFtpXSA9IGJ1ZmZlci5nZXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0YUdpZih1cmwsIGNiKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBidWZmZXIgPSBwYXJzZURhdGFVUkkodXJsKVxuICAgICAgaWYoYnVmZmVyKSB7XG4gICAgICAgIGhhbmRsZUdpZihjb3B5QnVmZmVyKGJ1ZmZlciksIGNiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIGRhdGEgVVJJJykpXG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UGl4ZWxzKHVybCwgdHlwZSwgY2IpIHtcbiAgaWYoIWNiKSB7XG4gICAgY2IgPSB0eXBlXG4gICAgdHlwZSA9ICcnXG4gIH1cbiAgdmFyIGV4dCA9IHBhdGguZXh0bmFtZSh1cmwpXG4gIHN3aXRjaCh0eXBlIHx8IGV4dC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY2FzZSAnLkdJRic6XG4gICAgICBodHRwR2lmKHVybCwgY2IpXG4gICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHVybCkpIHtcbiAgICAgICAgdXJsID0gJ2RhdGE6JyArIHR5cGUgKyAnO2Jhc2U2NCwnICsgdXJsLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgfVxuICAgICAgaWYodXJsLmluZGV4T2YoJ2RhdGE6aW1hZ2UvZ2lmOycpID09PSAwKSB7XG4gICAgICAgIGRhdGFHaWYodXJsLCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRJbWFnZSh1cmwsIGNiKVxuICAgICAgfVxuICB9XG59IiwiLypcbiAqIHR5cGVkZWZzLmpzXG4gKiBOb3JtYWxpemVzIGJyb3dzZXItc3BlY2lmaWMgcHJlZml4ZXMgYW5kIHByb3ZpZGUgc29tZSBiYXNpYyBwb2x5ZmlsbHNcbiAqL1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uICgvKiBmdW5jdGlvbiBGcmFtZVJlcXVlc3RDYWxsYmFjayAqLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZiBNYXRoLmltdWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgTWF0aC5pbXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBhbCA9IGEgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYmwgPSBiICYgMHhmZmZmO1xuICAgICAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XG4gICAgICAgIC8vIHRoZSBmaW5hbCB8MCBjb252ZXJ0cyB0aGUgdW5zaWduZWQgdmFsdWUgaW50byBhIHNpZ25lZCB2YWx1ZVxuICAgICAgICByZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApIHwgMCk7XG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXG5cbid1c2Ugc3RyaWN0JztcblxuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0byA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICBjb25zdCBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfTtcbn1cbiIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY29weVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXRcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXhhY3RFcXVhbHNcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbWluXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heFxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVcblxuLyoqXG4gKiBSb3RhdGVzIGEgdmVjMiBieSBhbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGFuZ2xlKSB7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgcyA9IE1hdGguc2luKGFuZ2xlKVxuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXVxuXG4gIG91dFswXSA9IHggKiBjIC0geSAqIHNcbiAgb3V0WzFdID0geCAqIHMgKyB5ICogY1xuXG4gIHJldHVybiBvdXRcbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNlaWxcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVBbmRBZGRcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlXG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemVcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeVxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBjcm9zc1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXG4gICAgb3V0WzBdID0gb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwXG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGVcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyZFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQzXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN11cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQ0XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbFxuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgc3RyaWRlID0gMlxuICAgIH1cblxuICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMFxuICAgIH1cbiAgICBcbiAgICBpZihjb3VudCkge1xuICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICB2ZWNbMF0gPSBhW2ldXG4gICAgICAgIHZlY1sxXSA9IGFbaSsxXVxuICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICBhW2ldID0gdmVjWzBdXG4gICAgICAgIGFbaSsxXSA9IHZlY1sxXVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGltaXQ7XG5cbi8qKlxuICogTGltaXQgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZlY3RvciB0byB0aGUgdmFsdWUgdXNlZCBmb3IgdGhlIGBtYXhgXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtICB7dmVjMn0gdGhlIHZlY3RvciB0byBsaW1pdFxuICogQHBhcmFtICB7TnVtYmVyfSBtYXggdGhlIG1heGltdW0gbWFnbml0dWRlIGZvciB0aGUgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxpbWl0KG91dCwgYSwgbWF4KSB7XG4gIHZhciBtU3EgPSBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdO1xuXG4gIGlmIChtU3EgPiBtYXggKiBtYXgpIHtcbiAgICB2YXIgbiA9IE1hdGguc3FydChtU3EpO1xuICAgIG91dFswXSA9IGFbMF0gLyBuICogbWF4O1xuICAgIG91dFsxXSA9IGFbMV0gLyBuICogbWF4O1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gYW5nbGVcblxudmFyIGZyb21WYWx1ZXMgPSByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbnZhciBkb3QgPSByZXF1aXJlKCcuL2RvdCcpXG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICB2YXIgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgdmFyIHRlbXBCID0gZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKVxuIFxuICAgIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpXG4gICAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQilcbiBcbiAgICB2YXIgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQilcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXG4gICAgfSAgICAgXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGIwID0gYlswXVxuICB2YXIgYjEgPSBiWzFdXG4gIHZhciBiMiA9IGJbMl1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtaW47XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZsb29yXG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pXG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3VuZFxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICBvdXRbMl0gPSBhWzJdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpXG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpXG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9sZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZWdhdGU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICBvdXRbMl0gPSAtYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVyc2U7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIG91dFsyXSA9IDEuMCAvIGFbMl1cbiAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3M7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl1cblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYnpcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl1cbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KVxuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpXG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheilcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb207XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMFxuXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIHZhciB6ID0gKE1hdGgucmFuZG9tKCkgKiAyLjApIC0gMS4wXG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlXG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlXG4gICAgb3V0WzJdID0geiAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV1cbiAgICB3ID0gdyB8fCAxLjBcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gd1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdXG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdXG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddXG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUXVhdDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHpcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xelxuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ5ID0gYlsxXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIFRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB5ID0gYVsxXSAtIGJ5XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG5cbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBieSArIHB5ICogY2MgLSBweiAqIHNjXG4gICAgb3V0WzJdID0gYnogKyBweSAqIHNjICsgcHogKiBjY1xuXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB4ID0gYVswXSAtIGJ4XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG4gICAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuICBcbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHogKiBzYyArIHB4ICogY2NcbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYnogKyBweiAqIGNjIC0gcHggKiBzY1xuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnggPSBiWzBdXG4gICAgdmFyIGJ5ID0gYlsxXVxuXG4gICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICBcbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHggKiBjYyAtIHB5ICogc2NcbiAgICBvdXRbMV0gPSBieSArIHB4ICogc2MgKyBweSAqIGNjXG4gICAgb3V0WzJdID0gYVsyXVxuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cbnZhciB2ZWMgPSByZXF1aXJlKCcuL2NyZWF0ZScpKClcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbFxuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzXG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV0gXG4gICAgICAgICAgICB2ZWNbMV0gPSBhW2krMV0gXG4gICAgICAgICAgICB2ZWNbMl0gPSBhW2krMl1cbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpXG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdIFxuICAgICAgICAgICAgYVtpKzFdID0gdmVjWzFdIFxuICAgICAgICAgICAgYVtpKzJdID0gdmVjWzJdXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhXG59IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmFudFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmRldGVybWluYW50XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc3Bvc2VcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi50cmFuc3Bvc2VcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTEgPSBhWzFdXG4gICAgb3V0WzFdID0gYVsyXVxuICAgIG91dFsyXSA9IGExXG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhWzFdXG4gICAgb3V0WzNdID0gYVszXVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBhbGlhcyBtYXQyLm11bHRpcGx5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM11cbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjFcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjFcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjNcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eVxuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBhbGlhcyBtYXQyLmlkZW50aXR5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkam9pbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5hZGpvaW50XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gIGFbMF1cbiAgb3V0WzBdID0gIGFbM11cbiAgb3V0WzFdID0gLWFbMV1cbiAgb3V0WzJdID0gLWFbMl1cbiAgb3V0WzNdID0gIGEwXG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAYWxpYXMgbWF0Mi5yb3RhdGVcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKVxuICB2YXIgYyA9IE1hdGguY29zKHJhZClcbiAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogc1xuICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzXG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGNcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogY1xuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydFxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuaW52ZXJ0XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGEzID0gYVszXVxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTFcblxuICBpZiAoIWRldCkgcmV0dXJuIG51bGxcbiAgZGV0ID0gMS4wIC8gZGV0XG5cbiAgb3V0WzBdID0gIGEzICogZGV0XG4gIG91dFsxXSA9IC1hMSAqIGRldFxuICBvdXRbMl0gPSAtYTIgKiBkZXRcbiAgb3V0WzNdID0gIGEwICogZGV0XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5jcmVhdGVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoNClcbiAgb3V0WzBdID0gMVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlXG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQGFsaWFzIG1hdDIuc2NhbGVcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgdjAgPSB2WzBdLCB2MSA9IHZbMV1cbiAgb3V0WzBdID0gYTAgKiB2MFxuICBvdXRbMV0gPSBhMSAqIHYwXG4gIG91dFsyXSA9IGEyICogdjFcbiAgb3V0WzNdID0gYTMgKiB2MVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQGFsaWFzIG1hdDIuY29weVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdXG4gIG91dFsxXSA9IGFbMV1cbiAgb3V0WzJdID0gYVsyXVxuICBvdXRbM10gPSBhWzNdXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvYlxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuZnJvYlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5mdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBNYXRoLnBvdyhhWzBdLCAyKSArXG4gICAgTWF0aC5wb3coYVsxXSwgMikgK1xuICAgIE1hdGgucG93KGFbMl0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzNdLCAyKVxuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGxkdVxuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5sZHVcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuZnVuY3Rpb24gbGR1KEwsIEQsIFUsIGEpIHtcbiAgTFsyXSA9IGFbMl0vYVswXVxuICBVWzBdID0gYVswXVxuICBVWzFdID0gYVsxXVxuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdXG4gIHJldHVybiBbTCwgRCwgVV1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMy5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vb21nZ2lmXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cbi8vXG4vLyBvbWdnaWYgaXMgYSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGEgR0lGIDg5YSBlbmNvZGVyIGFuZCBkZWNvZGVyLFxuLy8gaW5jbHVkaW5nIGFuaW1hdGlvbiBhbmQgY29tcHJlc3Npb24uICBJdCBkb2VzIG5vdCByZWx5IG9uIGFueSBzcGVjaWZpY1xuLy8gdW5kZXJseWluZyBzeXN0ZW0sIHNvIHNob3VsZCBydW4gaW4gdGhlIGJyb3dzZXIsIE5vZGUsIG9yIFBsYXNrLlxuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gR2lmV3JpdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgZ29wdHMpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIHZhciBnb3B0cyA9IGdvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBnb3B0cztcbiAgdmFyIGxvb3BfY291bnQgPSBnb3B0cy5sb29wID09PSB1bmRlZmluZWQgPyBudWxsIDogZ29wdHMubG9vcDtcbiAgdmFyIGdsb2JhbF9wYWxldHRlID0gZ29wdHMucGFsZXR0ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLnBhbGV0dGU7XG5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDAgfHwgd2lkdGggPiA2NTUzNSB8fCBoZWlnaHQgPiA2NTUzNSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aC9IZWlnaHQgaW52YWxpZC5cIik7XG5cbiAgZnVuY3Rpb24gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKSB7XG4gICAgdmFyIG51bV9jb2xvcnMgPSBwYWxldHRlLmxlbmd0aDtcbiAgICBpZiAobnVtX2NvbG9ycyA8IDIgfHwgbnVtX2NvbG9ycyA+IDI1NiB8fCAgbnVtX2NvbG9ycyAmIChudW1fY29sb3JzLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGNvZGUvY29sb3IgbGVuZ3RoLCBtdXN0IGJlIHBvd2VyIG9mIDIgYW5kIDIgLi4gMjU2LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bV9jb2xvcnM7XG4gIH1cblxuICAvLyAtIEhlYWRlci5cbiAgYnVmW3ArK10gPSAweDQ3OyBidWZbcCsrXSA9IDB4NDk7IGJ1ZltwKytdID0gMHg0NjsgIC8vIEdJRlxuICBidWZbcCsrXSA9IDB4Mzg7IGJ1ZltwKytdID0gMHgzOTsgYnVmW3ArK10gPSAweDYxOyAgLy8gODlhXG5cbiAgLy8gSGFuZGxpbmcgb2YgR2xvYmFsIENvbG9yIFRhYmxlIChwYWxldHRlKSBhbmQgYmFja2dyb3VuZCBpbmRleC5cbiAgdmFyIGdwX251bV9jb2xvcnNfcG93MiA9IDA7XG4gIHZhciBiYWNrZ3JvdW5kID0gMDtcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgdmFyIGdwX251bV9jb2xvcnMgPSBjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzKGdsb2JhbF9wYWxldHRlKTtcbiAgICB3aGlsZSAoZ3BfbnVtX2NvbG9ycyA+Pj0gMSkgKytncF9udW1fY29sb3JzX3BvdzI7XG4gICAgZ3BfbnVtX2NvbG9ycyA9IDEgPDwgZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIC0tZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGlmIChnb3B0cy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tncm91bmQgPSBnb3B0cy5iYWNrZ3JvdW5kO1xuICAgICAgaWYgKGJhY2tncm91bmQgPj0gZ3BfbnVtX2NvbG9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgICAgLy8gVGhlIEdJRiBzcGVjIHN0YXRlcyB0aGF0IGEgYmFja2dyb3VuZCBpbmRleCBvZiAwIHNob3VsZCBiZSBpZ25vcmVkLCBzb1xuICAgICAgLy8gdGhpcyBpcyBwcm9iYWJseSBhIG1pc3Rha2UgYW5kIHlvdSByZWFsbHkgd2FudCB0byBzZXQgaXQgdG8gYW5vdGhlclxuICAgICAgLy8gc2xvdCBpbiB0aGUgcGFsZXR0ZS4gIEJ1dCBhY3R1YWxseSBpbiB0aGUgZW5kIG1vc3QgYnJvd3NlcnMsIGV0YyBlbmRcbiAgICAgIC8vIHVwIGlnbm9yaW5nIHRoaXMgYWxtb3N0IGNvbXBsZXRlbHkgKGluY2x1ZGluZyBmb3IgZGlzcG9zZSBiYWNrZ3JvdW5kKS5cbiAgICAgIGlmIChiYWNrZ3JvdW5kID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZ3JvdW5kIGluZGV4IGV4cGxpY2l0bHkgcGFzc2VkIGFzIDAuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0gTG9naWNhbCBTY3JlZW4gRGVzY3JpcHRvci5cbiAgLy8gTk9URShkZWFubSk6IHcvaCBhcHBhcmVudGx5IGlnbm9yZWQgYnkgaW1wbGVtZW50YXRpb25zLCBidXQgc2V0IGFueXdheS5cbiAgYnVmW3ArK10gPSB3aWR0aCAmIDB4ZmY7IGJ1ZltwKytdID0gd2lkdGggPj4gOCAmIDB4ZmY7XG4gIGJ1ZltwKytdID0gaGVpZ2h0ICYgMHhmZjsgYnVmW3ArK10gPSBoZWlnaHQgPj4gOCAmIDB4ZmY7XG4gIC8vIE5PVEU6IEluZGljYXRlcyAwLWJwcCBvcmlnaW5hbCBjb2xvciByZXNvbHV0aW9uICh1bnVzZWQ/KS5cbiAgYnVmW3ArK10gPSAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwgPyAweDgwIDogMCkgfCAgLy8gR2xvYmFsIENvbG9yIFRhYmxlIEZsYWcuXG4gICAgICAgICAgICAgZ3BfbnVtX2NvbG9yc19wb3cyOyAgLy8gTk9URTogTm8gc29ydCBmbGFnICh1bnVzZWQ/KS5cbiAgYnVmW3ArK10gPSBiYWNrZ3JvdW5kOyAgLy8gQmFja2dyb3VuZCBDb2xvciBJbmRleC5cbiAgYnVmW3ArK10gPSAwOyAgLy8gUGl4ZWwgYXNwZWN0IHJhdGlvICh1bnVzZWQ/KS5cblxuICAvLyAtIEdsb2JhbCBDb2xvciBUYWJsZVxuICBpZiAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBnbG9iYWxfcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgcmdiID0gZ2xvYmFsX3BhbGV0dGVbaV07XG4gICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiA+PiA4ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gcmdiICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICBpZiAobG9vcF9jb3VudCAhPT0gbnVsbCkgeyAgLy8gTmV0c2NhcGUgYmxvY2sgZm9yIGxvb3BpbmcuXG4gICAgaWYgKGxvb3BfY291bnQgPCAwIHx8IGxvb3BfY291bnQgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvb3AgY291bnQgaW52YWxpZC5cIilcbiAgICAvLyBFeHRlbnNpb24gY29kZSwgbGFiZWwsIGFuZCBsZW5ndGguXG4gICAgYnVmW3ArK10gPSAweDIxOyBidWZbcCsrXSA9IDB4ZmY7IGJ1ZltwKytdID0gMHgwYjtcbiAgICAvLyBORVRTQ0FQRTIuMFxuICAgIGJ1ZltwKytdID0gMHg0ZTsgYnVmW3ArK10gPSAweDQ1OyBidWZbcCsrXSA9IDB4NTQ7IGJ1ZltwKytdID0gMHg1MztcbiAgICBidWZbcCsrXSA9IDB4NDM7IGJ1ZltwKytdID0gMHg0MTsgYnVmW3ArK10gPSAweDUwOyBidWZbcCsrXSA9IDB4NDU7XG4gICAgYnVmW3ArK10gPSAweDMyOyBidWZbcCsrXSA9IDB4MmU7IGJ1ZltwKytdID0gMHgzMDtcbiAgICAvLyBTdWItYmxvY2tcbiAgICBidWZbcCsrXSA9IDB4MDM7IGJ1ZltwKytdID0gMHgwMTtcbiAgICBidWZbcCsrXSA9IGxvb3BfY291bnQgJiAweGZmOyBidWZbcCsrXSA9IGxvb3BfY291bnQgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSAweDAwOyAgLy8gVGVybWluYXRvci5cbiAgfVxuXG5cbiAgdmFyIGVuZGVkID0gZmFsc2U7XG5cbiAgdGhpcy5hZGRGcmFtZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIGluZGV4ZWRfcGl4ZWxzLCBvcHRzKSB7XG4gICAgaWYgKGVuZGVkID09PSB0cnVlKSB7IC0tcDsgZW5kZWQgPSBmYWxzZTsgfSAgLy8gVW4tZW5kLlxuXG4gICAgb3B0cyA9IG9wdHMgPT09IHVuZGVmaW5lZCA/IHsgfSA6IG9wdHM7XG5cbiAgICAvLyBUT0RPKGRlYW5tKTogQm91bmRzIGNoZWNrIHgsIHkuICBEbyB0aGV5IG5lZWQgdG8gYmUgd2l0aGluIHRoZSB2aXJ0dWFsXG4gICAgLy8gY2FudmFzIHdpZHRoL2hlaWdodCwgSSBpbWFnaW5lP1xuICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID4gNjU1MzUgfHwgeSA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwieC95IGludmFsaWQuXCIpXG5cbiAgICBpZiAodyA8PSAwIHx8IGggPD0gMCB8fCB3ID4gNjU1MzUgfHwgaCA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpXG5cbiAgICBpZiAoaW5kZXhlZF9waXhlbHMubGVuZ3RoIDwgdyAqIGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZW5vdWdoIHBpeGVscyBmb3IgdGhlIGZyYW1lIHNpemUuXCIpO1xuXG4gICAgdmFyIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgIHZhciBwYWxldHRlID0gb3B0cy5wYWxldHRlO1xuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbCkge1xuICAgICAgdXNpbmdfbG9jYWxfcGFsZXR0ZSA9IGZhbHNlO1xuICAgICAgcGFsZXR0ZSA9IGdsb2JhbF9wYWxldHRlO1xuICAgIH1cblxuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGVpdGhlciBhIGxvY2FsIG9yIGdsb2JhbCBwYWxldHRlLlwiKTtcblxuICAgIHZhciBudW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1pbl9jb2RlX3NpemUgKHBvd2VyIG9mIDIpLCBkZXN0cm95aW5nIG51bV9jb2xvcnMuXG4gICAgdmFyIG1pbl9jb2RlX3NpemUgPSAwO1xuICAgIHdoaWxlIChudW1fY29sb3JzID4+PSAxKSArK21pbl9jb2RlX3NpemU7XG4gICAgbnVtX2NvbG9ycyA9IDEgPDwgbWluX2NvZGVfc2l6ZTsgIC8vIE5vdyB3ZSBjYW4gZWFzaWx5IGdldCBpdCBiYWNrLlxuXG4gICAgdmFyIGRlbGF5ID0gb3B0cy5kZWxheSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGVsYXk7XG5cbiAgICAvLyBGcm9tIHRoZSBzcGVjOlxuICAgIC8vICAgICAwIC0gICBObyBkaXNwb3NhbCBzcGVjaWZpZWQuIFRoZSBkZWNvZGVyIGlzXG4gICAgLy8gICAgICAgICAgIG5vdCByZXF1aXJlZCB0byB0YWtlIGFueSBhY3Rpb24uXG4gICAgLy8gICAgIDEgLSAgIERvIG5vdCBkaXNwb3NlLiBUaGUgZ3JhcGhpYyBpcyB0byBiZSBsZWZ0XG4gICAgLy8gICAgICAgICAgIGluIHBsYWNlLlxuICAgIC8vICAgICAyIC0gICBSZXN0b3JlIHRvIGJhY2tncm91bmQgY29sb3IuIFRoZSBhcmVhIHVzZWQgYnkgdGhlXG4gICAgLy8gICAgICAgICAgIGdyYXBoaWMgbXVzdCBiZSByZXN0b3JlZCB0byB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAvLyAgICAgMyAtICAgUmVzdG9yZSB0byBwcmV2aW91cy4gVGhlIGRlY29kZXIgaXMgcmVxdWlyZWQgdG9cbiAgICAvLyAgICAgICAgICAgcmVzdG9yZSB0aGUgYXJlYSBvdmVyd3JpdHRlbiBieSB0aGUgZ3JhcGhpYyB3aXRoXG4gICAgLy8gICAgICAgICAgIHdoYXQgd2FzIHRoZXJlIHByaW9yIHRvIHJlbmRlcmluZyB0aGUgZ3JhcGhpYy5cbiAgICAvLyAgNC03IC0gICAgVG8gYmUgZGVmaW5lZC5cbiAgICAvLyBOT1RFKGRlYW5tKTogRGlzcG9zZSBiYWNrZ3JvdW5kIGRvZXNuJ3QgcmVhbGx5IHdvcmssIGFwcGFyZW50bHkgbW9zdFxuICAgIC8vIGJyb3dzZXJzIGlnbm9yZSB0aGUgYmFja2dyb3VuZCBwYWxldHRlIGluZGV4IGFuZCBjbGVhciB0byB0cmFuc3BhcmVuY3kuXG4gICAgdmFyIGRpc3Bvc2FsID0gb3B0cy5kaXNwb3NhbCA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGlzcG9zYWw7XG4gICAgaWYgKGRpc3Bvc2FsIDwgMCB8fCBkaXNwb3NhbCA+IDMpICAvLyA0LTcgaXMgcmVzZXJ2ZWQuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNwb3NhbCBvdXQgb2YgcmFuZ2UuXCIpO1xuXG4gICAgdmFyIHVzZV90cmFuc3BhcmVuY3kgPSBmYWxzZTtcbiAgICB2YXIgdHJhbnNwYXJlbnRfaW5kZXggPSAwO1xuICAgIGlmIChvcHRzLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgJiYgb3B0cy50cmFuc3BhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdXNlX3RyYW5zcGFyZW5jeSA9IHRydWU7XG4gICAgICB0cmFuc3BhcmVudF9pbmRleCA9IG9wdHMudHJhbnNwYXJlbnQ7XG4gICAgICBpZiAodHJhbnNwYXJlbnRfaW5kZXggPCAwIHx8IHRyYW5zcGFyZW50X2luZGV4ID49IG51bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcGFyZW50IGNvbG9yIGluZGV4LlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzcG9zYWwgIT09IDAgfHwgdXNlX3RyYW5zcGFyZW5jeSB8fCBkZWxheSAhPT0gMCkge1xuICAgICAgLy8gLSBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgYnVmW3ArK10gPSAweDIxOyBidWZbcCsrXSA9IDB4Zjk7ICAvLyBFeHRlbnNpb24gLyBMYWJlbC5cbiAgICAgIGJ1ZltwKytdID0gNDsgIC8vIEJ5dGUgc2l6ZS5cblxuICAgICAgYnVmW3ArK10gPSBkaXNwb3NhbCA8PCAyIHwgKHVzZV90cmFuc3BhcmVuY3kgPT09IHRydWUgPyAxIDogMCk7XG4gICAgICBidWZbcCsrXSA9IGRlbGF5ICYgMHhmZjsgYnVmW3ArK10gPSBkZWxheSA+PiA4ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gdHJhbnNwYXJlbnRfaW5kZXg7ICAvLyBUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cbiAgICAgIGJ1ZltwKytdID0gMDsgIC8vIEJsb2NrIFRlcm1pbmF0b3IuXG4gICAgfVxuXG4gICAgLy8gLSBJbWFnZSBEZXNjcmlwdG9yXG4gICAgYnVmW3ArK10gPSAweDJjOyAgLy8gSW1hZ2UgU2VwZXJhdG9yLlxuICAgIGJ1ZltwKytdID0geCAmIDB4ZmY7IGJ1ZltwKytdID0geCA+PiA4ICYgMHhmZjsgIC8vIExlZnQuXG4gICAgYnVmW3ArK10gPSB5ICYgMHhmZjsgYnVmW3ArK10gPSB5ID4+IDggJiAweGZmOyAgLy8gVG9wLlxuICAgIGJ1ZltwKytdID0gdyAmIDB4ZmY7IGJ1ZltwKytdID0gdyA+PiA4ICYgMHhmZjtcbiAgICBidWZbcCsrXSA9IGggJiAweGZmOyBidWZbcCsrXSA9IGggPj4gOCAmIDB4ZmY7XG4gICAgLy8gTk9URTogTm8gc29ydCBmbGFnICh1bnVzZWQ/KS5cbiAgICAvLyBUT0RPKGRlYW5tKTogU3VwcG9ydCBpbnRlcmxhY2UuXG4gICAgYnVmW3ArK10gPSB1c2luZ19sb2NhbF9wYWxldHRlID09PSB0cnVlID8gKDB4ODAgfCAobWluX2NvZGVfc2l6ZS0xKSkgOiAwO1xuXG4gICAgLy8gLSBMb2NhbCBDb2xvciBUYWJsZVxuICAgIGlmICh1c2luZ19sb2NhbF9wYWxldHRlID09PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwYWxldHRlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIHJnYiA9IHBhbGV0dGVbaV07XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDE2ICYgMHhmZjtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiICYgMHhmZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwID0gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShcbiAgICAgICAgICAgIGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSA8IDIgPyAyIDogbWluX2NvZGVfc2l6ZSwgaW5kZXhlZF9waXhlbHMpO1xuXG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZW5kZWQgPT09IGZhbHNlKSB7XG4gICAgICBidWZbcCsrXSA9IDB4M2I7ICAvLyBUcmFpbGVyLlxuICAgICAgZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB0aGlzLmdldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYnVmOyB9O1xuICB0aGlzLnNldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKHYpIHsgYnVmID0gdjsgfTtcbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcDsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKHYpIHsgcCA9IHY7IH07XG59XG5cbi8vIE1haW4gY29tcHJlc3Npb24gcm91dGluZSwgcGFsZXR0ZSBpbmRleGVzIC0+IExaVyBjb2RlIHN0cmVhbS5cbi8vIHxpbmRleF9zdHJlYW18IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnkuXG5mdW5jdGlvbiBHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtKGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSwgaW5kZXhfc3RyZWFtKSB7XG4gIGJ1ZltwKytdID0gbWluX2NvZGVfc2l6ZTtcbiAgdmFyIGN1cl9zdWJibG9jayA9IHArKzsgIC8vIFBvaW50aW5nIGF0IHRoZSBsZW5ndGggZmllbGQuXG5cbiAgdmFyIGNsZWFyX2NvZGUgPSAxIDw8IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjb2RlX21hc2sgPSBjbGVhcl9jb2RlIC0gMTtcbiAgdmFyIGVvaV9jb2RlID0gY2xlYXJfY29kZSArIDE7XG4gIHZhciBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG5cbiAgdmFyIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTsgIC8vIE51bWJlciBvZiBiaXRzIHBlciBjb2RlLlxuICB2YXIgY3VyX3NoaWZ0ID0gMDtcbiAgLy8gV2UgaGF2ZSBhdCBtb3N0IDEyLWJpdCBjb2Rlcywgc28gd2Ugc2hvdWxkIGhhdmUgdG8gaG9sZCBhIG1heCBvZiAxOVxuICAvLyBiaXRzIGhlcmUgKGFuZCB0aGVuIHdlIHdvdWxkIHdyaXRlIG91dCkuXG4gIHZhciBjdXIgPSAwO1xuXG4gIGZ1bmN0aW9uIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKGJpdF9ibG9ja19zaXplKSB7XG4gICAgd2hpbGUgKGN1cl9zaGlmdCA+PSBiaXRfYmxvY2tfc2l6ZSkge1xuICAgICAgYnVmW3ArK10gPSBjdXIgJiAweGZmO1xuICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgIGlmIChwID09PSBjdXJfc3ViYmxvY2sgKyAyNTYpIHsgIC8vIEZpbmlzaGVkIGEgc3ViYmxvY2suXG4gICAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMjU1O1xuICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdF9jb2RlKGMpIHtcbiAgICBjdXIgfD0gYyA8PCBjdXJfc2hpZnQ7XG4gICAgY3VyX3NoaWZ0ICs9IGN1cl9jb2RlX3NpemU7XG4gICAgZW1pdF9ieXRlc190b19idWZmZXIoOCk7XG4gIH1cblxuICAvLyBJIGFtIG5vdCBhbiBleHBlcnQgb24gdGhlIHRvcGljLCBhbmQgSSBkb24ndCB3YW50IHRvIHdyaXRlIGEgdGhlc2lzLlxuICAvLyBIb3dldmVyLCBpdCBpcyBnb29kIHRvIG91dGxpbmUgaGVyZSB0aGUgYmFzaWMgYWxnb3JpdGhtIGFuZCB0aGUgZmV3IGRhdGFcbiAgLy8gc3RydWN0dXJlcyBhbmQgb3B0aW1pemF0aW9ucyBoZXJlIHRoYXQgbWFrZSB0aGlzIGltcGxlbWVudGF0aW9uIGZhc3QuXG4gIC8vIFRoZSBiYXNpYyBpZGVhIGJlaGluZCBMWlcgaXMgdG8gYnVpbGQgYSB0YWJsZSBvZiBwcmV2aW91c2x5IHNlZW4gcnVuc1xuICAvLyBhZGRyZXNzZWQgYnkgYSBzaG9ydCBpZCAoaGVyZWluIGNhbGxlZCBvdXRwdXQgY29kZSkuICBBbGwgZGF0YSBpc1xuICAvLyByZWZlcmVuY2VkIGJ5IGEgY29kZSwgd2hpY2ggcmVwcmVzZW50cyBvbmUgb3IgbW9yZSB2YWx1ZXMgZnJvbSB0aGVcbiAgLy8gb3JpZ2luYWwgaW5wdXQgc3RyZWFtLiAgQWxsIGlucHV0IGJ5dGVzIGNhbiBiZSByZWZlcmVuY2VkIGFzIHRoZSBzYW1lXG4gIC8vIHZhbHVlIGFzIGFuIG91dHB1dCBjb2RlLiAgU28gaWYgeW91IGRpZG4ndCB3YW50IGFueSBjb21wcmVzc2lvbiwgeW91XG4gIC8vIGNvdWxkIG1vcmUgb3IgbGVzcyBqdXN0IG91dHB1dCB0aGUgb3JpZ2luYWwgYnl0ZXMgYXMgY29kZXMgKHRoZXJlIGFyZVxuICAvLyBzb21lIGRldGFpbHMgdG8gdGhpcywgYnV0IGl0IGlzIHRoZSBpZGVhKS4gIEluIG9yZGVyIHRvIGFjaGlldmVcbiAgLy8gY29tcHJlc3Npb24sIHZhbHVlcyBncmVhdGVyIHRoZW4gdGhlIGlucHV0IHJhbmdlIChjb2RlcyBjYW4gYmUgdXAgdG9cbiAgLy8gMTItYml0IHdoaWxlIGlucHV0IG9ubHkgOC1iaXQpIHJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIHByZXZpb3VzbHkgc2VlblxuICAvLyBpbnB1dHMuICBUaGUgZGVjb21wcmVzc29yIGlzIGFibGUgdG8gYnVpbGQgdGhlIHNhbWUgbWFwcGluZyB3aGlsZVxuICAvLyBkZWNvZGluZywgc28gdGhlcmUgaXMgYWx3YXlzIGEgc2hhcmVkIGNvbW1vbiBrbm93bGVkZ2UgYmV0d2VlbiB0aGVcbiAgLy8gZW5jb2RpbmcgYW5kIGRlY29kZXIsIHdoaWNoIGlzIGFsc28gaW1wb3J0YW50IGZvciBcInRpbWluZ1wiIGFzcGVjdHMgbGlrZVxuICAvLyBob3cgdG8gaGFuZGxlIHZhcmlhYmxlIGJpdCB3aWR0aCBjb2RlIGVuY29kaW5nLlxuICAvL1xuICAvLyBPbmUgb2J2aW91cyBidXQgdmVyeSBpbXBvcnRhbnQgY29uc2VxdWVuY2Ugb2YgdGhlIHRhYmxlIHN5c3RlbSBpcyB0aGVyZVxuICAvLyBpcyBhbHdheXMgYSB1bmlxdWUgaWQgKGF0IG1vc3QgMTItYml0cykgdG8gbWFwIHRoZSBydW5zLiAgJ0EnIG1pZ2h0IGJlXG4gIC8vIDQsIHRoZW4gJ0FBJyBtaWdodCBiZSAxMCwgJ0FBQScgMTEsICdBQUFBJyAxMiwgZXRjLiAgVGhpcyByZWxhdGlvbnNoaXBcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGFuIGVmZmVjaWVudCBsb29rdXAgc3RyYXRlZ3kgZm9yIHRoZSBjb2RlIG1hcHBpbmcuICBXZVxuICAvLyBuZWVkIHRvIGtub3cgaWYgYSBydW4gaGFzIGJlZW4gc2VlbiBiZWZvcmUsIGFuZCBiZSBhYmxlIHRvIG1hcCB0aGF0IHJ1blxuICAvLyB0byB0aGUgb3V0cHV0IGNvZGUuICBTaW5jZSB3ZSBzdGFydCB3aXRoIGtub3duIHVuaXF1ZSBpZHMgKGlucHV0IGJ5dGVzKSxcbiAgLy8gYW5kIHRoZW4gZnJvbSB0aG9zZSBidWlsZCBtb3JlIHVuaXF1ZSBpZHMgKHRhYmxlIGVudHJpZXMpLCB3ZSBjYW5cbiAgLy8gY29udGludWUgdGhpcyBjaGFpbiAoYWxtb3N0IGxpa2UgYSBsaW5rZWQgbGlzdCkgdG8gYWx3YXlzIGhhdmUgc21hbGxcbiAgLy8gaW50ZWdlciB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIGN1cnJlbnQgYnl0ZSBjaGFpbnMgaW4gdGhlIGVuY29kZXIuXG4gIC8vIFRoaXMgbWVhbnMgaW5zdGVhZCBvZiB0cmFja2luZyB0aGUgaW5wdXQgYnl0ZXMgKEFBQUFCQ0QpIHRvIGtub3cgb3VyXG4gIC8vIGN1cnJlbnQgc3RhdGUsIHdlIGNhbiB0cmFjayB0aGUgdGFibGUgZW50cnkgZm9yIEFBQUFCQyAoaXQgaXMgZ3VhcmFudGVlZFxuICAvLyB0byBleGlzdCBieSB0aGUgbmF0dXJlIG9mIHRoZSBhbGdvcml0aG0pIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgRC5cbiAgLy8gVGhlcmVmb3IgdGhlIHR1cGxlIG9mICh0YWJsZV9lbnRyeSwgYnl0ZSkgaXMgZ3VhcmFudGVlZCB0byBhbHNvIGJlXG4gIC8vIHVuaXF1ZS4gIFRoaXMgYWxsb3dzIHVzIHRvIGNyZWF0ZSBhIHNpbXBsZSBsb29rdXAga2V5IGZvciBtYXBwaW5nIGlucHV0XG4gIC8vIHNlcXVlbmNlcyB0byBjb2RlcyAodGFibGUgaW5kaWNlcykgd2l0aG91dCBoYXZpbmcgdG8gc3RvcmUgb3Igc2VhcmNoXG4gIC8vIGFueSBvZiB0aGUgY29kZSBzZXF1ZW5jZXMuICBTbyBpZiAnQUFBQScgaGFzIGEgdGFibGUgZW50cnkgb2YgMTIsIHRoZVxuICAvLyB0dXBsZSBvZiAoJ0FBQUEnLCBLKSBmb3IgYW55IGlucHV0IGJ5dGUgSyB3aWxsIGJlIHVuaXF1ZSwgYW5kIGNhbiBiZSBvdXJcbiAgLy8ga2V5LiAgVGhpcyBsZWFkcyB0byBhIGludGVnZXIgdmFsdWUgYXQgbW9zdCAyMC1iaXRzLCB3aGljaCBjYW4gYWx3YXlzXG4gIC8vIGZpdCBpbiBhbiBTTUkgdmFsdWUgYW5kIGJlIHVzZWQgYXMgYSBmYXN0IHNwYXJzZSBhcnJheSAvIG9iamVjdCBrZXkuXG5cbiAgLy8gT3V0cHV0IGNvZGUgZm9yIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBpbmRleCBidWZmZXIuXG4gIHZhciBpYl9jb2RlID0gaW5kZXhfc3RyZWFtWzBdICYgY29kZV9tYXNrOyAgLy8gTG9hZCBmaXJzdCBpbnB1dCBpbmRleC5cbiAgdmFyIGNvZGVfdGFibGUgPSB7IH07ICAvLyBLZXknZCBvbiBvdXIgMjAtYml0IFwidHVwbGVcIi5cblxuICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7ICAvLyBTcGVjIHNheXMgZmlyc3QgY29kZSBzaG91bGQgYmUgYSBjbGVhciBjb2RlLlxuXG4gIC8vIEZpcnN0IGluZGV4IGFscmVhZHkgbG9hZGVkLCBwcm9jZXNzIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0uXG4gIGZvciAodmFyIGkgPSAxLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgdmFyIGsgPSBpbmRleF9zdHJlYW1baV0gJiBjb2RlX21hc2s7XG4gICAgdmFyIGN1cl9rZXkgPSBpYl9jb2RlIDw8IDggfCBrOyAgLy8gKHByZXYsIGspIHVuaXF1ZSB0dXBsZS5cbiAgICB2YXIgY3VyX2NvZGUgPSBjb2RlX3RhYmxlW2N1cl9rZXldOyAgLy8gYnVmZmVyICsgay5cblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdG8gY3JlYXRlIGEgbmV3IGNvZGUgdGFibGUgZW50cnkuXG4gICAgaWYgKGN1cl9jb2RlID09PSB1bmRlZmluZWQpIHsgIC8vIFdlIGRvbid0IGhhdmUgYnVmZmVyICsgay5cbiAgICAgIC8vIEVtaXQgaW5kZXggYnVmZmVyICh3aXRob3V0IGspLlxuICAgICAgLy8gVGhpcyBpcyBhbiBpbmxpbmUgdmVyc2lvbiBvZiBlbWl0X2NvZGUsIGJlY2F1c2UgdGhpcyBpcyB0aGUgY29yZVxuICAgICAgLy8gd3JpdGluZyByb3V0aW5lIG9mIHRoZSBjb21wcmVzc29yIChhbmQgVjggY2Fubm90IGlubGluZSBlbWl0X2NvZGVcbiAgICAgIC8vIGJlY2F1c2UgaXQgaXMgYSBjbG9zdXJlIGhlcmUgaW4gYSBkaWZmZXJlbnQgY29udGV4dCkuICBBZGRpdGlvbmFsbHlcbiAgICAgIC8vIHdlIGNhbiBjYWxsIGVtaXRfYnl0ZV90b19idWZmZXIgbGVzcyBvZnRlbiwgYmVjYXVzZSB3ZSBjYW4gaGF2ZVxuICAgICAgLy8gMzAtYml0cyAoZnJvbSBvdXIgMzEtYml0IHNpZ25lZCBTTUkpLCBhbmQgd2Uga25vdyBvdXIgY29kZXMgd2lsbCBvbmx5XG4gICAgICAvLyBiZSAxMi1iaXRzLCBzbyBjYW4gc2FmZWx5IGhhdmUgMTgtYml0cyB0aGVyZSB3aXRob3V0IG92ZXJmbG93LlxuICAgICAgLy8gZW1pdF9jb2RlKGliX2NvZGUpO1xuICAgICAgY3VyIHw9IGliX2NvZGUgPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IGN1cl9jb2RlX3NpemU7XG4gICAgICB3aGlsZSAoY3VyX3NoaWZ0ID49IDgpIHtcbiAgICAgICAgYnVmW3ArK10gPSBjdXIgJiAweGZmO1xuICAgICAgICBjdXIgPj49IDg7IGN1cl9zaGlmdCAtPSA4O1xuICAgICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMjU1O1xuICAgICAgICAgIGN1cl9zdWJibG9jayA9IHArKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dF9jb2RlID09PSA0MDk2KSB7ICAvLyBUYWJsZSBmdWxsLCBuZWVkIGEgY2xlYXIuXG4gICAgICAgIGVtaXRfY29kZShjbGVhcl9jb2RlKTtcbiAgICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgICBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7XG4gICAgICAgIGNvZGVfdGFibGUgPSB7IH07XG4gICAgICB9IGVsc2UgeyAgLy8gVGFibGUgbm90IGZ1bGwsIGluc2VydCBhIG5ldyBlbnRyeS5cbiAgICAgICAgLy8gSW5jcmVhc2Ugb3VyIHZhcmlhYmxlIGJpdCBjb2RlIHNpemVzIGlmIG5lY2Vzc2FyeS4gIFRoaXMgaXMgYSBiaXRcbiAgICAgICAgLy8gdHJpY2t5IGFzIGl0IGlzIGJhc2VkIG9uIFwidGltaW5nXCIgYmV0d2VlbiB0aGUgZW5jb2RpbmcgYW5kXG4gICAgICAgIC8vIGRlY29kZXIuICBGcm9tIHRoZSBlbmNvZGVycyBwZXJzcGVjdGl2ZSB0aGlzIHNob3VsZCBoYXBwZW4gYWZ0ZXJcbiAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBlbWl0dGVkIHRoZSBpbmRleCBidWZmZXIgYW5kIGFyZSBhYm91dCB0byBjcmVhdGUgdGhlXG4gICAgICAgIC8vIGZpcnN0IHRhYmxlIGVudHJ5IHRoYXQgd291bGQgb3ZlcmZsb3cgb3VyIGN1cnJlbnQgY29kZSBiaXQgc2l6ZS5cbiAgICAgICAgaWYgKG5leHRfY29kZSA+PSAoMSA8PCBjdXJfY29kZV9zaXplKSkgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX3RhYmxlW2N1cl9rZXldID0gbmV4dF9jb2RlKys7ICAvLyBJbnNlcnQgaW50byBjb2RlIHRhYmxlLlxuICAgICAgfVxuXG4gICAgICBpYl9jb2RlID0gazsgIC8vIEluZGV4IGJ1ZmZlciB0byBzaW5nbGUgaW5wdXQgay5cbiAgICB9IGVsc2Uge1xuICAgICAgaWJfY29kZSA9IGN1cl9jb2RlOyAgLy8gSW5kZXggYnVmZmVyIHRvIHNlcXVlbmNlIGluIGNvZGUgdGFibGUuXG4gICAgfVxuICB9XG5cbiAgZW1pdF9jb2RlKGliX2NvZGUpOyAgLy8gVGhlcmUgd2lsbCBzdGlsbCBiZSBzb21ldGhpbmcgaW4gdGhlIGluZGV4IGJ1ZmZlci5cbiAgZW1pdF9jb2RlKGVvaV9jb2RlKTsgIC8vIEVuZCBPZiBJbmZvcm1hdGlvbi5cblxuICAvLyBGbHVzaCAvIGZpbmFsaXplIHRoZSBzdWItYmxvY2tzIHN0cmVhbSB0byB0aGUgYnVmZmVyLlxuICBlbWl0X2J5dGVzX3RvX2J1ZmZlcigxKTtcblxuICAvLyBGaW5pc2ggdGhlIHN1Yi1ibG9ja3MsIHdyaXRpbmcgb3V0IGFueSB1bmZpbmlzaGVkIGxlbmd0aHMgYW5kXG4gIC8vIHRlcm1pbmF0aW5nIHdpdGggYSBzdWItYmxvY2sgb2YgbGVuZ3RoIDAuICBJZiB3ZSBoYXZlIGFscmVhZHkgc3RhcnRlZFxuICAvLyBidXQgbm90IHlldCB1c2VkIGEgc3ViLWJsb2NrIGl0IGNhbiBqdXN0IGJlY29tZSB0aGUgdGVybWluYXRvci5cbiAgaWYgKGN1cl9zdWJibG9jayArIDEgPT09IHApIHsgIC8vIFN0YXJ0ZWQgYnV0IHVudXNlZC5cbiAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDA7XG4gIH0gZWxzZSB7ICAvLyBTdGFydGVkIGFuZCB1c2VkLCB3cml0ZSBsZW5ndGggYW5kIGFkZGl0aW9uYWwgdGVybWluYXRvciBibG9jay5cbiAgICBidWZbY3VyX3N1YmJsb2NrXSA9IHAgLSBjdXJfc3ViYmxvY2sgLSAxO1xuICAgIGJ1ZltwKytdID0gMDtcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gR2lmUmVhZGVyKGJ1Zikge1xuICB2YXIgcCA9IDA7XG5cbiAgLy8gLSBIZWFkZXIgKEdJRjg3YSBvciBHSUY4OWEpLlxuICBpZiAoYnVmW3ArK10gIT09IDB4NDcgfHwgICAgICAgICAgICBidWZbcCsrXSAhPT0gMHg0OSB8fCBidWZbcCsrXSAhPT0gMHg0NiB8fFxuICAgICAgYnVmW3ArK10gIT09IDB4MzggfHwgKGJ1ZltwKytdKzEgJiAweGZkKSAhPT0gMHgzOCB8fCBidWZbcCsrXSAhPT0gMHg2MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR0lGIDg3YS84OWEgaGVhZGVyLlwiKTtcbiAgfVxuXG4gIC8vIC0gTG9naWNhbCBTY3JlZW4gRGVzY3JpcHRvci5cbiAgdmFyIHdpZHRoID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICB2YXIgaGVpZ2h0ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICB2YXIgcGYwID0gYnVmW3ArK107ICAvLyA8UGFja2VkIEZpZWxkcz4uXG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9mbGFnID0gcGYwID4+IDc7XG4gIHZhciBudW1fZ2xvYmFsX2NvbG9yc19wb3cyID0gcGYwICYgMHg3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnMgPSAxIDw8IChudW1fZ2xvYmFsX2NvbG9yc19wb3cyICsgMSk7XG4gIHZhciBiYWNrZ3JvdW5kID0gYnVmW3ArK107XG4gIGJ1ZltwKytdOyAgLy8gUGl4ZWwgYXNwZWN0IHJhdGlvICh1bnVzZWQ/KS5cblxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gbnVsbDtcbiAgdmFyIGdsb2JhbF9wYWxldHRlX3NpemUgICA9IG51bGw7XG5cbiAgaWYgKGdsb2JhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQgPSBwO1xuICAgIGdsb2JhbF9wYWxldHRlX3NpemUgPSBudW1fZ2xvYmFsX2NvbG9ycztcbiAgICBwICs9IG51bV9nbG9iYWxfY29sb3JzICogMzsgIC8vIFNlZWsgcGFzdCBwYWxldHRlLlxuICB9XG5cbiAgdmFyIG5vX2VvZiA9IHRydWU7XG5cbiAgdmFyIGZyYW1lcyA9IFsgXTtcblxuICB2YXIgZGVsYXkgPSAwO1xuICB2YXIgdHJhbnNwYXJlbnRfaW5kZXggPSBudWxsO1xuICB2YXIgZGlzcG9zYWwgPSAwOyAgLy8gMCAtIE5vIGRpc3Bvc2FsIHNwZWNpZmllZC5cbiAgdmFyIGxvb3BfY291bnQgPSBudWxsO1xuXG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgd2hpbGUgKG5vX2VvZiAmJiBwIDwgYnVmLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoYnVmW3ArK10pIHtcbiAgICAgIGNhc2UgMHgyMTogIC8vIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uIEJsb2NrXG4gICAgICAgIHN3aXRjaCAoYnVmW3ArK10pIHtcbiAgICAgICAgICBjYXNlIDB4ZmY6ICAvLyBBcHBsaWNhdGlvbiBzcGVjaWZpYyBibG9ja1xuICAgICAgICAgICAgLy8gVHJ5IGlmIGl0J3MgYSBOZXRzY2FwZSBibG9jayAod2l0aCBhbmltYXRpb24gbG9vcCBjb3VudGVyKS5cbiAgICAgICAgICAgIGlmIChidWZbcCAgIF0gIT09IDB4MGIgfHwgIC8vIDIxIEZGIGFscmVhZHkgcmVhZCwgY2hlY2sgYmxvY2sgc2l6ZS5cbiAgICAgICAgICAgICAgICAvLyBORVRTQ0FQRTIuMFxuICAgICAgICAgICAgICAgIGJ1ZltwKzEgXSA9PSAweDRlICYmIGJ1ZltwKzIgXSA9PSAweDQ1ICYmIGJ1ZltwKzMgXSA9PSAweDU0ICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNCBdID09IDB4NTMgJiYgYnVmW3ArNSBdID09IDB4NDMgJiYgYnVmW3ArNiBdID09IDB4NDEgJiZcbiAgICAgICAgICAgICAgICBidWZbcCs3IF0gPT0gMHg1MCAmJiBidWZbcCs4IF0gPT0gMHg0NSAmJiBidWZbcCs5IF0gPT0gMHgzMiAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzEwXSA9PSAweDJlICYmIGJ1ZltwKzExXSA9PSAweDMwICYmXG4gICAgICAgICAgICAgICAgLy8gU3ViLWJsb2NrXG4gICAgICAgICAgICAgICAgYnVmW3ArMTJdID09IDB4MDMgJiYgYnVmW3ArMTNdID09IDB4MDEgJiYgYnVmW3ArMTZdID09IDApIHtcbiAgICAgICAgICAgICAgcCArPSAxNDtcbiAgICAgICAgICAgICAgbG9vcF9jb3VudCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgICAgICAgcCsrOyAgLy8gU2tpcCB0ZXJtaW5hdG9yLlxuICAgICAgICAgICAgfSBlbHNlIHsgIC8vIFdlIGRvbid0IGtub3cgd2hhdCBpdCBpcywganVzdCB0cnkgdG8gZ2V0IHBhc3QgaXQuXG4gICAgICAgICAgICAgIHAgKz0gMTI7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7ICAvLyBTZWVrIHRocm91Z2ggc3ViYmxvY2tzLlxuICAgICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmOTogIC8vIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoYnVmW3ArK10gIT09IDB4NCB8fCBidWZbcCs0XSAhPT0gMClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncmFwaGljcyBleHRlbnNpb24gYmxvY2suXCIpO1xuICAgICAgICAgICAgdmFyIHBmMSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgZGVsYXkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICB0cmFuc3BhcmVudF9pbmRleCA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgaWYgKChwZjEgJiAxKSA9PT0gMCkgdHJhbnNwYXJlbnRfaW5kZXggPSBudWxsO1xuICAgICAgICAgICAgZGlzcG9zYWwgPSBwZjEgPj4gMiAmIDB4NztcbiAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweGZlOiAgLy8gQ29tbWVudCBFeHRlbnNpb24uXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgdmFyIGJsb2NrX3NpemUgPSBidWZbcCsrXTtcbiAgICAgICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gMCBzaXplIGlzIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYnVmLnNsaWNlKHAsIHArYmxvY2tfc2l6ZSkudG9TdHJpbmcoJ2FzY2lpJykpO1xuICAgICAgICAgICAgICBwICs9IGJsb2NrX3NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmtub3duIGdyYXBoaWMgY29udHJvbCBsYWJlbDogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgyYzogIC8vIEltYWdlIERlc2NyaXB0b3IuXG4gICAgICAgIHZhciB4ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgeSA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHcgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciBoID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgcGYyID0gYnVmW3ArK107XG4gICAgICAgIHZhciBsb2NhbF9wYWxldHRlX2ZsYWcgPSBwZjIgPj4gNztcbiAgICAgICAgdmFyIGludGVybGFjZV9mbGFnID0gcGYyID4+IDYgJiAxO1xuICAgICAgICB2YXIgbnVtX2xvY2FsX2NvbG9yc19wb3cyID0gcGYyICYgMHg3O1xuICAgICAgICB2YXIgbnVtX2xvY2FsX2NvbG9ycyA9IDEgPDwgKG51bV9sb2NhbF9jb2xvcnNfcG93MiArIDEpO1xuICAgICAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQ7XG4gICAgICAgIHZhciBwYWxldHRlX3NpemUgPSBnbG9iYWxfcGFsZXR0ZV9zaXplO1xuICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxvY2FsX3BhbGV0dGVfZmxhZykge1xuICAgICAgICAgIHZhciBoYXNfbG9jYWxfcGFsZXR0ZSA9IHRydWU7XG4gICAgICAgICAgcGFsZXR0ZV9vZmZzZXQgPSBwOyAgLy8gT3ZlcnJpZGUgd2l0aCBsb2NhbCBwYWxldHRlLlxuICAgICAgICAgIHBhbGV0dGVfc2l6ZSA9IG51bV9sb2NhbF9jb2xvcnM7XG4gICAgICAgICAgcCArPSBudW1fbG9jYWxfY29sb3JzICogMzsgIC8vIFNlZWsgcGFzdCBwYWxldHRlLlxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFfb2Zmc2V0ID0gcDtcblxuICAgICAgICBwKys7ICAvLyBjb2Rlc2l6ZVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWVzLnB1c2goe3g6IHgsIHk6IHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICBoYXNfbG9jYWxfcGFsZXR0ZTogaGFzX2xvY2FsX3BhbGV0dGUsXG4gICAgICAgICAgICAgICAgICAgICBwYWxldHRlX29mZnNldDogcGFsZXR0ZV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBwYWxldHRlX3NpemU6IHBhbGV0dGVfc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGFfb2Zmc2V0OiBkYXRhX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGFfbGVuZ3RoOiBwIC0gZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudF9pbmRleDogdHJhbnNwYXJlbnRfaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICBpbnRlcmxhY2VkOiAhIWludGVybGFjZV9mbGFnLFxuICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWw6IGRpc3Bvc2FsfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4M2I6ICAvLyBUcmFpbGVyIE1hcmtlciAoZW5kIG9mIGZpbGUpLlxuICAgICAgICBub19lb2YgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZ2lmIGJsb2NrOiAweFwiICsgYnVmW3AtMV0udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5udW1GcmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnJhbWVzLmxlbmd0aDtcbiAgfTtcblxuICB0aGlzLmxvb3BDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsb29wX2NvdW50O1xuICB9O1xuXG4gIHRoaXMuZnJhbWVJbmZvID0gZnVuY3Rpb24oZnJhbWVfbnVtKSB7XG4gICAgaWYgKGZyYW1lX251bSA8IDAgfHwgZnJhbWVfbnVtID49IGZyYW1lcy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFtZSBpbmRleCBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgIHJldHVybiBmcmFtZXNbZnJhbWVfbnVtXTtcbiAgfVxuXG4gIHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lQkdSQSA9IGZ1bmN0aW9uKGZyYW1lX251bSwgcGl4ZWxzKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZUluZm8oZnJhbWVfbnVtKTtcbiAgICB2YXIgbnVtX3BpeGVscyA9IGZyYW1lLndpZHRoICogZnJhbWUuaGVpZ2h0O1xuICAgIHZhciBpbmRleF9zdHJlYW0gPSBuZXcgVWludDhBcnJheShudW1fcGl4ZWxzKTsgIC8vIEF0IG1vc3QgOC1iaXQgaW5kaWNlcy5cbiAgICBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShcbiAgICAgICAgYnVmLCBmcmFtZS5kYXRhX29mZnNldCwgaW5kZXhfc3RyZWFtLCBudW1fcGl4ZWxzKTtcbiAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBmcmFtZS5wYWxldHRlX29mZnNldDtcblxuICAgIC8vIE5PVEUoZGVhbm0pOiBJdCBzZWVtcyB0byBiZSBtdWNoIGZhc3RlciB0byBjb21wYXJlIGluZGV4IHRvIDI1NiB0aGFuXG4gICAgLy8gdG8gPT09IG51bGwuICBOb3Qgc3VyZSB3aHksIGJ1dCBDb21wYXJlU3R1Yl9FUV9TVFJJQ1Qgc2hvd3MgdXAgaGlnaCBpblxuICAgIC8vIHRoZSBwcm9maWxlLCBub3Qgc3VyZSBpZiBpdCdzIHJlbGF0ZWQgdG8gdXNpbmcgYSBVaW50OEFycmF5LlxuICAgIHZhciB0cmFucyA9IGZyYW1lLnRyYW5zcGFyZW50X2luZGV4O1xuICAgIGlmICh0cmFucyA9PT0gbnVsbCkgdHJhbnMgPSAyNTY7XG5cbiAgICAvLyBXZSBhcmUgcG9zc2libHkganVzdCBibGl0dGluZyB0byBhIHBvcnRpb24gb2YgdGhlIGVudGlyZSBmcmFtZS5cbiAgICAvLyBUaGF0IGlzIGEgc3VicmVjdCB3aXRoaW4gdGhlIGZyYW1lcmVjdCwgc28gdGhlIGFkZGl0aW9uYWwgcGl4ZWxzXG4gICAgLy8gbXVzdCBiZSBza2lwcGVkIG92ZXIgYWZ0ZXIgd2UgZmluaXNoZWQgYSBzY2FubGluZS5cbiAgICB2YXIgZnJhbWV3aWR0aCAgPSBmcmFtZS53aWR0aDtcbiAgICB2YXIgZnJhbWVzdHJpZGUgPSB3aWR0aCAtIGZyYW1ld2lkdGg7XG4gICAgdmFyIHhsZWZ0ICAgICAgID0gZnJhbWV3aWR0aDsgIC8vIE51bWJlciBvZiBzdWJyZWN0IHBpeGVscyBsZWZ0IGluIHNjYW5saW5lLlxuXG4gICAgLy8gT3V0cHV0IGluZGljaWVzIG9mIHRoZSB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGNvcm5lcnMgb2YgdGhlIHN1YnJlY3QuXG4gICAgdmFyIG9wYmVnID0gKChmcmFtZS55ICogd2lkdGgpICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcGVuZCA9ICgoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgKiB3aWR0aCArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3AgICAgPSBvcGJlZztcblxuICAgIHZhciBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0O1xuXG4gICAgLy8gVXNlIHNjYW5zdHJpZGUgdG8gc2tpcCBwYXN0IHRoZSByb3dzIHdoZW4gaW50ZXJsYWNpbmcuICBUaGlzIGlzIHNraXBwaW5nXG4gICAgLy8gNyByb3dzIGZvciB0aGUgZmlyc3QgdHdvIHBhc3NlcywgdGhlbiAzIHRoZW4gMS5cbiAgICBpZiAoZnJhbWUuaW50ZXJsYWNlZCA9PT0gdHJ1ZSkge1xuICAgICAgc2NhbnN0cmlkZSArPSB3aWR0aCAqIDQgKiA3OyAgLy8gUGFzcyAxLlxuICAgIH1cblxuICAgIHZhciBpbnRlcmxhY2Vza2lwID0gODsgIC8vIFRyYWNraW5nIHRoZSByb3cgaW50ZXJ2YWwgaW4gdGhlIGN1cnJlbnQgcGFzcy5cblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleF9zdHJlYW1baV07XG5cbiAgICAgIGlmICh4bGVmdCA9PT0gMCkgeyAgLy8gQmVnaW5uaW5nIG9mIG5ldyBzY2FuIGxpbmVcbiAgICAgICAgb3AgKz0gc2NhbnN0cmlkZTtcbiAgICAgICAgeGxlZnQgPSBmcmFtZXdpZHRoO1xuICAgICAgICBpZiAob3AgPj0gb3BlbmQpIHsgLy8gQ2F0Y2ggdGhlIHdyYXAgdG8gc3dpdGNoIHBhc3NlcyB3aGVuIGludGVybGFjaW5nLlxuICAgICAgICAgIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQgKyB3aWR0aCAqIDQgKiAoaW50ZXJsYWNlc2tpcC0xKTtcbiAgICAgICAgICAvLyBpbnRlcmxhY2Vza2lwIC8gMiAqIDQgaXMgaW50ZXJsYWNlc2tpcCA8PCAxLlxuICAgICAgICAgIG9wID0gb3BiZWcgKyAoZnJhbWV3aWR0aCArIGZyYW1lc3RyaWRlKSAqIChpbnRlcmxhY2Vza2lwIDw8IDEpO1xuICAgICAgICAgIGludGVybGFjZXNraXAgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSB0cmFucykge1xuICAgICAgICBvcCArPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDNdO1xuICAgICAgICB2YXIgZyA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDFdO1xuICAgICAgICB2YXIgYiA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDJdO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBiO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBnO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSByO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSAyNTU7XG4gICAgICB9XG4gICAgICAtLXhsZWZ0O1xuICAgIH1cbiAgfTtcblxuICAvLyBJIHdpbGwgZ28gdG8gY29weSBhbmQgcGFzdGUgaGVsbCBvbmUgZGF5Li4uXG4gIHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSA9IGZ1bmN0aW9uKGZyYW1lX251bSwgcGl4ZWxzKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZUluZm8oZnJhbWVfbnVtKTtcbiAgICB2YXIgbnVtX3BpeGVscyA9IGZyYW1lLndpZHRoICogZnJhbWUuaGVpZ2h0O1xuICAgIHZhciBpbmRleF9zdHJlYW0gPSBuZXcgVWludDhBcnJheShudW1fcGl4ZWxzKTsgIC8vIEF0IG1vc3QgOC1iaXQgaW5kaWNlcy5cbiAgICBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShcbiAgICAgICAgYnVmLCBmcmFtZS5kYXRhX29mZnNldCwgaW5kZXhfc3RyZWFtLCBudW1fcGl4ZWxzKTtcbiAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBmcmFtZS5wYWxldHRlX29mZnNldDtcblxuICAgIC8vIE5PVEUoZGVhbm0pOiBJdCBzZWVtcyB0byBiZSBtdWNoIGZhc3RlciB0byBjb21wYXJlIGluZGV4IHRvIDI1NiB0aGFuXG4gICAgLy8gdG8gPT09IG51bGwuICBOb3Qgc3VyZSB3aHksIGJ1dCBDb21wYXJlU3R1Yl9FUV9TVFJJQ1Qgc2hvd3MgdXAgaGlnaCBpblxuICAgIC8vIHRoZSBwcm9maWxlLCBub3Qgc3VyZSBpZiBpdCdzIHJlbGF0ZWQgdG8gdXNpbmcgYSBVaW50OEFycmF5LlxuICAgIHZhciB0cmFucyA9IGZyYW1lLnRyYW5zcGFyZW50X2luZGV4O1xuICAgIGlmICh0cmFucyA9PT0gbnVsbCkgdHJhbnMgPSAyNTY7XG5cbiAgICAvLyBXZSBhcmUgcG9zc2libHkganVzdCBibGl0dGluZyB0byBhIHBvcnRpb24gb2YgdGhlIGVudGlyZSBmcmFtZS5cbiAgICAvLyBUaGF0IGlzIGEgc3VicmVjdCB3aXRoaW4gdGhlIGZyYW1lcmVjdCwgc28gdGhlIGFkZGl0aW9uYWwgcGl4ZWxzXG4gICAgLy8gbXVzdCBiZSBza2lwcGVkIG92ZXIgYWZ0ZXIgd2UgZmluaXNoZWQgYSBzY2FubGluZS5cbiAgICB2YXIgZnJhbWV3aWR0aCAgPSBmcmFtZS53aWR0aDtcbiAgICB2YXIgZnJhbWVzdHJpZGUgPSB3aWR0aCAtIGZyYW1ld2lkdGg7XG4gICAgdmFyIHhsZWZ0ICAgICAgID0gZnJhbWV3aWR0aDsgIC8vIE51bWJlciBvZiBzdWJyZWN0IHBpeGVscyBsZWZ0IGluIHNjYW5saW5lLlxuXG4gICAgLy8gT3V0cHV0IGluZGljaWVzIG9mIHRoZSB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGNvcm5lcnMgb2YgdGhlIHN1YnJlY3QuXG4gICAgdmFyIG9wYmVnID0gKChmcmFtZS55ICogd2lkdGgpICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcGVuZCA9ICgoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgKiB3aWR0aCArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3AgICAgPSBvcGJlZztcblxuICAgIHZhciBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0O1xuXG4gICAgLy8gVXNlIHNjYW5zdHJpZGUgdG8gc2tpcCBwYXN0IHRoZSByb3dzIHdoZW4gaW50ZXJsYWNpbmcuICBUaGlzIGlzIHNraXBwaW5nXG4gICAgLy8gNyByb3dzIGZvciB0aGUgZmlyc3QgdHdvIHBhc3NlcywgdGhlbiAzIHRoZW4gMS5cbiAgICBpZiAoZnJhbWUuaW50ZXJsYWNlZCA9PT0gdHJ1ZSkge1xuICAgICAgc2NhbnN0cmlkZSArPSB3aWR0aCAqIDQgKiA3OyAgLy8gUGFzcyAxLlxuICAgIH1cblxuICAgIHZhciBpbnRlcmxhY2Vza2lwID0gODsgIC8vIFRyYWNraW5nIHRoZSByb3cgaW50ZXJ2YWwgaW4gdGhlIGN1cnJlbnQgcGFzcy5cblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleF9zdHJlYW1baV07XG5cbiAgICAgIGlmICh4bGVmdCA9PT0gMCkgeyAgLy8gQmVnaW5uaW5nIG9mIG5ldyBzY2FuIGxpbmVcbiAgICAgICAgb3AgKz0gc2NhbnN0cmlkZTtcbiAgICAgICAgeGxlZnQgPSBmcmFtZXdpZHRoO1xuICAgICAgICBpZiAob3AgPj0gb3BlbmQpIHsgLy8gQ2F0Y2ggdGhlIHdyYXAgdG8gc3dpdGNoIHBhc3NlcyB3aGVuIGludGVybGFjaW5nLlxuICAgICAgICAgIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQgKyB3aWR0aCAqIDQgKiAoaW50ZXJsYWNlc2tpcC0xKTtcbiAgICAgICAgICAvLyBpbnRlcmxhY2Vza2lwIC8gMiAqIDQgaXMgaW50ZXJsYWNlc2tpcCA8PCAxLlxuICAgICAgICAgIG9wID0gb3BiZWcgKyAoZnJhbWV3aWR0aCArIGZyYW1lc3RyaWRlKSAqIChpbnRlcmxhY2Vza2lwIDw8IDEpO1xuICAgICAgICAgIGludGVybGFjZXNraXAgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSB0cmFucykge1xuICAgICAgICBvcCArPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDNdO1xuICAgICAgICB2YXIgZyA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDFdO1xuICAgICAgICB2YXIgYiA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDJdO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSByO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBnO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBiO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSAyNTU7XG4gICAgICB9XG4gICAgICAtLXhsZWZ0O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oY29kZV9zdHJlYW0sIHAsIG91dHB1dCwgb3V0cHV0X2xlbmd0aCkge1xuICB2YXIgbWluX2NvZGVfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107XG5cbiAgdmFyIGNsZWFyX2NvZGUgPSAxIDw8IG1pbl9jb2RlX3NpemU7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgLy8gTk9URTogVGhpcyBzaGFyZXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgZW5jb2RlciwgYnV0IGhhcyBhIGRpZmZlcmVudFxuICAvLyBtZWFuaW5nIGhlcmUuICBIZXJlIHRoaXMgbWFza3MgZWFjaCBjb2RlIGNvbWluZyBmcm9tIHRoZSBjb2RlIHN0cmVhbS5cbiAgdmFyIGNvZGVfbWFzayA9ICgxIDw8IGN1cl9jb2RlX3NpemUpIC0gMTtcbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIHZhciBjdXIgPSAwO1xuXG4gIHZhciBvcCA9IDA7ICAvLyBPdXRwdXQgcG9pbnRlci5cblxuICB2YXIgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107XG5cbiAgLy8gVE9ETyhkZWFubSk6IFdvdWxkIHVzaW5nIGEgVHlwZWRBcnJheSBiZSBhbnkgZmFzdGVyPyAgQXQgbGVhc3QgaXQgd291bGRcbiAgLy8gc29sdmUgdGhlIGZhc3QgbW9kZSAvIGJhY2tpbmcgc3RvcmUgdW5jZXJ0YWludHkuXG4gIC8vIHZhciBjb2RlX3RhYmxlID0gQXJyYXkoNDA5Nik7XG4gIHZhciBjb2RlX3RhYmxlID0gbmV3IEludDMyQXJyYXkoNDA5Nik7ICAvLyBDYW4gYmUgc2lnbmVkLCB3ZSBvbmx5IHVzZSAyMCBiaXRzLlxuXG4gIHZhciBwcmV2X2NvZGUgPSBudWxsOyAgLy8gVHJhY2sgY29kZS0xLlxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gUmVhZCB1cCB0byB0d28gYnl0ZXMsIG1ha2luZyBzdXJlIHdlIGFsd2F5cyAxMi1iaXRzIGZvciBtYXggc2l6ZWQgY29kZS5cbiAgICB3aGlsZSAoY3VyX3NoaWZ0IDwgMTYpIHtcbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIE5vIG1vcmUgZGF0YSB0byBiZSByZWFkLlxuXG4gICAgICBjdXIgfD0gY29kZV9zdHJlYW1bcCsrXSA8PCBjdXJfc2hpZnQ7XG4gICAgICBjdXJfc2hpZnQgKz0gODtcblxuICAgICAgaWYgKHN1YmJsb2NrX3NpemUgPT09IDEpIHsgIC8vIE5ldmVyIGxldCBpdCBnZXQgdG8gMCB0byBob2xkIGxvZ2ljIGFib3ZlLlxuICAgICAgICBzdWJibG9ja19zaXplID0gY29kZV9zdHJlYW1bcCsrXTsgIC8vIE5leHQgc3ViYmxvY2suXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAtLXN1YmJsb2NrX3NpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyhkZWFubSk6IFdlIHNob3VsZCBuZXZlciByZWFsbHkgZ2V0IGhlcmUsIHdlIHNob3VsZCBoYXZlIHJlY2VpdmVkXG4gICAgLy8gYW5kIEVPSS5cbiAgICBpZiAoY3VyX3NoaWZ0IDwgY3VyX2NvZGVfc2l6ZSlcbiAgICAgIGJyZWFrO1xuXG4gICAgdmFyIGNvZGUgPSBjdXIgJiBjb2RlX21hc2s7XG4gICAgY3VyID4+PSBjdXJfY29kZV9zaXplO1xuICAgIGN1cl9zaGlmdCAtPSBjdXJfY29kZV9zaXplO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IE1heWJlIHNob3VsZCBjaGVjayB0aGF0IHRoZSBmaXJzdCBjb2RlIHdhcyBhIGNsZWFyIGNvZGUsXG4gICAgLy8gYXQgbGVhc3QgdGhpcyBpcyB3aGF0IHlvdSdyZSBzdXBwb3NlZCB0byBkby4gIEJ1dCBhY3R1YWxseSBvdXIgZW5jb2RlclxuICAgIC8vIG5vdyBkb2Vzbid0IGVtaXQgYSBjbGVhciBjb2RlIGZpcnN0IGFueXdheS5cbiAgICBpZiAoY29kZSA9PT0gY2xlYXJfY29kZSkge1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSB0byBjbGVhciB0aGUgdGFibGUuICBUaGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhXG4gICAgICAvLyBmb3IgZ3JlYXRlciBlcnJvciBjaGVja2luZywgYnV0IHdlIGRvbid0IHJlYWxseSBkbyBhbnkgYW55d2F5LiAgV2VcbiAgICAgIC8vIHdpbGwganVzdCB0cmFjayBpdCB3aXRoIG5leHRfY29kZSBhbmQgb3ZlcndyaXRlIG9sZCBlbnRyaWVzLlxuXG4gICAgICBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG4gICAgICBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7XG4gICAgICBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG5cbiAgICAgIC8vIERvbid0IHVwZGF0ZSBwcmV2X2NvZGUgP1xuICAgICAgcHJldl9jb2RlID0gbnVsbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gZW9pX2NvZGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYSBzaW1pbGFyIHNpdHVhdGlvbiBhcyB0aGUgZGVjb2Rlciwgd2hlcmUgd2Ugd2FudCB0byBzdG9yZVxuICAgIC8vIHZhcmlhYmxlIGxlbmd0aCBlbnRyaWVzIChjb2RlIHRhYmxlIGVudHJpZXMpLCBidXQgd2Ugd2FudCB0byBkbyBpbiBhXG4gICAgLy8gZmFzdGVyIG1hbm5lciB0aGFuIGFuIGFycmF5IG9mIGFycmF5cy4gIFRoZSBjb2RlIGJlbG93IHN0b3JlcyBzb3J0IG9mIGFcbiAgICAvLyBsaW5rZWQgbGlzdCB3aXRoaW4gdGhlIGNvZGUgdGFibGUsIGFuZCB0aGVuIFwiY2hhc2VzXCIgdGhyb3VnaCBpdCB0b1xuICAgIC8vIGNvbnN0cnVjdCB0aGUgZGljdGlvbmFyeSBlbnRyaWVzLiAgV2hlbiBhIG5ldyBlbnRyeSBpcyBjcmVhdGVkLCBqdXN0IHRoZVxuICAgIC8vIGxhc3QgYnl0ZSBpcyBzdG9yZWQsIGFuZCB0aGUgcmVzdCAocHJlZml4KSBvZiB0aGUgZW50cnkgaXMgb25seVxuICAgIC8vIHJlZmVyZW5jZWQgYnkgaXRzIHRhYmxlIGVudHJ5LiAgVGhlbiB0aGUgY29kZSBjaGFzZXMgdGhyb3VnaCB0aGVcbiAgICAvLyBwcmVmaXhlcyB1bnRpbCBpdCByZWFjaGVzIGEgc2luZ2xlIGJ5dGUgY29kZS4gIFdlIGhhdmUgdG8gY2hhc2UgdHdpY2UsXG4gICAgLy8gZmlyc3QgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoLCBhbmQgdGhlbiB0byBhY3R1YWxseSBjb3B5IHRoZSBkYXRhIHRvIHRoZVxuICAgIC8vIG91dHB1dCAoYmFja3dhcmRzLCBzaW5jZSB3ZSBrbm93IHRoZSBsZW5ndGgpLiAgVGhlIGFsdGVybmF0aXZlIHdvdWxkIGJlXG4gICAgLy8gc3RvcmluZyBzb21ldGhpbmcgaW4gYW4gaW50ZXJtZWRpYXRlIHN0YWNrLCBidXQgdGhhdCBkb2Vzbid0IG1ha2UgYW55XG4gICAgLy8gbW9yZSBzZW5zZS4gIEkgaW1wbGVtZW50ZWQgYW4gYXBwcm9hY2ggd2hlcmUgaXQgYWxzbyBzdG9yZWQgdGhlIGxlbmd0aFxuICAgIC8vIGluIHRoZSBjb2RlIHRhYmxlLCBhbHRob3VnaCBpdCdzIGEgYml0IHRyaWNreSBiZWNhdXNlIHlvdSBydW4gb3V0IG9mXG4gICAgLy8gYml0cyAoMTIgKyAxMiArIDgpLCBidXQgSSBkaWRuJ3QgbWVhc3VyZSBtdWNoIGltcHJvdmVtZW50cyAodGhlIHRhYmxlXG4gICAgLy8gZW50cmllcyBhcmUgZ2VuZXJhbGx5IG5vdCB0aGUgbG9uZykuICBFdmVuIHdoZW4gSSBjcmVhdGVkIGJlbmNobWFya3MgZm9yXG4gICAgLy8gdmVyeSBsb25nIHRhYmxlIGVudHJpZXMgdGhlIGNvbXBsZXhpdHkgZGlkIG5vdCBzZWVtIHdvcnRoIGl0LlxuICAgIC8vIFRoZSBjb2RlIHRhYmxlIHN0b3JlcyB0aGUgcHJlZml4IGVudHJ5IGluIDEyIGJpdHMgYW5kIHRoZW4gdGhlIHN1ZmZpeFxuICAgIC8vIGJ5dGUgaW4gOCBiaXRzLCBzbyBlYWNoIGVudHJ5IGlzIDIwIGJpdHMuXG5cbiAgICB2YXIgY2hhc2VfY29kZSA9IGNvZGUgPCBuZXh0X2NvZGUgPyBjb2RlIDogcHJldl9jb2RlO1xuXG4gICAgLy8gQ2hhc2Ugd2hhdCB3ZSB3aWxsIG91dHB1dCwgZWl0aGVyIHtDT0RFfSBvciB7Q09ERS0xfS5cbiAgICB2YXIgY2hhc2VfbGVuZ3RoID0gMDtcbiAgICB2YXIgY2hhc2UgPSBjaGFzZV9jb2RlO1xuICAgIHdoaWxlIChjaGFzZSA+IGNsZWFyX2NvZGUpIHtcbiAgICAgIGNoYXNlID0gY29kZV90YWJsZVtjaGFzZV0gPj4gODtcbiAgICAgICsrY2hhc2VfbGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBrID0gY2hhc2U7XG5cbiAgICB2YXIgb3BfZW5kID0gb3AgKyBjaGFzZV9sZW5ndGggKyAoY2hhc2VfY29kZSAhPT0gY29kZSA/IDEgOiAwKTtcbiAgICBpZiAob3BfZW5kID4gb3V0cHV0X2xlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nLCBnaWYgc3RyZWFtIGxvbmdlciB0aGFuIGV4cGVjdGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbHJlYWR5IGhhdmUgdGhlIGZpcnN0IGJ5dGUgZnJvbSB0aGUgY2hhc2UsIG1pZ2h0IGFzIHdlbGwgd3JpdGUgaXQgZmFzdC5cbiAgICBvdXRwdXRbb3ArK10gPSBrO1xuXG4gICAgb3AgKz0gY2hhc2VfbGVuZ3RoO1xuICAgIHZhciBiID0gb3A7ICAvLyBUcmFjayBwb2ludGVyLCB3cml0aW5nIGJhY2t3YXJkcy5cblxuICAgIGlmIChjaGFzZV9jb2RlICE9PSBjb2RlKSAgLy8gVGhlIGNhc2Ugb2YgZW1pdHRpbmcge0NPREUtMX0gKyBrLlxuICAgICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2VfbGVuZ3RoLS0pIHtcbiAgICAgIGNoYXNlID0gY29kZV90YWJsZVtjaGFzZV07XG4gICAgICBvdXRwdXRbLS1iXSA9IGNoYXNlICYgMHhmZjsgIC8vIFdyaXRlIGJhY2t3YXJkcy5cbiAgICAgIGNoYXNlID4+PSA4OyAgLy8gUHVsbCBkb3duIHRvIHRoZSBwcmVmaXggY29kZS5cbiAgICB9XG5cbiAgICBpZiAocHJldl9jb2RlICE9PSBudWxsICYmIG5leHRfY29kZSA8IDQwOTYpIHtcbiAgICAgIGNvZGVfdGFibGVbbmV4dF9jb2RlKytdID0gcHJldl9jb2RlIDw8IDggfCBrO1xuICAgICAgLy8gVE9ETyhkZWFubSk6IEZpZ3VyZSBvdXQgdGhpcyBjbGVhcmluZyB2cyBjb2RlIGdyb3d0aCBsb2dpYyBiZXR0ZXIuICBJXG4gICAgICAvLyBoYXZlIGFuIGZlZWxpbmcgdGhhdCBpdCBzaG91bGQganVzdCBoYXBwZW4gc29tZXdoZXJlIGVsc2UsIGZvciBub3cgaXRcbiAgICAgIC8vIGlzIGF3a3dhcmQgYmV0d2VlbiB3aGVuIHdlIGdyb3cgcGFzdCB0aGUgbWF4IGFuZCB0aGVuIGhpdCBhIGNsZWFyIGNvZGUuXG4gICAgICAvLyBGb3Igbm93IGp1c3QgY2hlY2sgaWYgd2UgaGl0IHRoZSBtYXggMTItYml0cyAodGhlbiBhIGNsZWFyIGNvZGUgc2hvdWxkXG4gICAgICAvLyBmb2xsb3csIGFsc28gb2YgY291cnNlIGVuY29kZWQgaW4gMTItYml0cykuXG4gICAgICBpZiAobmV4dF9jb2RlID49IGNvZGVfbWFzaysxICYmIGN1cl9jb2RlX3NpemUgPCAxMikge1xuICAgICAgICArK2N1cl9jb2RlX3NpemU7XG4gICAgICAgIGNvZGVfbWFzayA9IGNvZGVfbWFzayA8PCAxIHwgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2X2NvZGUgPSBjb2RlO1xuICB9XG5cbiAgaWYgKG9wICE9PSBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgY29uc29sZS5sb2coXCJXYXJuaW5nLCBnaWYgc3RyZWFtIHNob3J0ZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBDb21tb25KUy5cbnRyeSB7IGV4cG9ydHMuR2lmV3JpdGVyID0gR2lmV3JpdGVyOyBleHBvcnRzLkdpZlJlYWRlciA9IEdpZlJlYWRlciB9IGNhdGNoKGUpIHt9XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgZG9fY29udmVydCA9IHJlcXVpcmUoXCIuL2RvQ29udmVydC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnZlcnQoYXJyLCByZXN1bHQpIHtcbiAgdmFyIHNoYXBlID0gW10sIGMgPSBhcnIsIHN6ID0gMVxuICB3aGlsZShBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgc2hhcGUucHVzaChjLmxlbmd0aClcbiAgICBzeiAqPSBjLmxlbmd0aFxuICAgIGMgPSBjWzBdXG4gIH1cbiAgaWYoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5kYXJyYXkoKVxuICB9XG4gIGlmKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBuZGFycmF5KG5ldyBGbG9hdDY0QXJyYXkoc3opLCBzaGFwZSlcbiAgfVxuICBkb19jb252ZXJ0KHJlc3VsdCwgYXJyKVxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKCdjd2lzZS1jb21waWxlcicpKHtcImFyZ3NcIjpbXCJhcnJheVwiLFwic2NhbGFyXCIsXCJpbmRleFwiXSxcInByZVwiOntcImJvZHlcIjpcInt9XCIsXCJhcmdzXCI6W10sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W119LFwiYm9keVwiOntcImJvZHlcIjpcIntcXG52YXIgX2lubGluZV8xX3Y9X2lubGluZV8xX2FyZzFfLF9pbmxpbmVfMV9pXFxuZm9yKF9pbmxpbmVfMV9pPTA7X2lubGluZV8xX2k8X2lubGluZV8xX2FyZzJfLmxlbmd0aC0xOysrX2lubGluZV8xX2kpIHtcXG5faW5saW5lXzFfdj1faW5saW5lXzFfdltfaW5saW5lXzFfYXJnMl9bX2lubGluZV8xX2ldXVxcbn1cXG5faW5saW5lXzFfYXJnMF89X2lubGluZV8xX3ZbX2lubGluZV8xX2FyZzJfW19pbmxpbmVfMV9hcmcyXy5sZW5ndGgtMV1dXFxufVwiLFwiYXJnc1wiOlt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOnRydWUsXCJydmFsdWVcIjpmYWxzZSxcImNvdW50XCI6MX0se1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzFfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjF9LHtcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcyX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjo0fV0sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W1wiX2lubGluZV8xX2lcIixcIl9pbmxpbmVfMV92XCJdfSxcInBvc3RcIjp7XCJib2R5XCI6XCJ7fVwiLFwiYXJnc1wiOltdLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltdfSxcImZ1bmNOYW1lXCI6XCJjb252ZXJ0XCIsXCJibG9ja1NpemVcIjo2NH0pXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgY3JlYXRlVGh1bmsgPSByZXF1aXJlKFwiLi9saWIvdGh1bmsuanNcIilcblxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xuICB0aGlzLmFyZ1R5cGVzID0gW11cbiAgdGhpcy5zaGltQXJncyA9IFtdXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cbiAgdGhpcy5hcnJheUJsb2NrSW5kaWNlcyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiIHx8ICh0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUuYmxvY2tJbmRpY2VzKSkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwiYXJyYXlcIlxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGFyZ190eXBlLmJsb2NrSW5kaWNlcyA/IGFyZ190eXBlLmJsb2NrSW5kaWNlcyA6IDApXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiIsIlwidXNlIHN0cmljdFwiXG5cbi8vIFRoZSBmdW5jdGlvbiBiZWxvdyBpcyBjYWxsZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBjd2lzZSBmdW5jdGlvbiBvYmplY3QsIGFuZCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4vLyBBIGZ1bmN0aW9uIG9iamVjdCBpcyBjb25zdHJ1Y3RlZCB3aGljaCBhY2NlcHRzIGFzIGFyZ3VtZW50IGEgY29tcGlsYXRpb24gZnVuY3Rpb24gYW5kIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbi5cbi8vIEl0IGlzIHRoaXMgb3RoZXIgZnVuY3Rpb24gdGhhdCBpcyBldmVudHVhbGx5IHJldHVybmVkIGJ5IGNyZWF0ZVRodW5rLCBhbmQgdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25lIHRoYXQgYWN0dWFsbHlcbi8vIGNoZWNrcyB3aGV0aGVyIGEgY2VydGFpbiBwYXR0ZXJuIG9mIGFyZ3VtZW50cyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgYmVmb3JlIGFuZCBjb21waWxlcyBuZXcgbG9vcHMgYXMgbmVlZGVkLlxuLy8gVGhlIGNvbXBpbGF0aW9uIHBhc3NlZCB0byB0aGUgZmlyc3QgZnVuY3Rpb24gb2JqZWN0IGlzIHVzZWQgZm9yIGNvbXBpbGluZyBuZXcgZnVuY3Rpb25zLlxuLy8gT25jZSB0aGlzIGZ1bmN0aW9uIG9iamVjdCBpcyBjcmVhdGVkLCBpdCBpcyBjYWxsZWQgd2l0aCBjb21waWxlIGFzIGFyZ3VtZW50LCB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgb2YgY29tcGlsZVxuLy8gaXMgYm91bmQgdG8gXCJwcm9jXCIgKGVzc2VudGlhbGx5IGNvbnRhaW5pbmcgYSBwcmVwcm9jZXNzZWQgdmVyc2lvbiBvZiB0aGUgdXNlciBhcmd1bWVudHMgdG8gY3dpc2UpLlxuLy8gU28gY3JlYXRlVGh1bmsgcm91Z2hseSB3b3JrcyBsaWtlIHRoaXM6XG4vLyBmdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4vLyAgIHZhciB0aHVuayA9IGZ1bmN0aW9uKGNvbXBpbGVCb3VuZCkge1xuLy8gICAgIHZhciBDQUNIRUQgPSB7fVxuLy8gICAgIHJldHVybiBmdW5jdGlvbihhcnJheXMgYW5kIHNjYWxhcnMpIHtcbi8vICAgICAgIGlmIChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzIGluIENBQ0hFRCkge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c10gPSBjb21waWxlQm91bmQoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cylcbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiBmdW5jKGFycmF5cyBhbmQgc2NhbGFycylcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZDEocHJvYykpXG4vLyB9XG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vY29tcGlsZS5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCIsIFwidmFyIENBQ0hFRD17fVwiXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciB0aHVua05hbWUgPSBwcm9jLmZ1bmNOYW1lICsgXCJfY3dpc2VfdGh1bmtcIlxuICBcbiAgLy9CdWlsZCB0aHVua1xuICBjb2RlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLCB0aHVua05hbWUsIFwiKFwiLCBwcm9jLnNoaW1BcmdzLmpvaW4oXCIsXCIpLCBcIil7XCJdLmpvaW4oXCJcIikpXG4gIHZhciB0eXBlc2lnID0gW11cbiAgdmFyIHN0cmluZ190eXBlc2lnID0gW11cbiAgdmFyIHByb2NfYXJncyA9IFtbXCJhcnJheVwiLHByb2MuYXJyYXlBcmdzWzBdLFwiLnNoYXBlLnNsaWNlKFwiLCAvLyBTbGljZSBzaGFwZSBzbyB0aGF0IHdlIG9ubHkgcmV0YWluIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgKHdoaWNoIGdldHMgcGFzc2VkIHRvIHRoZSBjd2lzZSBvcGVyYXRvciBhcyBTUykuXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXTwwPyhcIixcIitwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdK1wiKVwiKTpcIilcIl0uam9pbihcIlwiKV1cbiAgdmFyIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucyA9IFtdLCBzaGFwZUNvbmRpdGlvbnMgPSBbXVxuICAvLyBQcm9jZXNzIGFycmF5IGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBqID0gcHJvYy5hcnJheUFyZ3NbaV1cbiAgICB2YXJzLnB1c2goW1widFwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5kdHlwZSxcIixcbiAgICAgICAgICAgICAgIFwiclwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5vcmRlclwiXS5qb2luKFwiXCIpKVxuICAgIHR5cGVzaWcucHVzaChcInRcIiArIGopXG4gICAgdHlwZXNpZy5wdXNoKFwiclwiICsgailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwidFwiK2opXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInJcIitqK1wiLmpvaW4oKVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5kYXRhXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLnN0cmlkZVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5vZmZzZXR8MFwiKVxuICAgIGlmIChpPjApIHsgLy8gR2F0aGVyIGNvbmRpdGlvbnMgdG8gY2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5IChpZ25vcmluZyBibG9jayBpbmRpY2VzKVxuICAgICAgc2hhcGVMZW5ndGhDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGg9PT1hcnJheVwiICsgaiArIFwiLnNoYXBlLmxlbmd0aCtcIiArIChNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKS1NYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSkpXG4gICAgICBzaGFwZUNvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCJdPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSArIFwiXVwiKVxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3Igc2hhcGUgZXF1YWxpdHlcbiAgaWYgKHByb2MuYXJyYXlBcmdzLmxlbmd0aCA+IDEpIHtcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25hbGl0eSEnKVwiKVxuICAgIGNvZGUucHVzaChcImZvcih2YXIgc2hhcGVJbmRleD1hcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGgtXCIgKyBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiOyBzaGFwZUluZGV4LS0+MDspIHtcIilcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBzaGFwZSEnKVwiKVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICAvLyBQcm9jZXNzIHNjYWxhciBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJvY19hcmdzLnB1c2goXCJzY2FsYXJcIiArIHByb2Muc2NhbGFyQXJnc1tpXSlcbiAgfVxuICAvLyBDaGVjayBmb3IgY2FjaGVkIGZ1bmN0aW9uIChhbmQgaWYgbm90IHByZXNlbnQsIGdlbmVyYXRlIGl0KVxuICB2YXJzLnB1c2goW1widHlwZT1bXCIsIHN0cmluZ190eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0uam9pbigpXCJdLmpvaW4oXCJcIikpXG4gIHZhcnMucHVzaChcInByb2M9Q0FDSEVEW3R5cGVdXCIpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIFxuICBjb2RlLnB1c2goW1wiaWYoIXByb2Mpe1wiLFxuICAgICAgICAgICAgIFwiQ0FDSEVEW3R5cGVdPXByb2M9Y29tcGlsZShbXCIsIHR5cGVzaWcuam9pbihcIixcIiksIFwiXSl9XCIsXG4gICAgICAgICAgICAgXCJyZXR1cm4gcHJvYyhcIiwgcHJvY19hcmdzLmpvaW4oXCIsXCIpLCBcIil9XCJdLmpvaW4oXCJcIikpXG5cbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgdGh1bms6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcbiAgfVxuICBcbiAgLy9Db21waWxlIHRodW5rXG4gIHZhciB0aHVuayA9IG5ldyBGdW5jdGlvbihcImNvbXBpbGVcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kKHVuZGVmaW5lZCwgcHJvYykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGh1bmtcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcblxuLy8gVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdmVyeSBzaW1wbGUgbG9vcHMgYW5hbG9nb3VzIHRvIGhvdyB5b3UgdHlwaWNhbGx5IHRyYXZlcnNlIGFycmF5cyAodGhlIG91dGVybW9zdCBsb29wIGNvcnJlc3BvbmRzIHRvIHRoZSBzbG93ZXN0IGNoYW5naW5nIGluZGV4LCB0aGUgaW5uZXJtb3N0IGxvb3AgdG8gdGhlIGZhc3Rlc3QgY2hhbmdpbmcgaW5kZXgpXG4vLyBUT0RPOiBJZiB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgc3RyaWRlcyAoYW5kIG9mZnNldHMpIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZGVjcmVhc2luZyB0aGUgbnVtYmVyIG9mIFwicG9pbnRlcnNcIiBhbmQgcmVsYXRlZCB2YXJpYWJsZXMuIFRoZSBkcmF3YmFjayBpcyB0aGF0IHRoZSB0eXBlIHNpZ25hdHVyZSB3b3VsZCBiZWNvbWUgbW9yZSBzcGVjaWZpYyBhbmQgdGhhdCB0aGVyZSB3b3VsZCB0aHVzIGJlIGxlc3MgcG90ZW50aWFsIGZvciBjYWNoaW5nLCBidXQgaXQgbWlnaHQgc3RpbGwgYmUgd29ydGggaXQsIGVzcGVjaWFsbHkgd2hlbiBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBhcmd1bWVudHMuXG5mdW5jdGlvbiBpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aD4wXG4gICAgLCBjb2RlID0gW11cbiAgICAsIHZhcnMgPSBbXVxuICAgICwgaWR4PTAsIHBpZHg9MCwgaSwgalxuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7IC8vIEl0ZXJhdGlvbiB2YXJpYWJsZXNcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkgeyAvLyBUaGUgaW5uZXJtb3N0L2Zhc3Rlc3QgZGltZW5zaW9uJ3MgZGVsdGEgaXMgc2ltcGx5IGl0cyBzdHJpZGVcbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9dFwiLGosXCJwXCIsaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfSBlbHNlIHsgLy8gRm9yIG90aGVyIGRpbWVuc2lvbnMgdGhlIGRlbHRhIGlzIGJhc2ljYWxseSB0aGUgc3RyaWRlIG1pbnVzIHNvbWV0aGluZyB3aGljaCBlc3NlbnRpYWxseSBcInJld2luZHNcIiB0aGUgcHJldmlvdXMgKG1vcmUgaW5uZXIpIGRpbWVuc2lvblxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJwXCIsaWR4LFwiLXNcIixwaWR4LFwiKnRcIixqLFwicFwiLHBpZHgsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9ICBcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkgeyAvLyBTdGFydCBhdCBsYXJnZXN0IHN0cmlkZSBhbmQgd29yayB5b3VyIHdheSBpbndhcmRzXG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBjb2RlLnB1c2goW1wiZm9yKGlcIixpLFwiPTA7aVwiLGksXCI8c1wiLGlkeCxcIjsrK2lcIixpLFwiKXtcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL1B1c2ggYm9keSBvZiBpbm5lciBsb29wXG4gIGNvZGUucHVzaChib2R5KVxuICAvL0FkdmFuY2Ugc2NhbiBwb2ludGVyc1xuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgcGlkeCA9IGlkeFxuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2goW1wicFwiLGosXCIrPWRcIixqLFwic1wiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgaWYoaSA+IDApIHtcbiAgICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLHBpZHgsXCJdLT1zXCIscGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChbXCIrK2luZGV4W1wiLGlkeCxcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy8gR2VuZXJhdGUgXCJvdXRlclwiIGxvb3BzIHRoYXQgbG9vcCBvdmVyIGJsb2NrcyBvZiBkYXRhLCBhcHBseWluZyBcImlubmVyXCIgbG9vcHMgdG8gdGhlIGJsb2NrcyBieSBtYW5pcHVsYXRpbmcgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGlubmVyIGxvb3Agb25seSBcInNlZXNcIiB0aGUgY3VycmVudCBibG9jay5cbi8vIFRPRE86IElmIHRoaXMgaXMgdXNlZCwgdGhlbiB0aGUgcHJldmlvdXMgZGVjbGFyYXRpb24gKGRvbmUgYnkgZ2VuZXJhdGVDd2lzZU9wKSBvZiBzKiBpcyBlc3NlbnRpYWxseSB1bm5lY2Vzc2FyeS5cbi8vICAgICAgIEkgYmVsaWV2ZSB0aGUgcyogYXJlIG5vdCB1c2VkIGVsc2V3aGVyZSAoaW4gcGFydGljdWxhciwgSSBkb24ndCB0aGluayB0aGV5J3JlIHVzZWQgaW4gdGhlIHByZS9wb3N0IHBhcnRzIGFuZCBcInNoYXBlXCIgaXMgZGVmaW5lZCBpbmRlcGVuZGVudGx5KSwgc28gaXQgd291bGQgYmUgcG9zc2libGUgdG8gbWFrZSBkZWZpbmluZyB0aGUgcyogZGVwZW5kZW50IG9uIHdoYXQgbG9vcCBtZXRob2QgaXMgYmVpbmcgdXNlZC5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbG9vcHMgZm9yIHVubWF0Y2hlZCBkaW1lbnNpb25zXG4gIC8vIFRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBkaW1lbnNpb25zIGFyZSB0cmF2ZXJzZWQgaXMgZmFpcmx5IGFyYml0cmFyeSAoZnJvbSBzbWFsbCBzdHJpZGUgdG8gbGFyZ2Ugc3RyaWRlLCBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50KVxuICAvLyBUT0RPOiBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBsb29wcyBhcmUgcGxhY2VkIHdvdWxkIGFsc28gYmUgc29tZWhvdyBcIm9wdGltYWxcIiAoYXQgdGhlIHZlcnkgbGVhc3Qgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaXQgcmVhbGx5IGRvZXNuJ3QgaHVydCB1cyBpZiB0aGV5J3JlIG5vdCkuXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcImZvcih2YXIgalwiK2krXCI9U1NbXCIsIG9yZGVyW2ldLCBcIl18MDtqXCIsIGksIFwiPjA7KXtcIl0uam9pbihcIlwiKSkgLy8gSXRlcmF0ZSBiYWNrIHRvIGZyb250XG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpIC8vIEVpdGhlciBkZWNyZWFzZSBqIGJ5IGJsb2NrU2l6ZSAocyA9IGJsb2NrU2l6ZSksIG9yIHNldCBpdCB0byB6ZXJvIChhZnRlciBzZXR0aW5nIHMgPSBqKS5cbiAgICBjb2RlLnB1c2goW1wic1wiLG9yZGVyW2ldLFwiPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcIn1lbHNle3NcIixvcmRlcltpXSxcIj1cIixibG9ja1NpemVdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiLT1cIixibG9ja1NpemUsXCJ9XCJdLmpvaW4oXCJcIikpXG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIsb3JkZXJbaV0sXCJdPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgdmFyIGluZGV4U3RyID0gW1wib2Zmc2V0XCIraV1cbiAgICBmb3IodmFyIGo9bWF0Y2hlZDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgaW5kZXhTdHIucHVzaChbXCJqXCIsaixcIip0XCIsaSxcInBcIixvcmRlcltqXV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFtcInBcIixpLFwiPShcIixpbmRleFN0ci5qb2luKFwiK1wiKSxcIilcIl0uam9pbihcIlwiKSlcbiAgfVxuICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSlcbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vL0NvdW50IHRoZSBudW1iZXIgb2YgY29tcGF0aWJsZSBpbm5lciBvcmRlcnNcbi8vIFRoaXMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBjb21tb24gcHJlZml4IG9mIHRoZSBhcnJheXMgaW4gb3JkZXJzLlxuLy8gRWFjaCBhcnJheSBpbiBvcmRlcnMgbGlzdHMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvcnJlc3BvbmQgbmRhcnJheSBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIHN0cmlkZS5cbi8vIFRoaXMgaXMgdGh1cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGltZW5zaW9ucyB0aGF0IGNhbiBiZSBlZmZpY2llbnRseSB0cmF2ZXJzZWQgYnkgc2ltcGxlIG5lc3RlZCBsb29wcyBmb3IgYWxsIGFycmF5cy5cbmZ1bmN0aW9uIGNvdW50TWF0Y2hlcyhvcmRlcnMpIHtcbiAgdmFyIG1hdGNoZWQgPSAwLCBkaW1lbnNpb24gPSBvcmRlcnNbMF0ubGVuZ3RoXG4gIHdoaWxlKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBmb3IodmFyIGo9MTsgajxvcmRlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9yZGVyc1tqXVttYXRjaGVkXSAhPT0gb3JkZXJzWzBdW21hdGNoZWRdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVkXG4gICAgICB9XG4gICAgfVxuICAgICsrbWF0Y2hlZFxuICB9XG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8vUHJvY2Vzc2VzIGEgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBkYXRhIHR5cGVzXG4vLyBSZXBsYWNlcyB2YXJpYWJsZSBuYW1lcyBieSBkaWZmZXJlbnQgb25lcywgZWl0aGVyIFwibG9jYWxcIiBvbmVzICh0aGF0IGFyZSB0aGVuIGZlcnJpZWQgaW4gYW5kIG91dCBvZiB0aGUgZ2l2ZW4gYXJyYXkpIG9yIG9uZXMgbWF0Y2hpbmcgdGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBmdW5jdGlvbiBwZXJmb3JtaW5nIHRoZSB1bHRpbWF0ZSBsb29wIHdpbGwgYWNjZXB0LlxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleCAvLyBBZGRzIG9mZnNldCB0byB0aGUgXCJwb2ludGVyXCIgaW4gdGhlIGFycmF5XG4gICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgcHRyU3RyID0gXCJwXCIgKyBhcnJOdW0gKyBwdHJTdHJcbiAgICAgICAgdmFyIGxvY2FsU3RyID0gXCJsXCIgKyBpXG4gICAgICAgIHZhciBhcnJTdHIgPSBcImFcIiArIGFyck51bVxuICAgICAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dID09PSAwKSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMganVzdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoaXMgYXJyYXlcbiAgICAgICAgICBpZihjYXJnLmNvdW50ID09PSAxKSB7IC8vIEFyZ3VtZW50L2FycmF5IHVzZWQgb25seSBvbmNlKD8pXG4gICAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl09XCIsIGxvY2FsU3RyXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBhIFwiYmxvY2tcIlxuICAgICAgICAgIHZhciByZVN0ckFyciA9IFtjYXJnLm5hbWVdLCBwdHJTdHJBcnIgPSBbcHRyU3RyXVxuICAgICAgICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSk7IGorKykge1xuICAgICAgICAgICAgcmVTdHJBcnIucHVzaChcIlxcXFxzKlxcXFxbKFteXFxcXF1dKylcXFxcXVwiKVxuICAgICAgICAgICAgcHRyU3RyQXJyLnB1c2goXCIkXCIgKyAoaisxKSArIFwiKnRcIiArIGFyck51bSArIFwiYlwiICsgaikgLy8gTWF0Y2hlZCBpbmRleCB0aW1lcyBzdHJpZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKHJlU3RyQXJyLmpvaW4oXCJcIiksIFwiZ1wiKVxuICAgICAgICAgIHB0clN0ciA9IHB0clN0ckFyci5qb2luKFwiK1wiKVxuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgLyppZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IEdlbmVyaWMgYXJyYXlzIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBibG9ja3MhXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgcHJvZHVjZSBhbnkgbG9jYWwgdmFyaWFibGVzLCBldmVuIGlmIHZhcmlhYmxlcyBhcmUgdXNlZCBtdWx0aXBsZSB0aW1lcy4gSXQgd291bGQgYmUgcG9zc2libGUgdG8gZG8gc28sIGJ1dCBpdCB3b3VsZCBjb21wbGljYXRlIHRoaW5ncyBxdWl0ZSBhIGJpdC5cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJZXCIgKyBwcm9jLnNjYWxhckFyZ3MuaW5kZXhPZihpKSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJpbmRleFwiKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzaGFwZVwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcInNoYXBlXCIpXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3ByZS5qb2luKFwiXFxuXCIpLCBjb2RlLCBwb3N0LmpvaW4oXCJcXG5cIildLmpvaW4oXCJcXG5cIikudHJpbSgpXG59XG5cbmZ1bmN0aW9uIHR5cGVTdW1tYXJ5KGR0eXBlcykge1xuICB2YXIgc3VtbWFyeSA9IG5ldyBBcnJheShkdHlwZXMubGVuZ3RoKVxuICB2YXIgYWxsRXF1YWwgPSB0cnVlXG4gIGZvcih2YXIgaT0wOyBpPGR0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB0ID0gZHR5cGVzW2ldXG4gICAgdmFyIGRpZ2l0cyA9IHQubWF0Y2goL1xcZCsvKVxuICAgIGlmKCFkaWdpdHMpIHtcbiAgICAgIGRpZ2l0cyA9IFwiXCJcbiAgICB9IGVsc2Uge1xuICAgICAgZGlnaXRzID0gZGlnaXRzWzBdXG4gICAgfVxuICAgIGlmKHQuY2hhckF0KDApID09PSAwKSB7XG4gICAgICBzdW1tYXJ5W2ldID0gXCJ1XCIgKyB0LmNoYXJBdCgxKSArIGRpZ2l0c1xuICAgIH0gZWxzZSB7XG4gICAgICBzdW1tYXJ5W2ldID0gdC5jaGFyQXQoMCkgKyBkaWdpdHNcbiAgICB9XG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGFsbEVxdWFsID0gYWxsRXF1YWwgJiYgc3VtbWFyeVtpXSA9PT0gc3VtbWFyeVtpLTFdXG4gICAgfVxuICB9XG4gIGlmKGFsbEVxdWFsKSB7XG4gICAgcmV0dXJuIHN1bW1hcnlbMF1cbiAgfVxuICByZXR1cm4gc3VtbWFyeS5qb2luKFwiXCIpXG59XG5cbi8vR2VuZXJhdGVzIGEgY3dpc2Ugb3BlcmF0b3JcbmZ1bmN0aW9uIGdlbmVyYXRlQ1dpc2VPcChwcm9jLCB0eXBlc2lnKSB7XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvblxuICAvLyBBcnJheXMgZ2V0IHB1dCBmaXJzdCBpbiB0eXBlc2lnLCBhbmQgdGhlcmUgYXJlIHR3byBlbnRyaWVzIHBlciBhcnJheSAoZHR5cGUgYW5kIG9yZGVyKSwgc28gdGhpcyBnZXRzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgZmlyc3QgYXJyYXkgYXJnLlxuICB2YXIgZGltZW5zaW9uID0gKHR5cGVzaWdbMV0ubGVuZ3RoIC0gTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkpfDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGR0eXBlc1tpXSA9IHR5cGVzaWdbMippXVxuICAgIG9yZGVyc1tpXSA9IHR5cGVzaWdbMippKzFdXG4gIH1cbiAgXG4gIC8vRGV0ZXJtaW5lIHdoZXJlIGJsb2NrIGFuZCBsb29wIGluZGljZXMgc3RhcnQgYW5kIGVuZFxuICB2YXIgYmxvY2tCZWdpbiA9IFtdLCBibG9ja0VuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGV4cG9zZWQgYXMgYmxvY2tzXG4gIHZhciBsb29wQmVnaW4gPSBbXSwgbG9vcEVuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGl0ZXJhdGVkIG92ZXJcbiAgdmFyIGxvb3BPcmRlcnMgPSBbXSAvLyBvcmRlcnMgcmVzdHJpY3RlZCB0byB0aGUgbG9vcCBpbmRpY2VzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV08MCkge1xuICAgICAgbG9vcEJlZ2luLnB1c2goMClcbiAgICAgIGxvb3BFbmQucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tFbmQucHVzaChkaW1lbnNpb24rcHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9IGVsc2Uge1xuICAgICAgbG9vcEJlZ2luLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgLy8gTm9uLW5lZ2F0aXZlXG4gICAgICBsb29wRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXStkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goMClcbiAgICAgIGJsb2NrRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9XG4gICAgdmFyIG5ld09yZGVyID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvcmRlcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsb29wQmVnaW5baV08PW9yZGVyc1tpXVtqXSAmJiBvcmRlcnNbaV1bal08bG9vcEVuZFtpXSkge1xuICAgICAgICBuZXdPcmRlci5wdXNoKG9yZGVyc1tpXVtqXS1sb29wQmVnaW5baV0pIC8vIElmIHRoaXMgaXMgYSBsb29wIGluZGV4LCBwdXQgaXQgaW4gbmV3T3JkZXIsIHN1YnRyYWN0aW5nIGxvb3BCZWdpbiwgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGxvb3BPcmRlcnMgYXJlIHVzaW5nIGEgY29tbW9uIHNldCBvZiBpbmRpY2VzLlxuICAgICAgfVxuICAgIH1cbiAgICBsb29wT3JkZXJzLnB1c2gobmV3T3JkZXIpXG4gIH1cblxuICAvL0ZpcnN0IGNyZWF0ZSBhcmd1bWVudHMgZm9yIHByb2NlZHVyZVxuICB2YXIgYXJnbGlzdCA9IFtcIlNTXCJdIC8vIFNTIGlzIHRoZSBvdmVyYWxsIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZVxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICB2YXIgdmFycyA9IFtdXG4gIFxuICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgIHZhcnMucHVzaChbXCJzXCIsIGosIFwiPVNTW1wiLCBqLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVGhlIGxpbWl0cyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSkgLy8gQWN0dWFsIGRhdGEgYXJyYXlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSkgLy8gU3RyaWRlc1xuICAgIGFyZ2xpc3QucHVzaChcInBcIitpKSAvLyBPZmZzZXQgaW4gdGhlIGFycmF5IGF0IHdoaWNoIHRoZSBkYXRhIHN0YXJ0cyAoYWxzbyB1c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZGF0YSlcbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBsb29waW5nXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixsb29wQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSk7ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBibG9jayBpdGVyYXRpb25cbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcImJcIixqLFwiPXRcIixpLFwiW1wiLGJsb2NrQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiWVwiICsgaSlcbiAgfVxuICBpZihwcm9jLnNoYXBlQXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFycy5wdXNoKFwic2hhcGU9U1Muc2xpY2UoMClcIikgLy8gTWFrZXMgdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSBhdmFpbGFibGUgdG8gdGhlIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnMgKHNvIHlvdSBjYW4gdXNlIHdpZHRoL2hlaWdodCBmb3IgZXhhbXBsZSlcbiAgfVxuICBpZihwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwKSB7XG4gICAgLy8gUHJlcGFyZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrIG9mIHRoZSAobG9naWNhbCkgaW5kaWNlcywgaW5pdGlhbGl6ZWQgdG8gZGltZW5zaW9uIHplcm9lcy5cbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICB6ZXJvc1tpXSA9IFwiMFwiXG4gICAgfVxuICAgIHZhcnMucHVzaChbXCJpbmRleD1bXCIsIHplcm9zLmpvaW4oXCIsXCIpLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHsgLy8gT2Zmc2V0IGFyZ3VtZW50cyB1c2VkIGZvciBzdGVuY2lsIG9wZXJhdGlvbnNcbiAgICB2YXIgb2ZmX2FyZyA9IHByb2Mub2Zmc2V0QXJnc1tpXVxuICAgIHZhciBpbml0X3N0cmluZyA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbXCJ0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFycy5wdXNoKFwicVwiICsgaSArIFwiPTBcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuXG4gIC8vUHJlcGFyZSB0aGlzIHZhcmlhYmxlc1xuICB2YXIgdGhpc1ZhcnMgPSB1bmlxKFtdLmNvbmNhdChwcm9jLnByZS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MucG9zdC50aGlzVmFycykpXG4gIHZhcnMgPSB2YXJzLmNvbmNhdCh0aGlzVmFycylcbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJwXCIraStcInw9MFwiKVxuICB9XG4gIFxuICAvL0lubGluZSBwcmVsdWRlXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wcmUsIHByb2MsIGR0eXBlcykpXG4gIH1cblxuICAvL1Byb2Nlc3MgYm9keVxuICB2YXIgYm9keSA9IHByb2Nlc3NCbG9jayhwcm9jLmJvZHksIHByb2MsIGR0eXBlcylcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMobG9vcE9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgbG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpIC8vIFRPRE86IFJhdGhlciB0aGFuIHBhc3NpbmcgbG9vcE9yZGVyc1swXSwgaXQgbWlnaHQgYmUgaW50ZXJlc3RpbmcgdG8gbG9vayBhdCBwYXNzaW5nIGFuIG9yZGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgbWFqb3JpdHkgb2YgdGhlIGFyZ3VtZW50cyBmb3IgZXhhbXBsZS5cbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKVxuICB9XG5cbiAgLy9JbmxpbmUgZXBpbG9nXG4gIGlmKHByb2MucG9zdC5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucG9zdCwgcHJvYywgZHR5cGVzKSlcbiAgfVxuICBcbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYj1saXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGNvbXBhcmUoYSwgYikpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZV9lcShsaXN0KSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiID0gbGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSwgYj1hKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGEgIT09IGIpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0LCBjb21wYXJlLCBzb3J0ZWQpIHtcbiAgaWYobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIGlmKGNvbXBhcmUpIHtcbiAgICBpZighc29ydGVkKSB7XG4gICAgICBsaXN0LnNvcnQoY29tcGFyZSlcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpXG4gIH1cbiAgaWYoIXNvcnRlZCkge1xuICAgIGxpc3Quc29ydCgpXG4gIH1cbiAgcmV0dXJuIHVuaXF1ZV9lcShsaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoXG50aHJvdWdoLnRocm91Z2ggPSB0aHJvdWdoXG5cbi8vY3JlYXRlIGEgcmVhZGFibGUgd3JpdGFibGUgc3RyZWFtLlxuXG5mdW5jdGlvbiB0aHJvdWdoICh3cml0ZSwgZW5kLCBvcHRzKSB7XG4gIHdyaXRlID0gd3JpdGUgfHwgZnVuY3Rpb24gKGRhdGEpIHsgdGhpcy5xdWV1ZShkYXRhKSB9XG4gIGVuZCA9IGVuZCB8fCBmdW5jdGlvbiAoKSB7IHRoaXMucXVldWUobnVsbCkgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlLCBkZXN0cm95ZWQgPSBmYWxzZSwgYnVmZmVyID0gW10sIF9lbmRlZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuLy8gIHN0cmVhbS5hdXRvUGF1c2UgICA9ICEob3B0cyAmJiBvcHRzLmF1dG9QYXVzZSAgID09PSBmYWxzZSlcbiAgc3RyZWFtLmF1dG9EZXN0cm95ID0gIShvcHRzICYmIG9wdHMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKVxuXG4gIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgd3JpdGUuY2FsbCh0aGlzLCBkYXRhKVxuICAgIHJldHVybiAhc3RyZWFtLnBhdXNlZFxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgd2hpbGUoYnVmZmVyLmxlbmd0aCAmJiAhc3RyZWFtLnBhdXNlZCkge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2hpZnQoKVxuICAgICAgaWYobnVsbCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgZWxzZVxuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLnF1ZXVlID0gc3RyZWFtLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuLy8gICAgY29uc29sZS5lcnJvcihlbmRlZClcbiAgICBpZihfZW5kZWQpIHJldHVybiBzdHJlYW1cbiAgICBpZihkYXRhID09PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIi8qIChpZ25vcmVkKSAqLyIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGFVcmlUb0J1ZmZlcjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYEJ1ZmZlcmAgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBVUkkgYHVyaWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBEYXRhIFVSSSB0byB0dXJuIGludG8gYSBCdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0J1ZmZlcn0gQnVmZmVyIGluc3RhbmNlIGZyb20gRGF0YSBVUklcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGF0YVVyaVRvQnVmZmVyICh1cmkpIHtcbiAgaWYgKCEvXmRhdGFcXDovaS50ZXN0KHVyaSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgdXJpYCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBEYXRhIFVSSSAobXVzdCBiZWdpbiB3aXRoIFwiZGF0YTpcIiknKTtcbiAgfVxuXG4gIC8vIHN0cmlwIG5ld2xpbmVzXG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKTtcblxuICAvLyBzcGxpdCB0aGUgVVJJIHVwIGludG8gdGhlIFwibWV0YWRhdGFcIiBhbmQgdGhlIFwiZGF0YVwiIHBvcnRpb25zXG4gIHZhciBmaXJzdENvbW1hID0gdXJpLmluZGV4T2YoJywnKTtcbiAgaWYgKC0xID09PSBmaXJzdENvbW1hIHx8IGZpcnN0Q29tbWEgPD0gNCkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFsZm9ybWVkIGRhdGE6IFVSSScpO1xuXG4gIC8vIHJlbW92ZSB0aGUgXCJkYXRhOlwiIHNjaGVtZSBhbmQgcGFyc2UgdGhlIG1ldGFkYXRhXG4gIHZhciBtZXRhID0gdXJpLnN1YnN0cmluZyg1LCBmaXJzdENvbW1hKS5zcGxpdCgnOycpO1xuXG4gIHZhciBiYXNlNjQgPSBmYWxzZTtcbiAgdmFyIGNoYXJzZXQgPSAnVVMtQVNDSUknO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoJ2Jhc2U2NCcgPT0gbWV0YVtpXSkge1xuICAgICAgYmFzZTY0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKDAgPT0gbWV0YVtpXS5pbmRleE9mKCdjaGFyc2V0PScpKSB7XG4gICAgICBjaGFyc2V0ID0gbWV0YVtpXS5zdWJzdHJpbmcoOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IHRoZSBlbmNvZGVkIGRhdGEgcG9ydGlvbiBhbmQgZGVjb2RlIFVSSS1lbmNvZGVkIGNoYXJzXG4gIHZhciBkYXRhID0gdW5lc2NhcGUodXJpLnN1YnN0cmluZyhmaXJzdENvbW1hICsgMSkpO1xuXG4gIHZhciBlbmNvZGluZyA9IGJhc2U2NCA/ICdiYXNlNjQnIDogJ2FzY2lpJztcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuXG4gIC8vIHNldCBgLnR5cGVgIHByb3BlcnR5IHRvIE1JTUUgdHlwZVxuICBidWZmZXIudHlwZSA9IG1ldGFbMF0gfHwgJ3RleHQvcGxhaW4nO1xuXG4gIC8vIHNldCB0aGUgYC5jaGFyc2V0YCBwcm9wZXJ0eVxuICBidWZmZXIuY2hhcnNldCA9IGNoYXJzZXQ7XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGludGVycDFkKGFyciwgeCkge1xuICB2YXIgaXggPSBNYXRoLmZsb29yKHgpXG4gICAgLCBmeCA9IHggLSBpeFxuICAgICwgczAgPSAwIDw9IGl4ICAgJiYgaXggICA8IGFyci5zaGFwZVswXVxuICAgICwgczEgPSAwIDw9IGl4KzEgJiYgaXgrMSA8IGFyci5zaGFwZVswXVxuICAgICwgdzAgPSBzMCA/ICthcnIuZ2V0KGl4KSAgIDogMC4wXG4gICAgLCB3MSA9IHMxID8gK2Fyci5nZXQoaXgrMSkgOiAwLjBcbiAgcmV0dXJuICgxLjAtZngpKncwICsgZngqdzFcbn1cblxuZnVuY3Rpb24gaW50ZXJwMmQoYXJyLCB4LCB5KSB7XG4gIHZhciBpeCA9IE1hdGguZmxvb3IoeClcbiAgICAsIGZ4ID0geCAtIGl4XG4gICAgLCBzMCA9IDAgPD0gaXggICAmJiBpeCAgIDwgYXJyLnNoYXBlWzBdXG4gICAgLCBzMSA9IDAgPD0gaXgrMSAmJiBpeCsxIDwgYXJyLnNoYXBlWzBdXG4gICAgLCBpeSA9IE1hdGguZmxvb3IoeSlcbiAgICAsIGZ5ID0geSAtIGl5XG4gICAgLCB0MCA9IDAgPD0gaXkgICAmJiBpeSAgIDwgYXJyLnNoYXBlWzFdXG4gICAgLCB0MSA9IDAgPD0gaXkrMSAmJiBpeSsxIDwgYXJyLnNoYXBlWzFdXG4gICAgLCB3MDAgPSBzMCYmdDAgPyBhcnIuZ2V0KGl4ICAsaXkgICkgOiAwLjBcbiAgICAsIHcwMSA9IHMwJiZ0MSA/IGFyci5nZXQoaXggICxpeSsxKSA6IDAuMFxuICAgICwgdzEwID0gczEmJnQwID8gYXJyLmdldChpeCsxLGl5ICApIDogMC4wXG4gICAgLCB3MTEgPSBzMSYmdDEgPyBhcnIuZ2V0KGl4KzEsaXkrMSkgOiAwLjBcbiAgcmV0dXJuICgxLjAtZnkpICogKCgxLjAtZngpKncwMCArIGZ4KncxMCkgKyBmeSAqICgoMS4wLWZ4KSp3MDEgKyBmeCp3MTEpXG59XG5cbmZ1bmN0aW9uIGludGVycDNkKGFyciwgeCwgeSwgeikge1xuICB2YXIgaXggPSBNYXRoLmZsb29yKHgpXG4gICAgLCBmeCA9IHggLSBpeFxuICAgICwgczAgPSAwIDw9IGl4ICAgJiYgaXggICA8IGFyci5zaGFwZVswXVxuICAgICwgczEgPSAwIDw9IGl4KzEgJiYgaXgrMSA8IGFyci5zaGFwZVswXVxuICAgICwgaXkgPSBNYXRoLmZsb29yKHkpXG4gICAgLCBmeSA9IHkgLSBpeVxuICAgICwgdDAgPSAwIDw9IGl5ICAgJiYgaXkgICA8IGFyci5zaGFwZVsxXVxuICAgICwgdDEgPSAwIDw9IGl5KzEgJiYgaXkrMSA8IGFyci5zaGFwZVsxXVxuICAgICwgaXogPSBNYXRoLmZsb29yKHopXG4gICAgLCBmeiA9IHogLSBpelxuICAgICwgdTAgPSAwIDw9IGl6ICAgJiYgaXogICA8IGFyci5zaGFwZVsyXVxuICAgICwgdTEgPSAwIDw9IGl6KzEgJiYgaXorMSA8IGFyci5zaGFwZVsyXVxuICAgICwgdzAwMCA9IHMwJiZ0MCYmdTAgPyBhcnIuZ2V0KGl4LGl5LGl6KSAgICAgICA6IDAuMFxuICAgICwgdzAxMCA9IHMwJiZ0MSYmdTAgPyBhcnIuZ2V0KGl4LGl5KzEsaXopICAgICA6IDAuMFxuICAgICwgdzEwMCA9IHMxJiZ0MCYmdTAgPyBhcnIuZ2V0KGl4KzEsaXksaXopICAgICA6IDAuMFxuICAgICwgdzExMCA9IHMxJiZ0MSYmdTAgPyBhcnIuZ2V0KGl4KzEsaXkrMSxpeikgICA6IDAuMFxuICAgICwgdzAwMSA9IHMwJiZ0MCYmdTEgPyBhcnIuZ2V0KGl4LGl5LGl6KzEpICAgICA6IDAuMFxuICAgICwgdzAxMSA9IHMwJiZ0MSYmdTEgPyBhcnIuZ2V0KGl4LGl5KzEsaXorMSkgICA6IDAuMFxuICAgICwgdzEwMSA9IHMxJiZ0MCYmdTEgPyBhcnIuZ2V0KGl4KzEsaXksaXorMSkgICA6IDAuMFxuICAgICwgdzExMSA9IHMxJiZ0MSYmdTEgPyBhcnIuZ2V0KGl4KzEsaXkrMSxpeisxKSA6IDAuMFxuICByZXR1cm4gKDEuMC1meikgKiAoKDEuMC1meSkgKiAoKDEuMC1meCkqdzAwMCArIGZ4KncxMDApICsgZnkgKiAoKDEuMC1meCkqdzAxMCArIGZ4KncxMTApKSArIGZ6ICogKCgxLjAtZnkpICogKCgxLjAtZngpKncwMDEgKyBmeCp3MTAxKSArIGZ5ICogKCgxLjAtZngpKncwMTEgKyBmeCp3MTExKSlcbn1cblxuZnVuY3Rpb24gaW50ZXJwTmQoYXJyKSB7XG4gIHZhciBkID0gYXJyLnNoYXBlLmxlbmd0aHwwXG4gICAgLCBpeCA9IG5ldyBBcnJheShkKVxuICAgICwgZnggPSBuZXcgQXJyYXkoZClcbiAgICAsIHMwID0gbmV3IEFycmF5KGQpXG4gICAgLCBzMSA9IG5ldyBBcnJheShkKVxuICAgICwgaSwgdFxuICBmb3IoaT0wOyBpPGQ7ICsraSkge1xuICAgIHQgPSArYXJndW1lbnRzW2krMV1cbiAgICBpeFtpXSA9IE1hdGguZmxvb3IodClcbiAgICBmeFtpXSA9IHQgLSBpeFtpXVxuICAgIHMwW2ldID0gKDAgPD0gaXhbaV0gICAmJiBpeFtpXSAgIDwgYXJyLnNoYXBlW2ldKVxuICAgIHMxW2ldID0gKDAgPD0gaXhbaV0rMSAmJiBpeFtpXSsxIDwgYXJyLnNoYXBlW2ldKVxuICB9XG4gIHZhciByID0gMC4wLCBqLCB3LCBpZHhcbmlfbG9vcDpcbiAgZm9yKGk9MDsgaTwoMTw8ZCk7ICsraSkge1xuICAgIHcgPSAxLjBcbiAgICBpZHggPSBhcnIub2Zmc2V0XG4gICAgZm9yKGo9MDsgajxkOyArK2opIHtcbiAgICAgIGlmKGkgJiAoMTw8aikpIHtcbiAgICAgICAgaWYoIXMxW2pdKSB7XG4gICAgICAgICAgY29udGludWUgaV9sb29wXG4gICAgICAgIH1cbiAgICAgICAgdyAqPSBmeFtqXVxuICAgICAgICBpZHggKz0gYXJyLnN0cmlkZVtqXSAqIChpeFtqXSArIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighczBbal0pIHtcbiAgICAgICAgICBjb250aW51ZSBpX2xvb3BcbiAgICAgICAgfVxuICAgICAgICB3ICo9IDEuMCAtIGZ4W2pdXG4gICAgICAgIGlkeCArPSBhcnIuc3RyaWRlW2pdICogaXhbal1cbiAgICAgIH1cbiAgICB9XG4gICAgciArPSB3ICogYXJyLmRhdGFbaWR4XVxuICB9XG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGFyciwgeCwgeSwgeikge1xuICBzd2l0Y2goYXJyLnNoYXBlLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAwLjBcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gaW50ZXJwMWQoYXJyLCB4KVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBpbnRlcnAyZChhcnIsIHgsIHkpXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGludGVycDNkKGFyciwgeCwgeSwgeilcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGludGVycE5kLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVycG9sYXRlXG5tb2R1bGUuZXhwb3J0cy5kMSA9IGludGVycDFkXG5tb2R1bGUuZXhwb3J0cy5kMiA9IGludGVycDJkXG5tb2R1bGUuZXhwb3J0cy5kMyA9IGludGVycDNkXG4iLCJjb25zdCBCcmVzZW5oYW0gPSB7fTtcblxuY29uc3QgU2xvcGUgPSB7XG4gICAgRElSOiB7XG4gICAgICAgIFVQOiAxLFxuICAgICAgICBET1dOOiAtMSxcbiAgICB9LFxufTtcbi8qKlxuICogU2NhbnMgYSBsaW5lIG9mIHRoZSBnaXZlbiBpbWFnZSBmcm9tIHBvaW50IHAxIHRvIHAyIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nXG4gKiBncmF5LXNjYWxlIHZhbHVlcyAoMC0yNTUpIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVscyBpbiBhZGRpdGlvbiB0byB0aGUgbWluXG4gKiBhbmQgbWF4IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSBUaGUgc3RhcnQgcG9pbnQge3gseX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiBUaGUgZW5kIHBvaW50IHt4LHl9XG4gKiBAcmV0dXJucyB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZSA9IGZ1bmN0aW9uIChpbWFnZVdyYXBwZXIsIHAxLCBwMikge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBsZXQgeDAgPSBwMS54IHwgMDtcbiAgICBsZXQgeTAgPSBwMS55IHwgMDtcbiAgICBsZXQgeDEgPSBwMi54IHwgMDtcbiAgICBsZXQgeTEgPSBwMi55IHwgMDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3Qgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApO1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgeTtcbiAgICBsZXQgdG1wO1xuICAgIGxldCB4O1xuICAgIGNvbnN0IGxpbmUgPSBbXTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHZhbDtcbiAgICBsZXQgbWluID0gMjU1O1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVhZChhLCBiKSB7XG4gICAgICAgIHZhbCA9IGltYWdlRGF0YVtiICogd2lkdGggKyBhXTtcbiAgICAgICAgbWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuICAgICAgICBtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG4gICAgICAgIGxpbmUucHVzaCh2YWwpO1xuICAgIH1cblxuICAgIGlmIChzdGVlcCkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB5MDtcbiAgICAgICAgeTAgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geDE7XG4gICAgICAgIHgxID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBpZiAoeDAgPiB4MSkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgeDEgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geTA7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKHkxIC0geTApO1xuICAgIGVycm9yID0gKGRlbHRhWCAvIDIpIHwgMDtcbiAgICB5ID0geTA7XG4gICAgY29uc3QgeVN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xO1xuICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgICAgIHJlYWQoeSwgeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yIC09IGRlbHRhWTtcbiAgICAgICAgaWYgKGVycm9yIDwgMCkge1xuICAgICAgICAgICAgeSArPSB5U3RlcDtcbiAgICAgICAgICAgIGVycm9yICs9IGRlbHRhWDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4LFxuICAgIH07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSByZXN1bHQgZnJvbSBnZXRCYXJjb2RlTGluZSBpbnRvIGEgYmluYXJ5IHJlcHJlc2VudGF0aW9uXG4gKiBhbHNvIGNvbnNpZGVyaW5nIHRoZSBmcmVxdWVuY3kgYW5kIHNsb3BlIG9mIHRoZSBzaWduYWwgZm9yIG1vcmUgcm9idXN0IHJlc3VsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQge2xpbmUsIG1pbiwgbWF4fVxuICovXG5CcmVzZW5oYW0udG9CaW5hcnlMaW5lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGNvbnN0IHsgbWluIH0gPSByZXN1bHQ7XG4gICAgY29uc3QgeyBtYXggfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IGxpbmUgfSA9IHJlc3VsdDtcbiAgICBsZXQgc2xvcGU7XG4gICAgbGV0IHNsb3BlMjtcbiAgICBjb25zdCBjZW50ZXIgPSBtaW4gKyAobWF4IC0gbWluKSAvIDI7XG4gICAgY29uc3QgZXh0cmVtYSA9IFtdO1xuICAgIGxldCBjdXJyZW50RGlyO1xuICAgIGxldCBkaXI7XG4gICAgbGV0IHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTI7XG4gICAgY29uc3QgclRocmVzaG9sZCA9IC10aHJlc2hvbGQ7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG5cbiAgICAvLyAxLiBmaW5kIGV4dHJlbWFcbiAgICBjdXJyZW50RGlyID0gbGluZVswXSA+IGNlbnRlciA/IFNsb3BlLkRJUi5VUCA6IFNsb3BlLkRJUi5ET1dOO1xuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogMCxcbiAgICAgICAgdmFsOiBsaW5lWzBdLFxuICAgIH0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICBzbG9wZSA9IChsaW5lW2kgKyAxXSAtIGxpbmVbaV0pO1xuICAgICAgICBzbG9wZTIgPSAobGluZVtpICsgMl0gLSBsaW5lW2kgKyAxXSk7XG4gICAgICAgIGlmICgoc2xvcGUgKyBzbG9wZTIpIDwgclRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA8IChjZW50ZXIgKiAxLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuRE9XTjtcbiAgICAgICAgfSBlbHNlIGlmICgoc2xvcGUgKyBzbG9wZTIpID4gdGhyZXNob2xkICYmIGxpbmVbaSArIDFdID4gKGNlbnRlciAqIDAuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5VUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpciA9IGN1cnJlbnREaXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudERpciAhPT0gZGlyKSB7XG4gICAgICAgICAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICB2YWw6IGxpbmVbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSBkaXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiBsaW5lLmxlbmd0aCxcbiAgICAgICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGogPSBleHRyZW1hWzBdLnBvczsgaiA8IGV4dHJlbWFbMV0ucG9zOyBqKyspIHtcbiAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiBjZW50ZXIgPyAwIDogMTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XG4gICAgZm9yIChpID0gMTsgaSA8IGV4dHJlbWEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChleHRyZW1hW2kgKyAxXS52YWwgPiBleHRyZW1hW2ldLnZhbCkge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaV0udmFsICsgKChleHRyZW1hW2kgKyAxXS52YWwgLSBleHRyZW1hW2ldLnZhbCkgLyAzKSAqIDIpIHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2kgKyAxXS52YWwgKyAoKGV4dHJlbWFbaV0udmFsIC0gZXh0cmVtYVtpICsgMV0udmFsKSAvIDMpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSBleHRyZW1hW2ldLnBvczsgaiA8IGV4dHJlbWFbaSArIDFdLnBvczsgaisrKSB7XG4gICAgICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IHRocmVzaG9sZCA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgIH07XG59O1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldmVsb3BtZW50IG9ubHlcbiAqL1xuQnJlc2VuaGFtLmRlYnVnID0ge1xuICAgIHByaW50RnJlcXVlbmN5KGxpbmUsIGNhbnZhcykge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyNTY7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGksIDI1NSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGksIDI1NSAtIGxpbmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBwcmludFBhdHRlcm4obGluZSwgY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyBsZXRcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICBjdHguZmlsbENvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGksIDAsIDEsIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnJlc2VuaGFtO1xuIiwiaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5leHBvcnQgZW51bSBCYXJjb2RlRGlyZWN0aW9uIHtcbiAgICBGb3J3YXJkID0gMSxcbiAgICBSZXZlcnNlID0gLTEsXG59O1xuXG5leHBvcnQgdHlwZSBCYXJjb2RlUmVhZGVyVHlwZSA9IHN0cmluZztcbmV4cG9ydCB0eXBlIEJhcmNvZGVGb3JtYXQgPSBzdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVJlYWRlckNvbmZpZyB7XG4gICAgbm9ybWFsaXplQmFyU3BhY2VXaWR0aD86IGJvb2xlYW4sXG4gICAgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyVHlwZT4sXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVDb3JyZWN0aW9uIHtcbiAgICBiYXI6IG51bWJlcixcbiAgICBzcGFjZTogbnVtYmVyLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUG9zaXRpb24ge1xuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgc3RhcnRDb3VudGVyPzogbnVtYmVyLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIGVuZENvdW50ZXI/OiBudW1iZXIsXG4gICAgZXJyb3I/OiBudW1iZXIsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVJbmZvIGV4dGVuZHMgQmFyY29kZVBvc2l0aW9uIHtcbiAgICBjb2RlOiBudW1iZXIsXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlIHtcbiAgICBjb2RlOiBzdHJpbmcsXG4gICAgY29kZXNldD86IG51bWJlcixcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXG4gICAgZGVjb2RlZENvZGVzPzogQXJyYXk8c3RyaW5nIHwgQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+LFxuICAgIGRpcmVjdGlvbj86IEJhcmNvZGVEaXJlY3Rpb24sXG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kSW5mbz86IEJhcmNvZGVQb3NpdGlvbixcbiAgICBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbixcbiAgICBzdXBwbGVtZW50PzogQmFyY29kZSxcbn07XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBfcm93OiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG4gICAgc3VwcGxlbWVudHM6IEFycmF5PEJhcmNvZGVSZWFkZXI+ID0gW107XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwO1xuICAgIEZPUk1BVDogQmFyY29kZUZvcm1hdCA9ICd1bmtub3duJztcbiAgICBDT05GSUdfS0VZUzogQmFyY29kZVJlYWRlckNvbmZpZyA9IHt9O1xuICAgIC8vIFRPRE86IHNob3VsZCBhZGQgQUxQSEFCRVRIX1NUUklORywgQUxQSEFCRVQsIENIQVJBQ1RFUl9FTkNPRElOR1MgdG8gYmFzZSBjbGFzcywgaWYgdGhleVxuICAgIC8vIGFyZSB1c2VmdWwgaW4gbW9zdCByZWFkZXJzLlxuXG4gICAgYWJzdHJhY3QgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsO1xuXG4gICAgc3RhdGljIGdldCBFeGNlcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBTdGFydE5vdEZvdW5kRXhjZXB0aW9uOiAnU3RhcnQtSW5mbyB3YXMgbm90IGZvdW5kIScsXG4gICAgICAgICAgICBDb2RlTm90Rm91bmRFeGNlcHRpb246ICdDb2RlIGNvdWxkIG5vdCBiZSBmb3VuZCEnLFxuICAgICAgICAgICAgUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uOiAnUGF0dGVybiBjb3VsZCBub3QgYmUgZm91bmQhJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuXG4gICAgICAgIHRoaXMuX3JvdyA9IFtdO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgaWYgKHN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHBsZW1lbnRzID0gc3VwcGxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX25leHRVbnNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHN0YXJ0OiBudW1iZXIgPSAwKTogbnVtYmVyIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgX21hdGNoUGF0dGVybihjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbWF4U2luZ2xlRXJyb3I/OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBsZXQgc2luZ2xlRXJyb3IgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IG1vZHVsbyA9IDA7XG4gICAgICAgIGxldCBiYXJXaWR0aCA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBzY2FsZWQgPSAwO1xuXG4gICAgICAgIG1heFNpbmdsZUVycm9yID0gbWF4U2luZ2xlRXJyb3IgfHwgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBtb2R1bG8gKz0gY29kZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhcldpZHRoID0gc3VtIC8gbW9kdWxvO1xuICAgICAgICBtYXhTaW5nbGVFcnJvciAqPSBiYXJXaWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBzY2FsZWQgPSBjb2RlW2ldICogYmFyV2lkdGg7XG4gICAgICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcbiAgICAgICAgICAgIGlmIChzaW5nbGVFcnJvciA+IG1heFNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvciArPSBzaW5nbGVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3IgLyBtb2R1bG87XG4gICAgfVxuXG4gICAgX25leHRTZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgX2NvcnJlY3RCYXJzKGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvcnJlY3Rpb246IG51bWJlciwgaW5kaWNlczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGxldCB0bXAgPSAwO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHRtcCA9IGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSAqICgxIC0gKCgxIC0gY29ycmVjdGlvbikgLyAyKSk7XG4gICAgICAgICAgICBpZiAodG1wID4gMSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY29kZVBhdHRlcm4ocGF0dGVybjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybicsIHBhdHRlcm4pO1xuICAgICAgICB0aGlzLl9yb3cgPSBwYXR0ZXJuO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybiBjYWxsaW5nIGRlY29kZScsIHR5cGVvZiB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLkZPUk1BVCwgSlNPTi5zdHJpbmdpZnkodGhpcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKCk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdCByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZSgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldmVyc2VkIHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLlJldmVyc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5zdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5Gb3J3YXJkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSB0aGlzLkZPUk1BVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBfbWF0Y2hSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA8IDAgPyAwIDogc3RhcnQ7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9maWxsQ291bnRlcnMob2Zmc2V0OiBudW1iZXIgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KSwgZW5kOiBudW1iZXIgPSB0aGlzLl9yb3cubGVuZ3RoLCBpc1doaXRlOiBib29sZWFuID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuXG4gICAgX3RvQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5IHwgQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W3N0YXJ0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIEFycmF5SGVscGVyLmluaXQoY291bnRlcnMsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBudW1Db3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFyY29kZVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVDb3JyZWN0aW9uLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBDT0RFX1NISUZUID0gOTg7XG4gICAgQ09ERV9DID0gOTk7XG4gICAgQ09ERV9CID0gMTAwO1xuICAgIENPREVfQSA9IDEwMTtcbiAgICBTVEFSVF9DT0RFX0EgPSAxMDM7XG4gICAgU1RBUlRfQ09ERV9CID0gMTA0O1xuICAgIFNUQVJUX0NPREVfQyA9IDEwNTtcbiAgICBTVE9QX0NPREUgPSAxMDY7XG4gICAgQ09ERV9QQVRURVJOID0gW1xuICAgICAgICAgICAgWzIsIDEsIDIsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDIsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDIsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDIsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDMsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDMsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDMsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDIsIDMsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDMsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDMsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDMsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDMsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDEsIDMsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDMsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDEsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDEsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDIsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDIsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDMsIDIsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDMsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDMsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDMsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDEsIDMsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDMsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDMsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDMsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDMsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDMsIDEsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzMsIDMsIDIsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDQsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDQsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDMsIDEsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDIsIDRdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDQsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDIsIDRdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDQsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDQsIDEsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDQsIDEsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDIsIDEsIDRdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDQsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDEsIDRdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDQsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDQsIDIsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDQsIDIsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDQsIDEsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDEsIDEsIDRdLFxuICAgICAgICAgICAgWzQsIDEsIDMsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDQsIDEsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDQsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDQsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDQsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDIsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDQsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDQsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzQsIDIsIDEsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzQsIDIsIDEsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDQsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDIsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDEsIDQsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDMsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDQsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDEsIDRdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDMsIDJdLFxuICAgICAgICAgICAgWzIsIDMsIDMsIDEsIDEsIDEsIDJdLFxuICAgICAgICBdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC42NDtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XG4gICAgRk9STUFUID0gJ2NvZGVfMTI4JztcbiAgICBNT0RVTEVfSU5ESUNFUyA9IHsgYmFyOiBbMCwgMiwgNF0sIHNwYWNlOiBbMSwgMywgNV0gfTtcblxuICAgIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbikge1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JyZWN0KGNvdW50ZXIsIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5jb2RlID09PSAtMSB8fCBiZXN0TWF0Y2guZXJyb3IgPiB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfY29ycmVjdChjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBCYXJjb2RlQ29ycmVjdGlvbikge1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLnNwYWNlLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogX2ZpbmRTdGFydCBhbmQgZGVjb2RlQ29kZSBzaGFyZSBzaW1pbGFyIGNvZGUsIGNhbiB3ZSByZS11c2Ugc29tZT9cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSB0aGlzLlNUQVJUX0NPREVfQTsgY29kZSA8PSB0aGlzLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIC8vICAgICBkb25lID0gZmFsc2UsXG4gICAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIG11bHRpcGxpZXIgPSAwLFxuICAgICAgICAvLyAgICAgY2hlY2tzdW0gPSAwLFxuICAgICAgICAvLyAgICAgY29kZXNldCxcbiAgICAgICAgLy8gICAgIHJhd1Jlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHVuc2hpZnQsXG4gICAgICAgIC8vICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24uYmFyLFxuICAgICAgICAgICAgICAgIHNwYWNlOiBzdGFydEluZm8uY29ycmVjdGlvbi5zcGFjZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgbGV0IGNoZWNrc3VtID0gY29kZS5jb2RlO1xuICAgICAgICBsZXQgY29kZXNldCA9ICgoYzogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoY29kZS5jb2RlKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNoaWZ0TmV4dCA9IGZhbHNlO1xuICAgICAgICBsZXQgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgbGV0IHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICBsZXQgbXVsdGlwbGllciA9IDA7XG4gICAgICAgIGxldCByYXdSZXN1bHQ6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiA9IFtdOyAvLyBUT0RPOiBpIHRoaW5rIHRoaXMgc2hvdWxkIGJlIHN0cmluZyBvbmx5LCBidXQgaXQgY3JlYXRlcyBwcm9ibGVtcyBpZiBpdCBpc1xuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgICAgIHNoaWZ0TmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZSEuZW5kLCBjb2RlIS5jb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3UmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcisrO1xuICAgICAgICAgICAgICAgICAgICBjaGVja3N1bSArPSBtdWx0aXBsaWVyICogY29kZS5jb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXNldCkge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUuY29kZSAtIDY0KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlIDwgMTAgPyAnMCcgKyBjb2RlLmNvZGUgOiBjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bnNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgY29kZXNldCA9IGNvZGVzZXQgPT09IHRoaXMuQ09ERV9BID8gdGhpcy5DT0RFX0IgOiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUuZW5kID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlKSl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrc3VtIC09IG11bHRpcGxpZXIgKiByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoY2hlY2tzdW0gJSAxMDMgIT09IHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBsYXN0IGNvZGUgZnJvbSByZXN1bHQgKGNoZWNrc3VtKVxuICAgICAgICBpZiAocmVtb3ZlTGFzdENoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShyZXN1bHQubGVuZ3RoIC0gMSwgMSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIGNvZGVzZXQ6IGNvZGVzZXQgYXMgbnVtYmVyLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZEluZm86IGNvZGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZUluZm8gfCBudWxsIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgY2FsY3VsYXRlQ29ycmVjdGlvbihleHBlY3RlZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBub3JtYWxpemVkOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPik6IG51bWJlciB7XG4gICAgICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgPSAwLFxuICAgICAgICAgICAgc3VtRXhwZWN0ZWQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgc3VtRXhwZWN0ZWQgKz0gZXhwZWN0ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgKz0gbm9ybWFsaXplZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW1FeHBlY3RlZCAvIHN1bU5vcm1hbGl6ZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMTI4UmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbi8vIGNvbnN0IENPREVfTF9TVEFSVCA9IDA7XG5jb25zdCBDT0RFX0dfU1RBUlQgPSAxMDtcbmV4cG9ydCB7IENPREVfR19TVEFSVCB9O1xuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAxXTtcbmNvbnN0IE1JRERMRV9QQVRURVJOID0gWzEsIDEsIDEsIDEsIDFdO1xuZXhwb3J0IHsgTUlERExFX1BBVFRFUk4gfTtcbmNvbnN0IEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOID0gWzEsIDEsIDJdO1xuY29uc3QgQ09ERV9QQVRURVJOID0gW1xuICAgIFszLCAyLCAxLCAxXSxcbiAgICBbMiwgMiwgMiwgMV0sXG4gICAgWzIsIDEsIDIsIDJdLFxuICAgIFsxLCA0LCAxLCAxXSxcbiAgICBbMSwgMSwgMywgMl0sXG4gICAgWzEsIDIsIDMsIDFdLFxuICAgIFsxLCAxLCAxLCA0XSxcbiAgICBbMSwgMywgMSwgMl0sXG4gICAgWzEsIDIsIDEsIDNdLFxuICAgIFszLCAxLCAxLCAyXSxcbiAgICBbMSwgMSwgMiwgM10sXG4gICAgWzEsIDIsIDIsIDJdLFxuICAgIFsyLCAyLCAxLCAyXSxcbiAgICBbMSwgMSwgNCwgMV0sXG4gICAgWzIsIDMsIDEsIDFdLFxuICAgIFsxLCAzLCAyLCAxXSxcbiAgICBbNCwgMSwgMSwgMV0sXG4gICAgWzIsIDEsIDMsIDFdLFxuICAgIFszLCAxLCAyLCAxXSxcbiAgICBbMiwgMSwgMSwgM10sXG5dO1xuY29uc3QgQ09ERV9GUkVRVUVOQ1kgPSBbMCwgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl07XG4vLyBjb25zdCBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzA7XG5jb25zdCBBVkdfQ09ERV9FUlJPUiA9IDAuNDg7XG5cbmNsYXNzIEVBTlJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fMTMnO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSwgMSwgMV07IC8vIFRPRE86IGRvZXMgdGhpcyBuZWVkIHRvIGJlIGluIHRoZSBjbGFzcz9cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZz86IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBzdXBwbGVtZW50czogW10gfSwgY29uZmlnKSwgc3VwcGxlbWVudHMpO1xuICAgIH1cbiAgICBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbiwgdHJ5SGFyZGVyOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgQXJyYXk8bnVtYmVyPihwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuJywgcGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIsIGVwc2lsb24pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgKiBsb29wIGk9JHtvZmZzZXR9IGxlbj0ke3RoaXMuX3Jvdy5sZW5ndGh9IGlzV2hpdGU9JHtpc1doaXRlfSBjb3VudGVyUG9zPSR7Y291bnRlclBvc31gKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIG1hdGNoUGF0dGVybicsIGVycm9yLCBjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbiAmJiBiZXN0TWF0Y2guZXJyb3IgJiYgZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIGNvdW50ZXIucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZmluZFBhdHRlcm4gYW5kIGRlY29kZUNvZGUgYXBwZWFyIHRvIHNoYXJlIHF1aXRlIHNpbWlsYXIgY29kZSwgY2FuIGl0IGJlIHJlZHVjZWQ/XG4gICAgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29kZXJhbmdlPzogbnVtYmVyKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUnLCBzdGFydCwgY29kZXJhbmdlKTtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZUluZm8gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgaWYgKCFjb2RlcmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGJlZm9yZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIGNvZGVyYW5nZSA9IENPREVfUEFUVEVSTi5sZW5ndGg7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBhZnRlciBsZW5ndGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBjb2RlcmFuZ2U7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFN0YXJ0Jyk7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBzdGFydEluZm89JywgSlNPTi5zdHJpbmdpZnkoc3RhcnRJbmZvKSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpO1xuXG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIHN0YXJ0SW5mbycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBjYWxjdWxhdGVGaXJzdERpZ2l0JywgY29kZUZyZXF1ZW5jeSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDT0RFX0ZSRVFVRU5DWVtpXSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXlsb2FkJywgaW5Db2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9Jywgb3V0Q29kZSk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtPSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMCA8PCAoNSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaXJzdERpZ2l0ID0gdGhpcy5fY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0RGlnaXQ9JywgZmlyc3REaWdpdCk7XG4gICAgICAgIGlmIChmaXJzdERpZ2l0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoZmlyc3REaWdpdCk7XG5cbiAgICAgICAgbGV0IG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgb3V0Q29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcblxuICAgICAgICBpZiAobWlkZGxlUGF0dGVybiA9PT0gbnVsbCB8fCAhbWlkZGxlUGF0dGVybi5lbmQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2RlY29kZUNvZGUobWlkZGxlUGF0dGVybiEuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgICAgICBpZiAoIW1pZGRsZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgobWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIHJlc3VsdD0nLCBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVkQ29kZXM9JywgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgcmV0dXJuIG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm87XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB2ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCk7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kRW5kJywgb2Zmc2V0LCBpc1doaXRlKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGlzV2hpdGUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIF9jaGVja3N1bScsIHJlc3VsdCk7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gKj0gMztcblxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjaGVja3N1bScsIHN1bSAlIDEwID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RlY29kZUV4dGVuc2lvbnMob2Zmc2V0OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBzdGFydCwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zJywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGVyZSBhcmUgJywgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGgsICcgc3VwcGxlbWVudHMnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZXh0ZW5zaW9ucyBsb29wJywgaSwgdGhpcy5zdXBwbGVtZW50c1tpXSwgdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3VwcGxlbWVudHNbaV0uX2RlY29kZSh0aGlzLl9yb3csIHN0YXJ0SW5mby5lbmQpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcmVzdWx0LmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LmRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5zdXBwbGVtZW50c1tpXS5GT1JNQVQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBkZWNvZGVFeHRlbnNpb25zIGVycm9yIGluICcsIHRoaXMuc3VwcGxlbWVudHNbaV0sICc6ICcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZUV4dGVuc2lvbnMnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHJvdyk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxudW1iZXI+KCk7XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IG5ldyBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4oKTtcbiAgICAgICAgbGV0IHJlc3VsdEluZm86IEJhcmNvZGUgfCB7fSA9IHt9O1xuICAgICAgICBsZXQgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVQb3NpdGlvbiB8IEJhcmNvZGVJbmZvIHwgbnVsbCA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmRcbiAgICAgICAgfTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZEVuZChjb2RlLmVuZCwgZmFsc2UpO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICAvLyBDaGVja3N1bVxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrc3VtKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoaXMuc3VwcGxlbWVudHM9JywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBsZW1lbnQgPSB0aGlzLl9kZWNvZGVFeHRlbnNpb25zKGNvZGUuZW5kKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zIHJldHVybnMnLCBzdXBwbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN1cHBsZW1lbnQuZGVjb2RlZENvZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxhc3RDb2RlID0gc3VwcGxlbWVudC5kZWNvZGVkQ29kZXNbc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMubGVuZ3RoIC0gMV0gYXMgQmFyY29kZUluZm87XG4gICAgICAgICAgICBjb25zdCBlbmRJbmZvID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBsYXN0Q29kZS5zdGFydCArICgoKGxhc3RDb2RlLmVuZCAtIGxhc3RDb2RlLnN0YXJ0KSAvIDIpIHwgMCksXG4gICAgICAgICAgICAgICAgZW5kOiBsYXN0Q29kZS5lbmRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxlbWVudCxcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJykgKyBzdXBwbGVtZW50LmNvZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICAuLi5yZXN1bHRJbmZvLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVBTlJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICokLyslJztcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LCAweDEwOSwgMHgwNDksXG4gICAgMHgxNDgsIDB4MDE5LCAweDExOCwgMHgwNTgsIDB4MDBELCAweDEwQywgMHgwNEMsIDB4MDFDLCAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsXG4gICAgMHgwNDYsIDB4MDE2LCAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDA5NCwgMHgwQTgsIDB4MEEyLCAweDA4QSwgMHgwMkEsXG5dKTtcbmNvbnN0IEFTVEVSSVNLID0gMHgwOTQ7XG5cbmNsYXNzIENvZGUzOVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5JztcblxuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls3XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbOF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF90b1BhdHRlcm4oY291bnRlcnM6IFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBsZXQgbWF4TmFycm93V2lkdGggPSAwO1xuICAgICAgICBsZXQgbnVtV2lkZUJhcnMgPSBudW1Db3VudGVycztcbiAgICAgICAgbGV0IHdpZGVCYXJXaWR0aCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKG51bVdpZGVCYXJzID4gMykge1xuICAgICAgICAgICAgbWF4TmFycm93V2lkdGggPSB0aGlzLl9maW5kTmV4dFdpZHRoKGNvdW50ZXJzLCBtYXhOYXJyb3dXaWR0aCk7XG4gICAgICAgICAgICBudW1XaWRlQmFycyA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSAtIGkpO1xuICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycysrO1xuICAgICAgICAgICAgICAgICAgICB3aWRlQmFyV2lkdGggKz0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtV2lkZUJhcnMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzICYmIG51bVdpZGVCYXJzID4gMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudGVyc1tpXSAqIDIpID49IHdpZGVCYXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIF9maW5kTmV4dFdpZHRoKGNvdW50ZXJzOiBVaW50MTZBcnJheSwgY3VycmVudDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBtaW5XaWR0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldIDwgbWluV2lkdGggJiYgY291bnRlcnNbaV0gPiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW5XaWR0aDtcbiAgICB9O1xuXG4gICAgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcGF0dGVyblNpemUgPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xuICAgICAgICBpZiAoKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCAqIDMpID49IHBhdHRlcm5TaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIgfCBudWxsKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuXG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgbGV0IGxhc3RTdGFydDogbnVtYmVyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudGVycyA9IHRoaXMuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycykgYXMgVWludDE2QXJyYXk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzOVJlYWRlcjtcbiIsImltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgcGF0dGVybnMgPSB7XG4gICAgSU9ROiAvW0lPUV0vZyxcbiAgICBBWjA5OiAvW0EtWjAtOV17MTd9Lyxcbn07XG5cbmNsYXNzIENvZGUzOVZJTlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzlfdmluJztcblxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcbiAgICBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICEhY29kZTtcbiAgICB9XG5cbiAgICAvLyBDcmliYmVkIGZyb206XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3p4aW5nL3p4aW5nL2Jsb2IvbWFzdGVyL2NvcmUvc3JjL21haW4vamF2YS9jb20vZ29vZ2xlL3p4aW5nL2NsaWVudC9yZXN1bHQvVklOUmVzdWx0UGFyc2VyLmphdmFcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5fZGVjb2RlKHJvdywgc3RhcnQpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29kZSA9IHJlc3VsdC5jb2RlO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLklPUSwgJycpO1xuXG4gICAgICAgIGlmICghY29kZS5tYXRjaChwYXR0ZXJucy5BWjA5KSkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgQVowOSBwYXR0ZXJuIGNvZGU6JywgY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5VklOUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbi8vIGNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OS0kOi8uK0FCQ0QnO1xuY29uc3QgQUxQSEFCRVQgPSBbNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDQ1LCAzNiwgNTgsIDQ3LCA0NiwgNDMsIDY1LCA2NiwgNjcsIDY4XTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPVxuICAgIFsweDAwMywgMHgwMDYsIDB4MDA5LCAweDA2MCwgMHgwMTIsIDB4MDQyLCAweDAyMSwgMHgwMjQsIDB4MDMwLCAweDA0OCwgMHgwMGMsIDB4MDE4LFxuICAgICAgICAweDA0NSwgMHgwNTEsIDB4MDU0LCAweDAxNSwgMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgU1RBUlRfRU5EID0gWzB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcbmNvbnN0IE1JTl9FTkNPREVEX0NIQVJTID0gNDtcbmNvbnN0IE1BWF9BQ0NFUFRBQkxFID0gMi4wO1xuY29uc3QgUEFERElORyA9IDEuNTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZFNpemUge1xuICAgIHNpemU6IG51bWJlcixcbiAgICBjb3VudHM6IG51bWJlcixcbiAgICBtaW46IG51bWJlcixcbiAgICBtYXg6IG51bWJlcixcbn07XG5cbmludGVyZmFjZSBUaHJlc2hvbGQge1xuICAgIHNwYWNlOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxuICAgIGJhcjoge1xuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXG4gICAgfSxcbn07XG5cbmNsYXNzIE5ld0NvZGFiYXJSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBfY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICBGT1JNQVQgPSAnY29kYWJhcic7XG5cbiAgICBfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgICAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKG1pbiArIG1heCkgLyAyLjApIHwgMDtcbiAgICB9O1xuXG4gICAgX3RvUGF0dGVybihvZmZzZXQ6IG51bWJlcikge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IDc7XG4gICAgICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIG51bUNvdW50ZXJzO1xuXG4gICAgICAgIGlmIChlbmQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhclRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQsIGVuZCk7XG4gICAgICAgIGNvbnN0IHNwYWNlVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCArIDEsIGVuZCk7XG5cbiAgICAgICAgbGV0IGJpdG1hc2sgPSAxIDw8IChudW1Db3VudGVycyAtIDEpO1xuICAgICAgICBsZXQgdGhyZXNob2xkID0gMDtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGkgJiAxKSA9PT0gMCA/IGJhclRocmVzaG9sZCA6IHNwYWNlVGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJzW29mZnNldCArIGldID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiB8PSBiaXRtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0bWFzayA+Pj0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH07XG5cbiAgICBfaXNTdGFydEVuZChwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTVEFSVF9FTkQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChTVEFSVF9FTkRbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9zdW1Db3VudGVycyhzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl9jb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihpKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuICE9PSAtMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTG9vayBmb3Igd2hpdGVzcGFjZSBhaGVhZFxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMuX3N1bUNvdW50ZXJzKDAsIGkpO1xuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoaSwgaSArIDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q291bnRlcjogaSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ291bnRlcjogaSArIDgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgob2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDc7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnRDb3VudGVyOiBudW1iZXIsIGVuZENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBpZiAoKHN0YXJ0Q291bnRlciAtIDEgPD0gMClcbiAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW3N0YXJ0Q291bnRlciAtIDFdID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKHN0YXJ0Q291bnRlcikgLyAyLjApKSB7XG4gICAgICAgICAgICBpZiAoKGVuZENvdW50ZXIgKyA4ID49IHRoaXMuX2NvdW50ZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tlbmRDb3VudGVyICsgN10gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoZW5kQ291bnRlcikgLyAyLjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfY2hhclRvUGF0dGVybihjaGFyOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKEFMUEhBQkVUW2ldID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDSEFSQUNURVJfRU5DT0RJTkdTW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAweDA7XG4gICAgfTtcblxuICAgIF90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCBjYXRlZ29yaXphdGlvbjogVGhyZXNob2xkID0ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpZGU6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpZGU6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zID0gc3RhcnRDb3VudGVyO1xuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IChqICYgMSkgPT09IDIgPyBjYXRlZ29yaXphdGlvbi5iYXIgOiBjYXRlZ29yaXphdGlvbi5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY2F0LnNpemUgKz0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICAgICAgY2F0LmNvdW50cysrO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIChbJ3NwYWNlJywgJ2JhciddIGFzIGNvbnN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld2tpbmQgPSBjYXRlZ29yaXphdGlvbltrZXldO1xuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1pbiA9XG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigobmV3a2luZC5uYXJyb3cuc2l6ZSAvIG5ld2tpbmQubmFycm93LmNvdW50cyArIG5ld2tpbmQud2lkZS5zaXplIC8gbmV3a2luZC53aWRlLmNvdW50cykgLyAyKTtcbiAgICAgICAgICAgIG5ld2tpbmQubmFycm93Lm1heCA9IE1hdGguY2VpbChuZXdraW5kLndpZGUubWluKTtcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5tYXggPSBNYXRoLmNlaWwoKG5ld2tpbmQud2lkZS5zaXplICogTUFYX0FDQ0VQVEFCTEUgKyBQQURESU5HKSAvIG5ld2tpbmQud2lkZS5jb3VudHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2F0ZWdvcml6YXRpb247XG4gICAgfTtcblxuICAgIF92YWxpZGF0ZVJlc3VsdChyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IHRoaXMuX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4ocmVzdWx0LCBzdGFydENvdW50ZXIpO1xuICAgICAgICBsZXQgcG9zID0gc3RhcnRDb3VudGVyO1xuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IChqICYgMSkgPT09IDAgPyB0aHJlc2hvbGRzLmJhciA6IHRocmVzaG9sZHMuc3BhY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA8IGNhdC5taW4gfHwgc2l6ZSA+IGNhdC5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIgfCBudWxsKTogQmFyY29kZSB8IG51bGwge1xuXG4gICAgICAgIHRoaXMuX2NvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKG5leHRTdGFydCk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IDg7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChuZXh0U3RhcnQgPCB0aGlzLl9jb3VudGVycy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIHZlcmlmeSBlbmRcbiAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoIC0gMikgPCBNSU5fRU5DT0RFRF9DSEFSUyB8fCAhdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXJpZnkgZW5kIHdoaXRlIHNwYWNlXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5V2hpdGVzcGFjZShzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdCwgc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFN0YXJ0ID0gbmV4dFN0YXJ0ID4gdGhpcy5fY291bnRlcnMubGVuZ3RoID8gdGhpcy5fY291bnRlcnMubGVuZ3RoIDogbmV4dFN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydC5zdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsIC8vIFRPRE86IGkgdGhpbmsgaXQgc2hvdWxkIG5vdCBiZSByZXF1aXJlZCB0byByZXR1cm4gZm9ybWF0IGZyb20gdGhpcywgYXMgYmFyY29kZV9yZWFkZXIgZm9yY2Ugc2V0cyB0aGUgZm9ybWF0IGFueXdheVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5ld0NvZGFiYXJSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAndXBjX2EnO1xuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEVBTlJlYWRlci5wcm90b3R5cGUuX2RlY29kZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmNvZGUgJiYgcmVzdWx0LmNvZGUubGVuZ3RoID09PSAxMyAmJiByZXN1bHQuY29kZS5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgcmVzdWx0LmNvZGUgPSByZXN1bHQuY29kZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBDUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQsIE1JRERMRV9QQVRURVJOIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgRUFOOFJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl84JztcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IGluQ29kZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBjb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjhSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cblxuY2xhc3MgRUFOMlJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8yJztcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcblxuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDEgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDIgfHwgKHBhcnNlSW50KHJlc3VsdC5qb2luKCcnKSkgJSA0KSAhPT0gY29kZUZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kOiAoY29kZSBhcyBCYXJjb2RlSW5mbykuZW5kLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAoc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbikuc3RhcnQsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFOMlJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzI0LCAyMCwgMTgsIDE3LCAxMiwgNiwgMywgMTAsIDksIDVdO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcblxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgcmV0dXJuIHN1bSAlIDEwO1xufVxuXG5jbGFzcyBFQU41UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzUnO1xuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNSAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNCAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0KSAhPT0gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kOiAoY29kZSBhcyBCYXJjb2RlSW5mbykuZW5kLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAoc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbikuc3RhcnQsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFONVJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDRVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgQ09ERV9GUkVRVUVOQ1kgPSBbXG4gICAgICAgIFsgNTYsIDUyLCA1MCwgNDksIDQ0LCAzOCwgMzUsIDQyLCA0MSwgMzcgXSxcbiAgICAgICAgWzcsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdXTtcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogN107XG4gICAgRk9STUFUID0gJ3VwY19lJztcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA9IChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gKDEgPDwgKDUgLSBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0Q29kZSBhcyBCYXJjb2RlSW5mbztcbiAgICB9O1xuXG4gICAgX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5OiBudW1iZXIsIHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBmb3IgKGxldCBuclN5c3RlbSA9IDA7IG5yU3lzdGVtIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IG5yU3lzdGVtKyspe1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfY29udmVydFRvVVBDQShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IHVwY2EgPSBbcmVzdWx0WzBdXTtcbiAgICAgICAgY29uc3QgbGFzdERpZ2l0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAyXTtcblxuICAgICAgICBpZiAobGFzdERpZ2l0IDw9IDIpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgMykpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbbGFzdERpZ2l0LCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSgzLCA2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAzKSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDQpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDQsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDQpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNSkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMCwgcmVzdWx0WzVdXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDYpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIGxhc3REaWdpdF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBjYS5wdXNoKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gdXBjYTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jaGVja3N1bSh0aGlzLl9jb252ZXJ0VG9VUENBKHJlc3VsdCkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2ZpbmRFbmQob2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBDRVJlYWRlcjtcbiIsIi8vIFRPRE86IGkyb2Y1X3JlYWRlciBhbmQgMm9mNV9yZWFkZXIgc2hhcmUgdmVyeSBzaW1pbGFyIGNvZGUsIG1ha2UgdXNlIG9mIHRoYXRcblxuaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5cbmNsYXNzIEkyb2Y1UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjM4O1xuXG4gICAgU1RBUlRfUEFUVEVSTiA9IFtOLCBOLCBOLCBOXTtcbiAgICBTVE9QX1BBVFRFUk4gPSBbTiwgTiwgV107XG4gICAgQ09ERV9QQVRURVJOID0gW1xuICAgICAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICAgICAgW04sIFcsIE4sIE4sIFddLFxuICAgICAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICAgICAgW1csIE4sIFcsIE4sIE5dLFxuICAgICAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICAgICAgW1csIE4sIE4sIFcsIE5dLFxuICAgICAgICBbTiwgVywgTiwgVywgTl0sXG4gICAgXTtcbiAgICBNQVhfQ09SUkVDVElPTl9GQUNUT1IgPSA1O1xuICAgIEZPUk1BVCA9ICdpMm9mNSc7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzOiBCYXJjb2RlUmVhZGVyQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKHsgbm9ybWFsaXplQmFyU3BhY2VXaWR0aDogZmFsc2UgfSwgb3B0cykpO1xuICAgICAgICBpZiAob3B0cy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SID0gMC4zODtcbiAgICAgICAgICAgIHRoaXMuQVZHX0NPREVfRVJST1IgPSAwLjA5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnID0gb3B0cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX21hdGNoUGF0dGVybihjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb2RlU3VtID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvbiA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpbyA9IHRoaXMuTUFYX0NPUlJFQ1RJT05fRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvSW52ZXJzZSA9IDEgLyBjb3JyZWN0aW9uUmF0aW87XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJTdW1baSAlIDJdICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICAgICAgY29kZVN1bVtpICUgMl0gKz0gY29kZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMF0gPSBjb2RlU3VtWzBdIC8gY291bnRlclN1bVswXTtcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBjb2RlU3VtWzFdIC8gY291bnRlclN1bVsxXTtcblxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMF0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMV0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICAgICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gY29ycmVjdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaV0gKj0gdGhpcy5iYXJTcGFjZVJhdGlvW2kgJSAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX21hdGNoUGF0dGVybi5jYWxsKHRoaXMsIGNvdW50ZXIsIGNvZGUpO1xuICAgIH07XG5cbiAgICBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ/OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4gPSBmYWxzZSwgdHJ5SGFyZGVyOiBib29sZWFuID0gZmFsc2UpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xuICAgICAgICB0cnlIYXJkZXIgPSB0cnlIYXJkZXIgfHwgZmFsc2U7XG5cbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIDQpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2ZpbmRFbmQoKSB7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTik7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfTtcblxuICAgIF9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyOiBBcnJheTxBcnJheTxudW1iZXI+Pikge1xuICAgICAgICBjb25zdCBjb2RlczogQXJyYXk8QmFyY29kZUluZm8+ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgX2RlY29kZUNvZGUoY291bnRlcjogQXJyYXk8bnVtYmVyPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJQYWlyID0gW1swLCAwLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDAsIDBdXTtcbiAgICAgICAgbGV0IGNvZGVzOiBCYXJjb2RlSW5mb1tdIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMF1baV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzFdW2ldID0gY291bnRlcnNbcG9zICsgMV0gKiB0aGlzLmJhclNwYWNlUmF0aW9bMV07XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlcyA9IHRoaXMuX2RlY29kZVBhaXIoY291bnRlclBhaXIpO1xuICAgICAgICAgICAgaWYgKCFjb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGVzW2ldLmNvZGUgKyAnJyk7XG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4oKTtcblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHxcbiAgICAgICAgICAgICAgICByZXN1bHQubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5jb25zdCBTVEFSVF9QQVRURVJOID0gW1csIE4sIFcsIE4sIE4sIE5dO1xuY29uc3QgU1RPUF9QQVRURVJOID0gW1csIE4sIE4sIE4sIFddO1xuY29uc3QgQ09ERV9QQVRURVJOID0gW1xuICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgW04sIFcsIE4sIE4sIFddLFxuICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgW1csIE4sIFcsIE4sIE5dLFxuICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgW1csIE4sIE4sIFcsIE5dLFxuICAgIFtOLCBXLCBOLCBXLCBOXSxcbl07XG5jb25zdCBTVEFSVF9QQVRURVJOX0xFTkdUSCA9IFNUQVJUX1BBVFRFUk4ucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcblxuY2xhc3MgVHdvT2ZGaXZlUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcblxuICAgIEZPUk1BVCA9ICcyb2Y1JztcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcblxuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcblxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlID0gZmFsc2UsIHRyeUhhcmRlciA9IGZhbHNlKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFtdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGxldCBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyBTVEFSVF9QQVRURVJOX0xFTkdUSCk7XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiA1O1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgIH1cblxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2ZpbmRFbmQoKSB7XG4gICAgICAgIC8vIFRPRE86IHJldmVyc2UsIGZvbGxvd2VkIGJ5IHNvbWUgY2FsY3MsIGZvbGxvd2VkIGJ5IGFub3RoZXIgcmV2ZXJzZT8gcmVhbGx5P1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVE9QX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgICAgICBlbmRJbmZvLnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH1cblxuICAgIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xuICAgIH1cblxuICAgIF9kZWNvZGVDb2RlKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPikge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlcik7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2NvZGUuY29kZX1gKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cblxuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XG4gICAgICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFR3b09mRml2ZVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICQvKyVhYmNkKic7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAweDExNCwgMHgxNDgsIDB4MTQ0LCAweDE0MiwgMHgxMjgsIDB4MTI0LCAweDEyMiwgMHgxNTAsIDB4MTEyLCAweDEwQSxcbiAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcbiAgICAweDExQSwgMHgxNTgsIDB4MTRDLCAweDE0NiwgMHgxMkMsIDB4MTE2LCAweDFCNCwgMHgxQjIsIDB4MUFDLCAweDFBNixcbiAgICAweDE5NiwgMHgxOUEsIDB4MTZDLCAweDE2NiwgMHgxMzYsIDB4MTNBLCAweDEyRSwgMHgxRDQsIDB4MUQyLCAweDFDQSxcbiAgICAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUUsXG5dKTtcbmNvbnN0IEFTVEVSSVNLID0gMHgxNUU7XG5cbmNsYXNzIENvZGU5M1JlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzkzJztcbiAgICBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXJzLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5IC8gc3VtKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkIDwgMSB8fCBub3JtYWxpemVkID4gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSAmIDEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub3JtYWxpemVkOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IChwYXR0ZXJuIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPDw9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF92ZXJpZnlFbmQobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyKSB7XG4gICAgICAgIGlmIChsYXN0U3RhcnQgPT09IG5leHRTdGFydCB8fCAhdGhpcy5fcm93W25leHRTdGFydF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZUV4dGVuZGVkKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPikge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjaGFyQXJyYXkubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChjaGFyID49ICdhJyAmJiBjaGFyIDw9ICdkJykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gKGxlbmd0aCAtIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJBcnJheVsrK2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IG5leHRDaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDY0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdGJyAmJiBuZXh0Q2hhciA8PSAnSicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnSycgJiYgbmV4dENoYXIgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1AnICYmIG5leHRDaGFyIDw9ICdTJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyA0Myk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdUJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICc6JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogY29kZV85M19yZWFkZXIgX2RlY29kZUV4dGVuZGVkIGhpdCBkZWZhdWx0IGNhc2UsIHRoaXMgbWF5IGJlIGFuIGVycm9yJywgZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPiwgaW5kZXg6IG51bWJlciwgbWF4V2VpZ2h0OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgYXJyYXlUb0NoZWNrID0gY2hhckFycmF5LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlUb0NoZWNrLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ZWRTdW1zID0gYXJyYXlUb0NoZWNrLnJlZHVjZSgoc3VtLCBjaGFyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSAoKChpICogLTEpICsgKGxlbmd0aCAtIDEpKSAlIG1heFdlaWdodCkgKyAxO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBTFBIQUJFVC5pbmRleE9mKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgKHdlaWdodCAqIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgY29uc3QgY2hlY2tDaGFyID0gQUxQSEFCRVRbKHdlaWdodGVkU3VtcyAlIDQ3KV07XG4gICAgICAgIHJldHVybiBjaGVja0NoYXIgPT09IGNoYXJBcnJheVtpbmRleF0uY2hhckNvZGVBdCgwKTtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeUNoZWNrc3VtcyhjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDIsIDIwKVxuICAgICAgICAgICAgJiYgdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMSwgMTUpO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiB8IG51bGwgPSBbXTtcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0O1xuICAgICAgICBsZXQgZGVjb2RlZENoYXI6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICByZXN1bHQucG9wKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5RW5kKGxhc3RTdGFydCwgbmV4dFN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNoZWNrc3VtcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGVuZ3RoIC0gMik7XG4gICAgICAgIC8vIHllcywgdGhpcyBpcyBhbiBhc3NpZ24gaW5zaWRlIGFuIGlmLlxuICAgICAgICBpZiAoKHJlc3VsdCA9IHRoaXMuX2RlY29kZUV4dGVuZGVkKHJlc3VsdCkpID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGU5M1JlYWRlcjtcbiIsImltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgcGF0dGVybnMgPSB7XG4gICAgQUVJTzogL1tBRUlPXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XS8sXG59O1xuXG5jb25zdCBjb2RlMzJzZXQgPSAnMDEyMzQ1Njc4OUJDREZHSEpLTE1OUFFSU1RVVldYWVonO1xuXG5jbGFzcyBDb2RlMzJSZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzMyX3JlYWRlcic7XG5cbiAgICBfZGVjb2RlQ29kZTMyKGNvZGU6IHN0cmluZykge1xuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcyAqIDMyICsgY29kZTMyc2V0LmluZGV4T2YoY29kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGUzMiA9ICcnICsgcmVzO1xuICAgICAgICBpZiAoY29kZTMyLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnQScgKyBjb2RlMzI7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9kZWNvZGUocm93LCBzdGFydCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuQUVJTywgJycpO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29kZTMyID0gdGhpcy5fZGVjb2RlQ29kZTMyKGNvZGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFjb2RlMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGUzMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzMlJlYWRlcjtcbiIsImltcG9ydCBCcmVzZW5oYW0gZnJvbSAnLi9icmVzZW5oYW0nO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl84X3JlYWRlcic7XG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzkzX3JlYWRlcic7XG5pbXBvcnQgQ29kZTMyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzMyX3JlYWRlcic7XG5cbmNvbnN0IFJFQURFUlMgPSB7XG4gICAgY29kZV8xMjhfcmVhZGVyOiBDb2RlMTI4UmVhZGVyLFxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcbiAgICBlYW5fNV9yZWFkZXI6IEVBTjVSZWFkZXIsXG4gICAgZWFuXzJfcmVhZGVyOiBFQU4yUmVhZGVyLFxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcbiAgICBjb2RlXzM5X3JlYWRlcjogQ29kZTM5UmVhZGVyLFxuICAgIGNvZGVfMzlfdmluX3JlYWRlcjogQ29kZTM5VklOUmVhZGVyLFxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxuICAgIHVwY19yZWFkZXI6IFVQQ1JlYWRlcixcbiAgICB1cGNfZV9yZWFkZXI6IFVQQ0VSZWFkZXIsXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcbiAgICAnMm9mNV9yZWFkZXInOiBUd29PZkZpdmVSZWFkZXIsXG4gICAgY29kZV85M19yZWFkZXI6IENvZGU5M1JlYWRlcixcbiAgICBjb2RlXzMyX3JlYWRlcjogQ29kZTMyUmVhZGVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHJlZ2lzdGVyUmVhZGVyOiAobmFtZSwgcmVhZGVyKSA9PiB7XG4gICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgfSxcbiAgICBjcmVhdGUoY29uZmlnLCBpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICBjb25zdCBfY2FudmFzID0ge1xuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX2JhcmNvZGVSZWFkZXJzID0gW107XG5cbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICBpbml0Q29uZmlnKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRkZWJ1ZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1Zy5kZXRlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZnJlcXVlbmN5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5jbGFzc05hbWUgPSAnZnJlcXVlbmN5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHguZnJlcXVlbmN5ID0gX2NhbnZhcy5kb20uZnJlcXVlbmN5LmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLnBhdHRlcm5CdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuLmNsYXNzTmFtZSA9ICdwYXR0ZXJuQnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LnBhdHRlcm4gPSBfY2FudmFzLmRvbS5wYXR0ZXJuLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmRyYXdpbmdCdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5kb20ub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5vdmVybGF5ID0gX2NhbnZhcy5kb20ub3ZlcmxheS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRSZWFkZXJzKCkge1xuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaCgocmVhZGVyQ29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRlcjtcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCBzdXBwbGVtZW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSByZWFkZXJDb25maWcuY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiAnLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5zdXBwbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdXBwbGVtZW50cy5tYXAoKHN1cHBsZW1lbnQpID0+IG5ldyBSRUFERVJTW3N1cHBsZW1lbnRdKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXJPYmogPSBuZXcgUkVBREVSU1tyZWFkZXJdKGNvbmZpZ3VyYXRpb24sIHN1cHBsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLnB1c2gocmVhZGVyT2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBFcnJvciBjb25zdHJ1Y3RpbmcgcmVhZGVyICcsIHJlYWRlciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWdpc3RlcmVkIFJlYWRlcnM6ICR7X2JhcmNvZGVSZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHJlYWRlcikgPT4gSlNPTi5zdHJpbmdpZnkoeyBmb3JtYXQ6IHJlYWRlci5GT1JNQVQsIGNvbmZpZzogcmVhZGVyLmNvbmZpZyB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20uZnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybixcbiAgICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kIHRoZSBsaW5lIG9uIGJvdGggZW5kc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGFuZ2xlLCBleHQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBhbW91bnQgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaW5zaWRlIGltYWdlXG4gICAgICAgICAgICBleHRlbmRMaW5lKGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0pXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzFdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xuICAgICAgICAgICAgICAgIGV4dGVuZExpbmUoLWV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICB4OiAoYm94WzFdWzBdIC0gYm94WzBdWzBdKSAvIDIgKyBib3hbMF1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IChib3hbM11bMF0gLSBib3hbMl1bMF0pIC8gMiArIGJveFsyXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV0sXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZShsaW5lKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgYmFyY29kZUxpbmUgPSBCcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUoaW5wdXRJbWFnZVdyYXBwZXIsIGxpbmVbMF0sIGxpbmVbMV0pO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIF9jYW52YXMuY3R4Lm92ZXJsYXksIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50RnJlcXVlbmN5KGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJyZXNlbmhhbS50b0JpbmFyeUxpbmUoYmFyY29kZUxpbmUpO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybikge1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludFBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZVBhdHRlcm4oYmFyY29kZUxpbmUubGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KGJveFsxXVswXSAtIGJveFswXVswXSwgMikgKyBNYXRoLnBvdygoYm94WzFdWzFdIC0gYm94WzBdWzFdKSwgMikpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBzbGljZXMgPSAxNjtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRpcjtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb247XG4gICAgICAgICAgICBjb25zdCB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHlkaXIgPSBNYXRoLmNvcyhsaW5lQW5nbGUpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgc2xpY2VzICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBsaW5lIHBlcnBlbmRpY3VsYXIgdG8gYW5nbGVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgZGlyID0gc2lkZUxlbmd0aCAvIHNsaWNlcyAqIGkgKiAoaSAlIDIgPT09IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogZGlyICogeGRpcixcbiAgICAgICAgICAgICAgICAgICAgeDogZGlyICogeWRpcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS55IC0gbGluZVswXS55KSwgMilcbiAgICAgICAgICAgICAgICArIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZUltYWdlID8gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZUltYWdlKGltYWdlV3JhcHBlcikgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxuICAgICAgICAgKiB2YWxpZCBiYXJjb2RlIHBhdHRlcm4gd2l0aGluIHRoZSBnaXZlbiBhcmVhLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYm94IFRoZSBhcmVhIHRvIHNlYXJjaCBpblxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgbGV0IGxpbmU7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBfY2FudmFzLmN0eC5vdmVybGF5O1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcuZHJhd0JvdW5kaW5nQm94ICYmIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIGN0eCwgeyBjb2xvcjogJ2JsdWUnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lID0gZ2V0TGluZShib3gpO1xuICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGdldExpbmVMZW5ndGgobGluZSk7XG4gICAgICAgICAgICBjb25zdCBsaW5lQW5nbGUgPSBNYXRoLmF0YW4yKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSwgbGluZVsxXS54IC0gbGluZVswXS54KTtcbiAgICAgICAgICAgIGxpbmUgPSBnZXRFeHRlbmRlZExpbmUobGluZSwgbGluZUFuZ2xlLCBNYXRoLmZsb29yKGxpbmVMZW5ndGggKiAwLjEpKTtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwgeyB4OiAneCcsIHk6ICd5JyB9LCBjdHgsIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBhbmdsZTogbGluZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHJlc3VsdC5iYXJjb2RlTGluZS5saW5lLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogcmVzdWx0LmJhcmNvZGVMaW5lLnRocmVzaG9sZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykge1xuICAgICAgICAgICAgICAgIGxldCBpOyBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhcmNvZGVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtdWx0aXBsZSB9ID0gY29uZmlnO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmJveCA9IGJveDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21JbWFnZShpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZUZyb21JbWFnZShpbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWdpc3RlciBleGlzdGluZyByZWFkZXInLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRSZWFkZXJzKHJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb25maWcucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJ0eXBlIEV2ZW50TmFtZSA9IHN0cmluZztcblxuaW50ZXJmYWNlIFN1YnNjcmlwdGlvbiB7XG4gICAgYXN5bmM/OiBib29sZWFuO1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcbiAgICBvbmNlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50RGF0YSB7XG4gICAgc3Vic2NyaWJlcnM6IEFycmF5PFN1YnNjcmlwdGlvbj47XG59XG5cbmludGVyZmFjZSBFdmVudHMge1xuICAgIFtrZXk6IHN0cmluZ106IEV2ZW50RGF0YTtcbn1cblxuaW50ZXJmYWNlIEV2ZW50SW50ZXJmYWNlIHtcbiAgICBzdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQ7XG4gICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIEV2ZW50SW50ZXJmYWNlKCk6IEV2ZW50SW50ZXJmYWNlIHtcbiAgICBsZXQgZXZlbnRzOiBFdmVudHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50TmFtZTogRXZlbnROYW1lKTogRXZlbnREYXRhIHtcbiAgICAgICAgaWYgKCFldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJFdmVudHMoKTogdm9pZCB7XG4gICAgICAgIGV2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24sIGRhdGE6IG5ldmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH0sIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayB3YXMgbm90IHNwZWNpZmllZCBvbiBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICAgICAgcmV0dXJuIF9zdWJzY3JpYmUoZXZlbnQsIGNhbGxiYWNrLCBhc3luYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gZXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggb25lLXRpbWUgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhIXN1YnNjcmliZXIub25jZSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSBhcyBuZXZlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc3Vic2NyaWJlclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICFzdWJzY3JpYmVyLm9uY2UpO1xuXG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRoZSByZXN0XG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmMgPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgX3N1YnNjcmliZShldmVudCwge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IGV2ZW50LnN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlci5jYWxsYmFjayAhPT0gY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhckV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59KCkpO1xuIiwiY29uc3QgRVJST1JfREVTQyA9ICdUaGlzIG1heSBtZWFuIHRoYXQgdGhlIHVzZXIgaGFzIGRlY2xpbmVkIGNhbWVyYSBhY2Nlc3MsIG9yIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbWVkaWEgQVBJcy4gSWYgeW91IGFyZSBydW5uaW5nIGluIGlPUywgeW91IG11c3QgdXNlIFNhZmFyaS4nO1xuXG5pbnRlcmZhY2UgRXJyb3Ige1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgc3RhY2s/OiBzdHJpbmc7XG4gICAgY29kZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXJyb3IoYGVudW1lcmF0ZURldmljZXMgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gKTtcbiAgICAgICAgZXJyb3IuY29kZSA9IC0xO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXJyb3IoYGdldFVzZXJNZWRpYSBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWApO1xuICAgICAgICBlcnJvci5jb2RlID0gLTE7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoL3BpY2snO1xuaW1wb3J0IHsgZ2V0VXNlck1lZGlhLCBlbnVtZXJhdGVEZXZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL21lZGlhRGV2aWNlcyc7XG5pbXBvcnQgeyBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5sZXQgc3RyZWFtUmVmOiBNZWRpYVN0cmVhbSB8IG51bGw7XG5cbmZ1bmN0aW9uIHdhaXRGb3JWaWRlbyh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDEwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVmlkZW8oKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvLnZpZGVvV2lkdGggPiAxMCAmJiB2aWRlby52aWRlb0hlaWdodCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAqIGRldjogY2hlY2tWaWRlbyBmb3VuZCAke3ZpZGVvLnZpZGVvV2lkdGh9cHggeCAke3ZpZGVvLnZpZGVvSGVpZ2h0fXB4YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVmlkZW8sIDUwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gcGxheSB2aWRlbyBzdHJlYW0uIElzIHdlYmNhbSB3b3JraW5nPycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dGVtcHRzLS07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWaWRlbygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY2FtZXJhLXN0cmVhbSB0byBhIGdpdmVuIHZpZGVvLWVsZW1lbnRcbiAqIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgY29udGVudCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCwgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIHN0cmVhbVJlZiA9IHN0cmVhbTtcbiAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ211dGVkJywgJ3RydWUnKTtcbiAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJ3RydWUnKTsgLy8gbm90IGxpc3RlZCBvbiBNRE4uLi5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gd2FpdEZvclZpZGVvKHZpZGVvKTtcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gcGljayh2aWRlb0NvbnN0cmFpbnRzLCBbJ3dpZHRoJywgJ2hlaWdodCcsICdmYWNpbmdNb2RlJyxcbiAgICAgICAgJ2FzcGVjdFJhdGlvJywgJ2RldmljZUlkJ10pO1xuXG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgJiYgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyA+IDApIHtcbiAgICAgICAgbm9ybWFsaXplZC5hc3BlY3RSYXRpbyA9IHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW87XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ21pbkFzcGVjdFJhdGlvXFwnIGlzIGRlcHJlY2F0ZWQ7IFVzZSBcXCdhc3BlY3RSYXRpb1xcJyBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5mYWNpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuZmFjaW5nTW9kZSA9IHZpZGVvQ29uc3RyYWludHMuZmFjaW5nO1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogQ29uc3RyYWludCBcXCdmYWNpbmdcXCcgaXMgZGVwcmVjYXRlZC4gVXNlIFxcJ2ZhY2luZ01vZGVcXCcgaW5zdGVhZFxcJycpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gVE9ETzogIzE5MiBJIGRvbid0IHRoaW5rIHRoZXJlJ3MgYW55IGdvb2QgcmVhc29uIHBpY2tDb25zdHJhaW50cyBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSxcbi8vIEkgdGhpbmsgaXQgd2FzIGp1c3QgdGhhdCB3YXkgc28gaXQgY291bGQgYmUgY2hhaW5lZCB0byBvdGhlciBmdW5jdGlvbnMgdGhhdCBkaWQgcmV0dXJuIGEgUHJvbWlzZS5cbi8vIFRoYXQncyBub3QgbmVjZXNzYXJ5IHdpdGggYXN5bmMgZnVuY3Rpb25zIGJlaW5nIGEgdGhpbmcsIHNvIHRoYXQgc2hvdWxkIGJlIGZpeGVkLlxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCA9IHt9KTogUHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPiB7XG4gICAgY29uc3QgdmlkZW8gPSBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG5cbiAgICBpZiAodmlkZW8gJiYgdmlkZW8uZGV2aWNlSWQgJiYgdmlkZW8uZmFjaW5nTW9kZSkge1xuICAgICAgICBkZWxldGUgdmlkZW8uZmFjaW5nTW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGF1ZGlvOiBmYWxzZSwgdmlkZW8gfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVudW1lcmF0ZVZpZGVvRGV2aWNlcygpOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcblxuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBlbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKChkZXZpY2U6IE1lZGlhRGV2aWNlSW5mbykgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCBudWxsIHtcbiAgICBpZiAoIXN0cmVhbVJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgcmV0dXJuIHRyYWNrcyAmJiB0cmFja3M/Lmxlbmd0aCA/IHRyYWNrc1swXSA6IG51bGw7XG59XG5cbi8qKlxuICogVXNlZCBmb3IgYWNjZXNzaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3RpdmUgc3RyZWFtIHRyYWNrIGFuZCBhdmFpbGFibGUgdmlkZW8gZGV2aWNlcy5cbiAqL1xuY29uc3QgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MgPSB7XG4gICAgYXN5bmMgcmVxdWVzdCh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCwgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3QgbmV3Q29uc3RyYWludHMgPSBhd2FpdCBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgIHJldHVybiBpbml0Q2FtZXJhKHZpZGVvLCBuZXdDb25zdHJhaW50cyk7XG4gICAgfSxcbiAgICByZWxlYXNlKCk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPOiBpIHdvbmRlciBpZiB0ZWxsaW5nIHRoZSBWaWRlbyBlbGVtZW50IHRvIHBhdXNlKCkgYmVmb3JlIGNhbGxpbmcgTWVkaWFTdHJlYW1UcmFjay5zdG9wKCkgd291bGQgYWxsZXZpYXRlIHNvbWUgb2YgdGhlIGlzc3VlcyB3aXRoIHRoZSBjYW1lcmEgYXBwZWFyaW5nIHRvIHN0YXkgb3BlbiBvbiBBbmRyb2lkIGV2ZW4gYWZ0ZXIgc3RvcHBpbmcuXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZiAmJiBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKHRyYWNrcyAmJiB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmFja3NbMF0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVJlZiA9IG51bGw7XG4gICAgfSxcbiAgICBlbnVtZXJhdGVWaWRlb0RldmljZXMsXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5sYWJlbCA6ICcnO1xuICAgIH0sXG4gICAgZ2V0QWN0aXZlVHJhY2ssXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU0NhbWVyYUFjY2VzcztcbiIsImltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQge1xuICAgIFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvcixcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uLFxuICAgIFhZU2l6ZSxcbiAgICBRdWFnZ2FJbWFnZURhdGEsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5mdW5jdGlvbiBjb250YWlucyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsIGxpc3Q6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gbGlzdCAmJiBsaXN0LnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pIGFzIEFycmF5PGtleW9mIFF1YWdnYUpTQ29kZVJlc3VsdD47XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IGl0ZW1ba2V5XSA9PT0gY29kZVJlc3VsdFtrZXldKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKFxuICAgIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBmaWx0ZXI6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24gfCB1bmRlZmluZWQsXG4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZpbHRlcihjb2RlUmVzdWx0KSA6IHRydWU7XG59XG5cbmludGVyZmFjZSBSZXN1bHRDb2xsZWN0b3Ige1xuICAgIGFkZFJlc3VsdDogKGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCkgPT4gdm9pZDtcbiAgICBnZXRSZXN1bHRzOiAoKSA9PiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlKGNvbmZpZzogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IpOiBSZXN1bHRDb2xsZWN0b3Ige1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgICAgICBjb25zdCByZXN1bHRzOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+ID0gW107XG4gICAgICAgIGxldCBjYXBhY2l0eSA9IGNvbmZpZy5jYXBhY2l0eSA/PyAyMDtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgICAgIHJldHVybiAhIWNhcGFjaXR5XG4gICAgICAgICAgICAgICAgJiYgY29kZVJlc3VsdFxuICAgICAgICAgICAgICAgICYmICFjb250YWlucyhjb2RlUmVzdWx0LCBjb25maWcuYmxhY2tsaXN0IGFzIEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFJlc3VsdChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IGFueSA9IHsgfTsgLy8gdGhpcyBpcyAnYW55JyB0byBhdm9pZCBoYXZpbmcgdG8gY29uc3RydWN0IGEgd2hvbGUgUXVhZ2dhSlNDb2RlUmVzdWx0IDp8XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eS0tO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCA9IGNvZGVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZVNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdWx0cygpOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBEZXZDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIGRyYXdCb3VuZGluZ0JveDogZmFsc2UsXG4gICAgICAgICAgICBzaG93RnJlcXVlbmN5OiBmYWxzZSxcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0dGVybjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBzaG93Q2FudmFzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGb3VuZFBhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1NrZWxldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dSZW1haW5pbmdQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBib3hGcm9tUGF0Y2hlczoge1xuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkQm94OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QkI6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGV2Q29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgTm9kZUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICBzaXplOiA4MDAsXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9kZUNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IFByb2RDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDQsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvZENvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgRGV2Q29uZmlnIGZyb20gJy4vY29uZmlnLmRldic7XG5pbXBvcnQgTm9kZUNvbmZpZyBmcm9tICcuL2NvbmZpZy5ub2RlJztcbmltcG9ydCBQcm9kQ29uZmlnIGZyb20gJy4vY29uZmlnLnByb2QnO1xuXG4vLyBAdHMtaWdub3JlIC8vIFRPRE86IHRoaXMgcHJvZHVjZXMgYSBiaXphcnJlIHR5cGVzY3JpcHQgZXJyb3Jcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuY29uc3QgUXVhZ2dhQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IEVOVi5kZXZlbG9wbWVudFxuICAgID8gRGV2Q29uZmlnXG4gICAgOiBFTlYubm9kZVxuICAgICAgICA/IE5vZGVDb25maWdcbiAgICAgICAgOiBQcm9kQ29uZmlnO1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gXCIuLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tIFwiY29tbW9uL2ltYWdlX3dyYXBwZXJcIjtcblxuZXhwb3J0IGNsYXNzIFF1YWdnYUNvbnRleHQge1xuICAgIHB1YmxpYyBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdDtcblxuICAgIHB1YmxpYyBpbnB1dFN0cmVhbTogYW55O1xuXG4gICAgcHVibGljIGZyYW1lZ3JhYmJlcjogYW55O1xuXG4gICAgcHVibGljIGlucHV0SW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyO1xuXG4gICAgcHVibGljIHN0b3BwZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBib3hTaXplOiBhbnk7XG5cbiAgICBwdWJsaWMgcmVzdWx0Q29sbGVjdG9yOiBhbnk7XG5cbiAgICBwdWJsaWMgZGVjb2RlcjogYW55O1xuXG4gICAgcHVibGljIHdvcmtlclBvb2w6IGFueVtdID0gW107XG5cbiAgICBwdWJsaWMgb25VSVRocmVhZCA9IHRydWU7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FudmFzQ29udGFpbmVyID0gbmV3IENhbnZhc0NvbnRhaW5lcigpO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzSW5mbyB7XG4gICAgaW1hZ2U6IGFueTtcbiAgICBvdmVybGF5OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNDb250YWluZXIge1xuICAgIHB1YmxpYyByZWFkb25seSBjdHg6IENhbnZhc0luZm87XG4gICAgcHVibGljIHJlYWRvbmx5IGRvbTogQ2FudmFzSW5mbztcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN0eCA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgICAgIHRoaXMuZG9tID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbSB9IGZyb20gJy4uL2lucHV0L2lucHV0X3N0cmVhbV9mYWN0b3J5JztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcblxudHlwZSBCdWZmZXJSZXR1cm4gPSB7XG4gICAgaW5wdXRJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcjtcbiAgICAvLyBib3hTaXplIHNob3VsZCBiZSBsaWtlIFtbIG51bWJlciwgbnVtYmVyXSwgLi4uXSBidXQgY2xvbmUncyBzaWduYXR1cmUgZG9lc24ndCBzZWVtIHRvIGFsbG93IHRoYXRcbiAgICBib3hTaXplOiBBcnJheTxBcnJheTxudW1iZXI+Pjtcbn07XG5cbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXG4gICAgbG9jYXRvcjogYW55LFxuKTogQnVmZmVyUmV0dXJuIHtcbiAgICBjb25zdCBpbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlciB8fCBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgIHR5cGU6ICdYWVNpemUnLFxuICAgIH0pO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICBjbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChpbnB1dEltYWdlV3JhcHBlciwgbG9jYXRvcik7XG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdQb3J0KHRhcmdldD86IEVsZW1lbnQgfCBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFscmVhZHkgYSBET00gZWxlbWVudFxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIFVzZSAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JyBhcyBhIGZhbGxiYWNrIHNlbGVjdG9yIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBnZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicpO1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicpO1xuXG4gICAgICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IG92ZXJsYXkuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY2FudmFzLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0Q2FudmFzKGNvbnRleHQ6IFF1YWdnYUNvbnRleHQpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLy8gTk9URTogKFNPTUUgT0YpIFRISVMgSVMgQlJPV1NFUiBPTkxZIENPREUuICBOb2RlIGRvZXMgbm90IGhhdmUgJ2F0b2InIGJ1aWx0IGluLCBub3IgWE1MSHR0cFJlcXVlc3QuXG4vLyBIb3cgZXhhY3RseSBpcyB0aGlzIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBpbiBRdWFnZ2E/IERvIHdlIG5lZWQgdGhlIGJyb3dzZXIgc3BlY2lmaWMgY29kZT8gRG8gd2Vcbi8vIG5lZWQgdG8gcG9ydCBhbnkgcGFydCBvZiB0aGlzIHRoYXQgZG9lc24ndCB3b3JrIGluIE5vZGUgdG8gbm9kZT9cblxuLy8gVGFncyBzY3JhcGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xuY29uc3QgRXhpZlRhZ3MgPSB7IDB4MDExMjogJ29yaWVudGF0aW9uJyB9O1xuZXhwb3J0IGNvbnN0IEF2YWlsYWJsZVRhZ3MgPSBPYmplY3Qua2V5cyhFeGlmVGFncykubWFwKChrZXkpID0+IEV4aWZUYWdzW2tleV0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbk9iamVjdFVSTChzcmMsIHRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgaWYgKC9eYmxvYjovaS50ZXN0KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFVSTFRvQmxvYihzcmMpXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiBmaW5kVGFnc0luQnVmZmVyKGJ1ZmZlciwgdGFncykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJsKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YVVybC5yZXBsYWNlKC9eZGF0YTooW147XSspO2Jhc2U2NCwvZ21pLCAnJyk7XG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeS5sZW5ndGg7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gcmVhZFRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgaHR0cC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiAoaHR0cC5zdGF0dXMgPT09IDIwMCB8fCBodHRwLnN0YXR1cyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGh0dHAuc2VuZCgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbkJ1ZmZlcihmaWxlLCBzZWxlY3RlZFRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gZmlsZS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGV4aWZUYWdzID0gc2VsZWN0ZWRUYWdzLnJlZHVjZSgocmVzdWx0LCBzZWxlY3RlZFRhZykgPT4ge1xuICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcigodGFnKSA9PiBFeGlmVGFnc1t0YWddID09PSBzZWxlY3RlZFRhZylbMF07XG4gICAgICAgIGlmIChleGlmVGFnKSB7XG4gICAgICAgICAgICByZXN1bHRbZXhpZlRhZ10gPSBzZWxlY3RlZFRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgbWFya2VyO1xuXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGV4aWZUYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRFWElGRGF0YShmaWxlLCBzdGFydCwgZXhpZlRhZ3MpIHtcbiAgICBpZiAoZ2V0U3RyaW5nRnJvbUJ1ZmZlcihmaWxlLCBzdGFydCwgNCkgIT09ICdFeGlmJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcbiAgICBsZXQgYmlnRW5kO1xuXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0RDREKSB7XG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgZXhpZlRhZ3MsIGJpZ0VuZCk7XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7XG4gICAgY29uc3QgdGFncyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW50cnlPZmZzZXQgPSBkaXJTdGFydCArIGkgKiAxMiArIDI7XG4gICAgICAgIGNvbnN0IHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCkge1xuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBvdXRzdHIgPSAnJztcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRzdHI7XG59XG4iLCJpbXBvcnQgeyBmaW5kVGFnc0luT2JqZWN0VVJMIH0gZnJvbSAnLi9leGlmX2hlbHBlcic7XG5cbmNvbnN0IEltYWdlTG9hZGVyID0ge307XG5JbWFnZUxvYWRlci5sb2FkID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgY2FsbGJhY2ssIG9mZnNldCwgc2l6ZSwgc2VxdWVuY2UpIHtcbiAgICBjb25zdCBodG1sSW1hZ2VzU3JjQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgaHRtbEltYWdlc0FycmF5ID0gbmV3IEFycmF5KGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBpbWc7XG4gICAgbGV0IG51bTtcblxuICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5WzBdID0gZGlyZWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcbiAgICAgICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVtpXSA9IGAke2RpcmVjdG9yeX1pbWFnZS0keyhgMDAke251bX1gKS5zbGljZSgtMyl9LmpwZ2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZCA9IFtdO1xuICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xuICAgIH07XG4gICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCA9IGZ1bmN0aW9uIChsb2FkZWRJbWcpIHtcbiAgICAgICAgY29uc3Qgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbm90bG9hZGVkSW1ncy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3NbeF0gPT09IGxvYWRlZEltZykge1xuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ05hbWUgPSBodG1sSW1hZ2VzU3JjQXJyYXlbeV0uc3Vic3RyKGh0bWxJbWFnZXNTcmNBcnJheVt5XS5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZEltZy5zcmMubGFzdEluZGV4T2YoaW1nTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7IGltZzogbG9hZGVkSW1nIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90bG9hZGVkSW1ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2VzIGxvYWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0YWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbMF0udGFncyA9IHRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UoaW1nKTtcbiAgICAgICAgYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSkge1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKEltYWdlTG9hZGVyKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuaW1wb3J0IEltYWdlTG9hZGVyIGZyb20gJy4uL2ltYWdlX2xvYWRlcic7XG5pbXBvcnQgeyBYWVNpemUsIFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgeyBJbnB1dFN0cmVhbUZhY3RvcnksIElucHV0U3RyZWFtLCBFdmVudEhhbmRsZXJMaXN0IH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0uZCc7XG5cbmNvbnN0IGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5ID0ge1xuICAgIGNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHR5cGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0U2l6ZSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuXG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SW5wdXRTdHJlYW0oY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCAodHlwZW9mIGNvbmZpZy5zcmMgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5zcmMgOiAnJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGxheSgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnPy50eXBlICE9PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRUaW1lJywgdGltZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgICAgIF9ldmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyaWdnZXIoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjYW5yZWNvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoc2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHNpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGF0ID0gaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcbiAgICAgICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCk6IGZhbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgc2VxdWVuY2U6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIGxldCBwYXVzZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpbWdBcnJheTogYW55W10gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAxO1xuICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgKGltZ3M6IEFycmF5PHsgdGFnczogYW55OyBpbWc6IEhUTUxJbWFnZUVsZW1lbnR9PikgPT4ge1xuICAgICAgICAgICAgICAgIGltZ0FycmF5ID0gaW1ncztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sIG9mZnNldCwgc2l6ZSwgX2NvbmZpZz8uc2VxdWVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpOyAvLyBUT0RPOiB0eXBlc2NyaXB0IGNvbXBsYWlucyB0aGF0IGFueVtdIGlzIG5vdCB2YWxpZCBmb3IgYSBzZWNvbmQgYXJnIGZvciBhcHBseT8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYW55IGNvZGUgc2hhcmVkIHdpdGggdGhlIGZpcnN0IElucHV0U3RyZWFtIGFib3ZlIHNob3VsZCBiZSBzaGFyZWQgbm90IGNvcGllZFxuICAgICAgICAvLyBUT0RPOiBwdWJsaXNoRXZlbnQgbmVlZHMgYWNjZXNzIHRvIGlucHV0U3RyZWFtLCBidXQgaW5wdXRTdHJlYW0gbmVlZHMgYWNjZXNzIHRvIHB1Ymxpc2hFdmVudFxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHdoeSBpdCdzIGEgJ3ZhcicsIHNvIGl0IGhvaXN0cyBiYWNrLiAgVGhpcyBpcyB1Z2x5LCBhbmQgc2hvdWxkIGJlIGNoYW5nZWQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcblxuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgobmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShjYW52YXNTaXplKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5Py5bZnJhbWVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJZHggPCAoc2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUlkeCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnZW5kZWQnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsIi8vIFRPRE86IEl0J3MgcHJldHR5IGxpa2VseSB0aGF0IHRoaXMgc2hhcmVzIGNvZGUgd2l0aCB0aGUgYnJvd3NlciB2ZXJzaW9uLCBpbnZlc3RpZ2F0ZSB0aGF0XG5pbXBvcnQgR2V0UGl4ZWxzIGZyb20gJ2dldC1waXhlbHMnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuaW1wb3J0IHsgUG9pbnQsIFhZU2l6ZSB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlVmlkZW9TdHJlYW0gbm90IGF2YWlsYWJsZScpO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlTGl2ZVN0cmVhbSBub3QgYXZhaWxhYmxlJyk7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IG1pbWU6IHN0cmluZzsgc2l6ZTogbnVtYmVyOyBzcmM6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogZnJhbWUgc2hvdWxkIGJlIGEgdHlwZSBOZEFycmF5LCBidXQgTmRBcnJheSBkb2Vzbid0IGhhdmUgdHMgZGVmaW5pdGlvbnNcbiAgICAgICAgLy8gVE9ETzogdGhlcmUgaXMgYSB0cy1uZGFycmF5IHRoYXQgbWlnaHQgd29yaywgdGhvdWdoXG4gICAgICAgIGxldCBmcmFtZTogYW55ID0gbnVsbDtcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgICAgY29uc3QgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8gLy8gZmFsc2UgZXNsaW50IGVycm9ycz8gd2VpcmQuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcygpOiB2b2lkIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICAgICAgICAgICAgR2V0UGl4ZWxzKGJhc2VVcmwsIF9jb25maWc/Lm1pbWUsIChlcnIsIHBpeGVscykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKioqKiBxdWFnZ2EgbG9hZEltYWdlcyBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGRlY29kaW5nIHBpeGVscyBpbiBsb2FkSW1hZ2VzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKiBJbnB1dFN0cmVhbU5vZGUgcGl4ZWxzLnNoYXBlJywgcGl4ZWxzLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGZyYW1lID0gcGl4ZWxzO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdID0gcGl4ZWxzLnNoYXBlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemVcbiAgICAgICAgICAgICAgICAgICAgPyB3aWR0aCAvIGhlaWdodCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2NvbmZpZy5zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IHdpZHRoIC8gaGVpZ2h0ID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9jb25maWcuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA6IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxuICAgICAgICB2YXIgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgodykge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IHc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQoaCkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IF9jb25maWc/LnNyYztcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHN6KSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IHN6Lng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHN6Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsImltcG9ydCBCcm93c2VySW5wdXRTdHJlYW0gZnJvbSAnLi9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtX2Jyb3dzZXInO1xuaW1wb3J0IE5vZGVJbnB1dFN0cmVhbSBmcm9tICcuL2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fbm9kZSc7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLmQnO1xuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VySW5wdXRTdHJlYW07XG5leHBvcnQgeyBOb2RlSW5wdXRTdHJlYW0gfTtcbmV4cG9ydCB0eXBlIHsgSW5wdXRTdHJlYW0gfTtcbiIsImltcG9ydCBOb2RlRnJhbWVHcmFiYmVyIGZyb20gJy4vZnJhbWVfZ3JhYmJlcl9ub2RlJztcblxuaW1wb3J0IHtcbiAgICBpbWFnZVJlZixcbiAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhLFxuICAgIGNvbXB1dGVHcmF5LFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuXG5jb25zdCBUT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShjYW52YXMsIHRhcmdldFNpemUpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB0YXJnZXRTaXplLngpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGFyZ2V0U2l6ZS54O1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gdGFyZ2V0U2l6ZS55KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRTaXplLnk7XG4gICAgfVxufVxuXG5jb25zdCBGcmFtZUdyYWJiZXIgPSB7fTtcblxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSwgY2FudmFzKSB7XG4gICAgY29uc3QgX3RoYXQgPSB7fTtcbiAgICBjb25zdCBfc3RyZWFtQ29uZmlnID0gaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCk7XG4gICAgY29uc3QgX3ZpZGVvU2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xuICAgIGNvbnN0IF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpO1xuICAgIGNvbnN0IF9zaXplID0gaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpO1xuICAgIGNvbnN0IHRvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICBjb25zdCBfc3ggPSB0b3BSaWdodC54O1xuICAgIGNvbnN0IF9zeSA9IHRvcFJpZ2h0Lnk7XG4gICAgbGV0IF9jYW52YXM7XG4gICAgbGV0IF9jdHggPSBudWxsO1xuICAgIGxldCBfZGF0YSA9IG51bGw7XG5cbiAgICBfY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXMud2lkdGggPSBfY2FudmFzU2l6ZS54O1xuICAgIF9jYW52YXMuaGVpZ2h0ID0gX2NhbnZhc1NpemUueTtcbiAgICBfY3R4ID0gX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3NpemUueCAqIF9zaXplLnkpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpemU6IF9zaXplLFxuICAgICAgICAgICAgdG9wUmlnaHQsXG4gICAgICAgICAgICB2aWRlb1NpemU6IF92aWRlb1NpemUsXG4gICAgICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzU2l6ZSxcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIGdpdmVuIGFycmF5IGFzIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cbiAgICAgKiBUaGUgaW1hZ2UtZGF0YSBpcyBjb252ZXJ0ZWQgdG8gZ3JheS1zY2FsZSBhbmQgdGhlbiBoYWxmLXNhbXBsZWQgaWYgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBfdGhhdC5ncmFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkb0hhbGZTYW1wbGUgPSBfc3RyZWFtQ29uZmlnLmhhbGZTYW1wbGU7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcbiAgICAgICAgbGV0IGRyYXdhYmxlID0gZnJhbWU7XG4gICAgICAgIGxldCBkcmF3QW5nbGUgPSAwO1xuICAgICAgICBsZXQgY3R4RGF0YTtcbiAgICAgICAgaWYgKGRyYXdhYmxlKSB7XG4gICAgICAgICAgICBhZGp1c3RDYW52YXNTaXplKF9jYW52YXMsIF9jYW52YXNTaXplKTtcbiAgICAgICAgICAgIGlmIChfc3RyZWFtQ29uZmlnLnR5cGUgPT09ICdJbWFnZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZSA9IGZyYW1lLmltZztcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUudGFncyAmJiBmcmFtZS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdBbmdsZSA9IDkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSAtOTAgKiBUT19SQURJQU5TO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhd0FuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgICAgICBfY3R4LnJvdGF0ZShkcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAtX2NhbnZhc1NpemUueSAvIDIsIC1fY2FudmFzU2l6ZS54IC8gMiwgX2NhbnZhc1NpemUueSwgX2NhbnZhc1NpemUueCk7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoLWRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoLV9jYW52YXNTaXplLnggLyAyLCAtX2NhbnZhc1NpemUueSAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgMCwgMCwgX2NhbnZhc1NpemUueCwgX2NhbnZhc1NpemUueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eERhdGEgPSBfY3R4LmdldEltYWdlRGF0YShfc3gsIF9zeSwgX3NpemUueCwgX3NpemUueSkuZGF0YTtcbiAgICAgICAgICAgIGlmIChkb0hhbGZTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGN0eERhdGEsIF9zaXplLCBfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIF9kYXRhLCBfc3RyZWFtQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGcmFtZUdyYWJiZXI7XG5leHBvcnQgeyBOb2RlRnJhbWVHcmFiYmVyIH07XG4iLCIvKiBXb3JrZXIgZnVuY3Rpb25zLiBUaGVzZSBhcmUgc3RyYWlnaHQgZnJvbSB0aGUgb3JpZ2luYWwgcXVhZ2dhLmpzIGZpbGUuXG4gKiBOb3QgcHJlc2VudGx5IHVzZWQsIGFzIHdvcmtlciBzdXBwb3J0IGlzIG5vbi1mdW5jdGlvbmFsLiAgS2VlcGluZyB0aGVtIGFyb3VuZCB0ZW1wb3JhcmlseVxuICogdG8gcmVmZXIgdG8gdW50aWwgaXQgaXMgcmUtaW1wbGVtZW50ZWQuIFdlIG1heSBiZSBhYmxlIHRvIGZpeC91c2Ugc29tZSBvZiB0aGlzLlxuICovXG5cbmltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gXCIuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuXG4vLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCBpbnRlcmZhY2UgZm9yIEZyYW1lR3JhYmJlclxuXG5pbnRlcmZhY2UgUVdvcmtlclRocmVhZCB7XG4gICAgaW1hZ2VEYXRhOiBVaW50OEFycmF5O1xuICAgIGJ1c3k6IGJvb2xlYW47XG4gICAgd29ya2VyOiBXb3JrZXI7XG59XG5cbmxldCB3b3JrZXJQb29sOiBBcnJheTxRV29ya2VyVGhyZWFkPiA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlV29ya2VycyhmcmFtZUdyYWJiZXI6IGFueSkge1xuICAgIGxldCBhdmFpbGFibGVXb3JrZXI6IFFXb3JrZXJUaHJlYWQ7XG4gICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoKSB7XG4gICAgICAgIGF2YWlsYWJsZVdvcmtlciA9IHdvcmtlclBvb2wuZmlsdGVyKCh3b3JrZXJUaHJlYWQpID0+ICF3b3JrZXJUaHJlYWQuYnVzeSlbMF07XG4gICAgICAgIGlmIChhdmFpbGFibGVXb3JrZXIpIHtcbiAgICAgICAgICAgIGZyYW1lR3JhYmJlci5hdHRhY2hEYXRhKGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKGZyYW1lR3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIuYnVzeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEsXG4gICAgICAgICAgICAgICAgfSwgW2F2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEuYnVmZmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29uZmlnRm9yV29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAuLi5jb25maWcuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlKGZhY3RvcnkpIHtcbiAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICB2YXIgUXVhZ2dhID0gZmFjdG9yeSgpLmRlZmF1bHQ7XG4gICAgICAgIGlmICghUXVhZ2dhKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgJ2V2ZW50JzogJ2Vycm9yJywgbWVzc2FnZTogJ1F1YWdnYSBjb3VsZCBub3QgYmUgY3JlYXRlZCcgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4vLyBAdHMtaWdub3JlXG4gICAgdmFyIGltYWdlV3JhcHBlcjtcblxuLy8gQHRzLWlnbm9yZVxuICAgIGZ1bmN0aW9uIG9uUHJvY2Vzc2VkKHJlc3VsdCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlUmVhZHkoKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ2luaXRpYWxpemVkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuY21kID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBlLmRhdGEuY29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIgPSBuZXcgUXVhZ2dhLkltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAgICAgeDogZS5kYXRhLnNpemUueCxcbiAgICAgICAgICAgICAgICB5OiBlLmRhdGEuc2l6ZS55LFxuICAgICAgICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgUXVhZ2dhLmluaXQoY29uZmlnLCB3b3JrZXJJbnRlcmZhY2VSZWFkeSwgaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3Byb2Nlc3MnKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgUXVhZ2dhLnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3NldFJlYWRlcnMnKSB7XG4gICAgICAgICAgICBRdWFnZ2Euc2V0UmVhZGVycyhlLmRhdGEucmVhZGVycyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3JlZ2lzdGVyUmVhZGVyJykge1xuICAgICAgICAgICAgUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyKGUuZGF0YS5uYW1lLCBlLmRhdGEucmVhZGVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlV29ya2VyQmxvYigpIHtcbiAgICB2YXIgYmxvYixcbiAgICAgICAgZmFjdG9yeVNvdXJjZTtcblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBfX2ZhY3RvcnlTb3VyY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmYWN0b3J5U291cmNlID0gX19mYWN0b3J5U291cmNlX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB9XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgIGJsb2IgPSBuZXcgQmxvYihbJygnICsgd29ya2VySW50ZXJmYWNlLnRvU3RyaW5nKCkgKyAnKSgnICsgZmFjdG9yeVNvdXJjZSArICcpOyddLFxuICAgICAgICB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbTogYW55LCBjYjogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBibG9iVVJMID0gZ2VuZXJhdGVXb3JrZXJCbG9iKCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcblxuICAgIGNvbnN0IHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCA9IHtcbiAgICAgICAgd29ya2VyLFxuICAgICAgICBpbWFnZURhdGE6IG5ldyBVaW50OEFycmF5KGlucHV0U3RyZWFtLmdldFdpZHRoKCkgKiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSksXG4gICAgICAgIGJ1c3k6IHRydWUsXG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2luaXRpYWxpemVkJykge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2Iod29ya2VyVGhyZWFkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETzogaG93IHRvIHRocmVhZCBwdWJsaXNoUmVzdWx0IGludG8gaGVyZT9cbiAgICAgICAgICAgIC8vIHB1Ymxpc2hSZXN1bHQoZS5kYXRhLnJlc3VsdCwgd29ya2VyVGhyZWFkLmltYWdlRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBlcnJvcjogJyArIGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgIHNpemU6IHsgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgfSxcbiAgICAgICAgaW1hZ2VEYXRhOiB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLFxuICAgICAgICBjb25maWc6IGNvbmZpZ0Zvcldvcmtlcihjb25maWcpLFxuICAgIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eTogbnVtYmVyLCBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW0/OiBhbnksIGNiPzogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBpbmNyZWFzZUJ5ID0gY2FwYWNpdHkgLSB3b3JrZXJQb29sLmxlbmd0aDtcbiAgICBpZiAoaW5jcmVhc2VCeSA9PT0gMCAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgIH0gZWxzZSBpZiAoaW5jcmVhc2VCeSA8IDApIHtcbiAgICAgICAgY29uc3Qgd29ya2Vyc1RvVGVybWluYXRlID0gd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcbiAgICAgICAgd29ya2Vyc1RvVGVybWluYXRlLmZvckVhY2goZnVuY3Rpb24gKHdvcmtlclRocmVhZCkge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIHRlcm1pbmF0ZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXJQb29sID0gd29ya2VyUG9vbC5zbGljZSgwLCBpbmNyZWFzZUJ5KTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd29ya2VySW5pdGlhbGl6ZWQgPSAod29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkKSA9PiB7XG4gICAgICAgICAgICB3b3JrZXJQb29sLnB1c2god29ya2VyVGhyZWFkKTtcbiAgICAgICAgICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCA+PSBjYXBhY2l0eSAmJiBjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0V29ya2VyKGNvbmZpZywgaW5wdXRTdHJlYW0sIHdvcmtlckluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdzZXRSZWFkZXJzJywgcmVhZGVycyB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogYW55KSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdyZWdpc3RlclJlYWRlcicsIG5hbWUsIHJlYWRlciB9KSk7XG59XG4iLCJpbXBvcnQgeyBJbnB1dFN0cmVhbVR5cGUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgYW4gSW5wdXRTdHJlYW0gdHlwZXNjcmlwdCBpbnRlcmZhY2UsIHNvIHdlIGRvbid0IGhhdmUgYW4gXCJhbnlcIiBpbiB0aGUgbmV4dCBsaW5lXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cElucHV0U3RyZWFtKHR5cGU6IElucHV0U3RyZWFtVHlwZSA9ICdMaXZlU3RyZWFtJywgdmlld3BvcnQ6IEVsZW1lbnQgfCBudWxsLCBJbnB1dFN0cmVhbTogYW55KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ1ZpZGVvU3RyZWFtJzoge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJbWFnZVN0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4geyBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlSW1hZ2VTdHJlYW0oKSB9O1xuICAgICAgICBjYXNlICdMaXZlU3RyZWFtJzoge1xuICAgICAgICAgICAgbGV0IHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB2aWRlbyA9IHZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKHZpZGVvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCogc2V0dXBJbnB1dFN0cmVhbSBpbnZhbGlkIHR5cGUgJHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmlkZW86IG51bGwsIGlucHV0U3RyZWFtOiBudWxsIH07XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmV4cG9ydCB0eXBlIEJveCA9IEFycmF5PFsgbnVtYmVyLCBudW1iZXIgXT47XG5cbmV4cG9ydCB0eXBlIExpbmUgPSBbIFBvaW50LCBQb2ludCBdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUJveChib3g6IEJveCwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgY29ybmVyID0gYm94Lmxlbmd0aDtcbiAgICB3aGlsZSAoY29ybmVyLS0pIHtcbiAgICAgICAgYm94W2Nvcm5lcl1bMF0gKz0geE9mZnNldDtcbiAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlTGluZShsaW5lOiBMaW5lLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxpbmVbMF0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xuICAgIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMV0ueSArPSB5T2Zmc2V0O1xufVxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IFF1YWdnYUNvbnRleHQgfSBmcm9tICcuLi9RdWFnZ2FDb250ZXh0JztcbmltcG9ydCBfaW5pdEJ1ZmZlcnMgZnJvbSAnLi9pbml0QnVmZmVycyc7XG5pbXBvcnQgX2dldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xuaW1wb3J0IF9pbml0Q2FudmFzIGZyb20gJy4vaW5pdENhbnZhcyc7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi4vbG9jYXRvci9iYXJjb2RlX2xvY2F0b3InO1xuaW1wb3J0IEJyb3dzZXJJbnB1dFN0cmVhbSwgeyBOb2RlSW5wdXRTdHJlYW0gfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeSc7XG5pbXBvcnQgQnJvd3NlckZyYW1lR3JhYmJlciwgeyBOb2RlRnJhbWVHcmFiYmVyIH0gZnJvbSAnLi4vaW5wdXQvZnJhbWVfZ3JhYmJlcic7XG5pbXBvcnQgKiBhcyBRV29ya2VycyBmcm9tICcuL3F3b3JrZXInO1xuaW1wb3J0IHNldHVwSW5wdXRTdHJlYW0gZnJvbSAnLi9zZXR1cElucHV0U3RyZWFtJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcbmltcG9ydCB7IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcblxuY29uc3QgSW5wdXRTdHJlYW0gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IE5vZGVJbnB1dFN0cmVhbSA6IEJyb3dzZXJJbnB1dFN0cmVhbTtcbmNvbnN0IEZyYW1lR3JhYmJlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gTm9kZUZyYW1lR3JhYmJlciA6IEJyb3dzZXJGcmFtZUdyYWJiZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XG4gICAgY29udGV4dDogUXVhZ2dhQ29udGV4dCA9IG5ldyBRdWFnZ2FDb250ZXh0KCk7XG5cbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9ID0gX2luaXRCdWZmZXJzKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJveFNpemUgPSBib3hTaXplO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRCdWZmZXJzKGltYWdlV3JhcHBlcik7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIHJldHVybiBfZ2V0Vmlld1BvcnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWFkeShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGluaXRDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9pbml0Q2FudmFzKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvbS5vdmVybGF5O1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xuICAgIH1cblxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBCYXJjb2RlTG9jYXRvci5jaGVja0ltYWdlQ29uc3RyYWludHModGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLCB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdG9yKTtcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIgPSBGcmFtZUdyYWJiZXIuY3JlYXRlKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2wodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5udW1PZldvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbml0SW5wdXRTdHJlYW0oY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGU6IGlucHV0VHlwZSwgY29uc3RyYWludHMgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIGNvbnN0IHsgdmlkZW8sIGlucHV0U3RyZWFtIH0gPSBzZXR1cElucHV0U3RyZWFtKGlucHV0VHlwZSwgdGhpcy5nZXRWaWV3UG9ydCgpLCBJbnB1dFN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ0xpdmVTdHJlYW0nICYmIHZpZGVvKSB7XG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgY29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gaW5wdXRTdHJlYW0udHJpZ2dlcignY2FucmVjb3JkJykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKCdwcmVsb2FkJywgJ2F1dG8nKTtcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0SW5wdXRTdHJlYW0odGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSk7XG4gICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSA9IGlucHV0U3RyZWFtO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nQm94ZXMoKTogQXJyYXk8QXJyYXk8bnVtYmVyPj4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0ZSA/IEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpXG4gICAgICAgICAgICA6IFtbXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzFdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbM10pLFxuICAgICAgICAgICAgXV07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSB0b3BSaWdodC55O1xuXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3gpIHtcbiAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveGVzW2ldLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XG4gICAgICAgICAgICBFdmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYXRlQW5kRGVjb2RlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xuICAgICAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVJlc3VsdCA9IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB8fCB7fTtcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5ib3hlcyA9IGJveGVzO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGRlY29kZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0gdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUltYWdlKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoaW1hZ2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoaW1hZ2VSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlcnNVcGRhdGVkID0gUVdvcmtlcnMudXBkYXRlV29ya2Vycyh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKTtcbiAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCk7XG4gICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgbGV0IG5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBkZWxheSA9IDEwMDAgLyAodGhpcy5jb250ZXh0LmNvbmZpZz8uZnJlcXVlbmN5IHx8IDYwKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0IHx8IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA+PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgKz0gZGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmV3RnJhbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG5ld0ZyYW1lKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG5cbiAgICBzdGFydCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkICYmIHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtPy50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb250aW51b3VzVXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBRV29ya2Vycy5hZGp1c3RXb3JrZXJQb29sKDApO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0gJiYgdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogUXVhZ2dhSlNSZWFkZXJDb25maWcpOiB2b2lkIHtcbiAgICAgICAgQmFyY29kZURlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIFFXb3JrZXJzLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IFR5cGVEZWZzIGZyb20gJy4vY29tbW9uL3R5cGVkZWZzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vcmVhZGVyL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnL2NvbmZpZyc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuaW1wb3J0IFF1YWdnYSBmcm9tICcuL3F1YWdnYS9xdWFnZ2EnO1xuXG5jb25zdCBpbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcbmNvbnN0IF9jb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcblxuY29uc3QgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbmZpZywgY2IsIGltYWdlV3JhcHBlciwgcXVhZ2dhSW5zdGFuY2UgPSBpbnN0YW5jZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3OTogcGVuZGluZyByZXN0cnVjdHVyZSBpbiBJc3N1ZSAjMTc5LCB3ZSBhcmUgdGVtcCBkaXNhYmxpbmcgd29ya2Vyc1xuICAgICAgICBpZiAocXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0Lm9uVUlUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdElucHV0U3RyZWFtKGNiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXJ0KCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnN0b3AoKTtcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25EZXRlY3RlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uUHJvY2Vzc2VkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbiAocmVhZGVycykge1xuICAgICAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyBuYW1lLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyByZWFkZXIsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiAocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcXVhZ2dhSW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlKHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgLy8gVE9ETyAjMTc1OiByZXN0cnVjdHVyZSB3b3JrZXIgc3VwcG9ydCBzbyB0aGF0IGl0IHdpbGwgd29yayB3aXRoIHR5cGVzY3JpcHQgdXNpbmcgd29ya2VyLWxvYWRlclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3b3JrZXJzIHJlcXVpcmUgV29ya2VyIGFuZCBCbG9iIHN1cHBvcnQgcHJlc2VudGx5LCBzbyBpZiBubyBCbG9iIG9yIFdvcmtlciB0aGVuIHNldFxuICAgICAgICAvLyB3b3JrZXJzIHRvIDAuXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIG5vIFdvcmtlciBhbmQvb3IgQmxvYiBzdXBwb3J0IC0gZm9yY2luZyBudW1PZldvcmtlcnMgdG8gMCcpO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBCYXJjb2RlUmVhZGVyLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcbmV4cG9ydCB7XG4gICAgQmFyY29kZURlY29kZXIsXG4gICAgQmFyY29kZVJlYWRlcixcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=